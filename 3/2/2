<p>В предыдущем примере мы, чтобы иметь возможность вызывать функцию <code>foo</code> в модуле <code>main.c</code>, объявили её: <code>int foo(int);</code>. Делать это таким способом не удобно. Для каждого <code>.c</code> файла создают заголовочный (header) <code>.h</code> файл, в котором записаны объявления функций, и который мы добавляем с помощью <code>#include</code>, чтобы получить эти объявления.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p>Скомпилировать такой проект можно так:</p>

<pre><code class="language-no-highlight">gcc main.c -c
gcc foo.c -c
gcc main.o foo.o</code></pre>

<p>, либо так: <code>gcc main.c foo.c</code></p>

<p>Обычно, внешние библиотеки распространяются только в виде заголовочных и объектных файлов; без исходного кода реализаций функций. (При этом объектные файлы могут быть объединены в архивы и/или быть shared.) При этом сами реализации функций могут быть и не на языке C (мы это сделаем позже).</p>

<p>Но как компилятор может удостовериться в том, что сигнатура функции в заголовочном файле соответствует её сигнатуре в реализации, когда компилятор видит только объектный файл? (Вам придется пока поверить мне, что общих способов узнать сигнатуру функции по объектному файлу нет.) Ответ простой — никак!</p>

<p>Изменим только файл <code>foo.c</code></p>

<pre><code class="language-cpp">void foo(int x) {
    
}</code></pre>

<p>Это успешно скомпилируется и скомпонуется, а значение, которое <code>printf</code> выведет, не имеет отношения к функции <code>foo</code>.</p>