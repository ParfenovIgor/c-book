<p><code>main.c</code></p>

<pre><code class="language-cpp">int foo(int);

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p>В этой программе объявлена функция <code>foo</code>. Но её реализация отсутствует. Попробуем выполнить компиляцию без компоновки: <code>gcc main.c -c</code>. Компиляция завершена успешно и мы получили объектный файл <code>main.o</code>!</p>

<p>Если же мы попытаемся выполнить компоновку <code>gcc main.c</code>, то получим ошибку:</p>

<pre><code class="language-no-highlight">/usr/bin/ld: /tmp/cchwCA2L.o: in function `main':
main.c:(.text+0xe): undefined reference to `foo'
collect2: error: ld returned 1 exit status</code></pre>

<p>Задача компоновщика подставить реализации функций из других модулей, которые мы ему подали. Мы подали компоновщику единственный модуль, в котором он не нашел реализацию функции <code>foo</code>.</p>

<p>Как же выглядит функция <code>foo</code> в объектном файле, когда её реализация отсутствует? В инструкциях вызова этой функции не указывается её адрес (ведь он неизвестен). А информация о том, что этот адрес должен быть подставлен на этапе компоновки, хранится в секциях, в названии которых есть подстрока <code>rel</code> (проверьте, есть ли такие секции в вашем объектном файле).</p>

<p>Реализуем функцию <code>foo</code> в другом модуле.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}
</code></pre>

<p>Если мы попытаемся скомпилировать это в исполняемый файл, то получим ошибку   <code>undefined reference to `main' </code>. Скомпилируем в объектный файл <code>gcc foo.c -c</code>.      </p>

<p>Чтобы выполнить компоновку обоих объектных файлов, просто напишем их всех при вызове <code>gcc</code>: <code>gcc main.o foo.o</code>. Полученный исполняемый файл можно запустить.</p>