<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Продолжим работать с той же программой. Можно сделать вывод, что процесс сборки такой программы уже нетривиальный, и мы тратим много времени на ввод повторяющегося набора команд. Чтобы решить эту проблему, мы можем написать все команды в один <code>shell</code> скрипт, и запускать его.</p>

<p><code>build.sh</code></p>

<pre><code class="language-no-highlight">rm foo.o boo.o main.o a.out
gcc foo.c -c
gcc boo.c -c
gcc main.c -c
gcc foo.o boo.o main.o</code></pre>

<p>Все команды, кроме первой, можно объединить в одну, но в целях наглядности проблемы я намеренно напишу их так.</p>

<p>Обратите внимание на первую команду: удаление всех файлов, полученных в результате компиляции. Зачем это необходимо? Если мы допустим ошибку компиляции в одном из модулей, то соответствующий объектный файл не сформируется. Однако старый не будет удален, и скрипт продолжит выполняться. В результате мы получим либо ошибку компоновки, либо скомпонованную программу, один из модулей в которой устаревший.</p>

<p>Обратите внимание на такую проблему. Пусть мы изменили реализацию функции <code>foo</code> (но не её сигнатуру). Конечно, модуль <code>foo</code> следует перекомпилировать. Но нет смысла в перекомпиляции других модулей, ведь они никак не изменились.</p>

<p>Обратите внимание на строки 2-4 скрипта — их выполнение является независимым, и мы можем их выполнить одновременно. Сделать это с помощью <code>shell</code> скрипта непросто.</p>

<p>Пусть у нас программа является составной. Например, у нас есть компилятор и его стандартная библиотека. Скорее всего компилятору понадобиться стандартная библиотека, но в то же время, если мы хотим собрать стандартную библиотеку, нам не требуется собирать компилятор.</p>

<p>Итак, мы сформировали несколько проблем, которые решает программа <code>make</code>:</p>

<ol>
	<li>Выполнение этапа сборки только в том случае, если её результат устарел.</li>
	<li>Автоматическое распараллеливание этапов сборки.</li>
	<li>Разделение сборки на этапы и автоматическое рекурсивное определение необходимых этапов для сборки текущего этапа.</li>
</ol>