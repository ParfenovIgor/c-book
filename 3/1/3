<p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компиляция переписывает код в язык ассемблера (Assembly). Язык ассемблера мы изучим позже.</p>

<p>Выполните <code>gcc main.c -S</code>, чтобы выполнить компиляцию. Вы получите такой вывод (содержимое обрезано):</p>

<pre><code class="language-no-highlight">	.file	"main.c"
	.text
	.globl	foo
	.type	foo, @function
foo:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...</code></pre>

<p>Кратко охаректеризовать язык ассемблера можно так. У нас есть порядка десяти ячеек памяти, которые называются регистрами, и доступ к этим ячейкам самый быстрый. Кроме того у нас есть оперативная память (RAM), которая представляет собой большую ленту пронумерованных ячеек. Наша программа является последовательностью инструкций в оперативной памяти, которые имеют следующий вид:</p>

<ul>
	<li>Записать в регистр <code>D</code> значение, равное сумме значений в регистрах <code>B</code> и <code>I</code>.</li>
	<li>Записать в регистр <code>E</code> значение, записанное в оперативной памяти в ячейке под номером, который записан в регистре <code>A</code>.</li>
	<li>Если значение в регистре <code>H</code> равно нулю, то продолжить выполнение программы с инструкции, которая находится в оперативной памяти в ячейке под номером, который записан в регистре <code>C</code>.</li>
</ul>

<p>Понятно, что с одной стороны такой язык легко выучить из-за его простоты, с другой стороны его очень тяжело читать из-за отсутствия конструкций, отвечающих за высокоуровневую организацию кода.</p>