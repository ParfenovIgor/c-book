<p>Принято, что функция <code>main</code> принимает два аргумента, и её полная сигнатура на самом деле выглядит так: <code>int main(int argc, char **argv)</code>. Второй аргумент — список строк, длина которого неизвестна, а первый аргумент — длина этого списка. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>Что за список строк имеется ввиду? Это список аргументов программы. Когда мы запускаем программу в терминале, мы передаем их так: <code>./program ababba babba</code>. При таком запуске вывод программы будет такой:</p>

<pre><code>program
ababba
babba</code></pre>

<p>Первый аргумент всегда должен быть названием исполняемого файла. Мы можем нарушить это правило, если сделаем системный вызов <code>exec</code> самостоятельно, и некоторые программы в таком случае могут отказаться работать. (Что такое системные вызовы мы изучим позже.)</p>

<p>Благодаря особенностям <em>ABI</em> (что это такое, мы узнаем позже) мы можем написать в сигнатуру не все аргументы. Однако мы не можем написать большее количество аргументов, иначе они попадут на данные функции, которая нас вызвала, и мы начнем оперировать ими. (<code>main</code> — не первая функция при стандартном linker-скрипте.) Обратите внимание: компилятор никак не помешает нам этого сделать.</p>

<pre><code class="language-cpp">int main(int a, int b, int c, int d) {
    printf("%d %d %d %d\n", a, b, c, d);
    d = 5;
    return 0;
}
</code></pre>

<p>Если использовать 64-битный компилятор, то размер адресов (любых) будет 8 байт (то есть два <code>int</code>-а). Тогда переменные <code>b</code> и <code>c</code> лягут на аргумент <code>argv</code>, а переменная <code>d</code> на вызвавшую функцию. (Если бы функция <code>main</code> была первой, а мы могли бы сделать это, написав свой linker-скрипт, то мы могли бы ткнуться за пределы стека и получить ошибку исполнения.)</p>