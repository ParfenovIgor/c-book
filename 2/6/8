<p>Один из способов изменить битовую запись числа типа <code>float</code> напрямую следующий:</p>

<pre><code class="language-cpp">int main() {
    float a;
    int *b = (int*)(&amp;a);
    *b = 0x3FFFFFFF;
    printf("%f\n", a);
    return 0;
}</code></pre>

<p>(Попробуйте самостоятельно выяснить, какое число будет выведено.)</p>

<p>В C++ подобные манипуляции можно делать с помощью оператора <code>reinterpret_cast</code>. В C также можно сделать это с помощью объединений <code>union</code>.</p>

<p>Объединение реализует сумму типов (sum types), то есть её содержимое является одним из нескольких типов. Однако, в силу простоты языка C и того, как в нем объединения реализованы:</p>

<ul>
	<li>Узнать, какой тип храниться в конкретном объекте объединения без дополнительной информации, невозможно.</li>
	<li>Само обращение к объединению является лишь приведением одного и того же адреса в тип, который мы запрашиваем.</li>
</ul>

<p>Таким образом, объединения отличаются от просто приведения типа тем, что выбор типов ограничен, и у них есть псевдонимы.</p>

<pre><code class="language-cpp">union U {
    float a;
    int b;
};

int main() {
    union U u;
    u.b = 0x3FFFFFFF;
    printf("%f\n", u.a);
    return 0;
}</code></pre>

<p>Можно типам данных давать псевдонимы. Например, если мы напишем <code>typedef int i32;</code>, то мы сможем, написав <code>i32</code> создать переменную типа <code>int</code>: <code>i32 a = 3;</code>.</p>

<p>К перечислениям, структурам и объединениям можно применять такой синтаксис:</p>

<pre><code class="language-cpp">typedef int i32;

typedef struct {
    i32 a;
} S;

int main() {
    S s;
    s.a = 7;
    return 0;
}</code></pre>

<p>При таком объявлении структуры мы не должны писать ключевое слово <code>struct</code> в типе.</p>