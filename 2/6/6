<p>Перечисления (enumerations) — это способ задать числам идентификатор, привязав их при этом к контексту. Рассмотрим программу:</p>

<pre><code class="language-cpp">enum E {
    A,
    B,
    C = 10,
    D,
    E
};

int main() {
    enum E e = A;
    printf("%d %d %d %d %d %d\n", A, B, C, D, E, e);
    return 0;
}</code></pre>

<p>Мы объявляем перечисление с помощью ключевого слова <code>enum</code>, затем мы даем ему название <code>E</code> и в фигурных скобках перечисляем значения. Сами значения в перечислении используются так же, как и переменные типа число-константа <code>const int</code>. Эти значения мы можем вывести без ограничений, как и если бы это были константы. Посмотрите на логику присваивания значений им. Мы можем также объявлять объекты или инстансы (instances) перечисления, указывая их тип как <code>enum E</code>. Этот тип — это всего лишь число.</p>

<p>Вывод этой программы: <code>0 1 10 11 12 0</code></p>

<p>Здесь может возникнуть вопрос: а где же привязка к контексту (названию перечисления), ведь их содержимое ведет себя как глобальные переменные? Этой привязки нет, что является недостатком перечислений в языке C. Тем не менее, в C++ были введены классы перечислений (enum classes), которые решают этот недостаток.</p>

<p>Перейдем к структурам (structures). Они необходимы для объединения группы переменных для того, чтобы манипулировать ими одновременно. В отличии от массивов, типы переменных в структурах разные, и их количество сильно ограничено.</p>

<pre><code class="language-cpp">struct S {
    int a;
    long long b;
};

int main() {
    struct S s1;
    s1.a = 4;
    s1.b = 7;
    printf("%d %d ", s1.a, s1.b);
    
    struct S *s2 = (struct S*)malloc(sizeof(struct S));
    (*s2).a = 12;
    s2-&gt;b = 17;
    printf("%d %d\n", s2-&gt;a, s2-&gt;b);
    free(s2);
    
    return 0;
}</code></pre>

<p>Мы объявляем структуру с помощью ключевого слова <code>struct</code>, следом за которым указываем название структуры и её содержимое в фигурных скобках. Объект или инстанс структуры объявляются с указыванием типа <code>struct S</code> и названия структуры: <code>struct S s1;</code>. Как только мы объявили этот объект, у нас появились сразу две связанные переменные, к которым мы обращаемся через идентификатор <code>struct</code>.  Хоть структуры и является сложным типом, их можно передавать в функции и возвращать из них. К полям (field) структуры мы обращаемся через символ <code>.</code>.</p>

<p>Можно объявлять объекты структуры динамически. Тогда, чтобы получить доступ к полям структуры, необходимо выполнить разыменование. Так как это распространённое действие (вы даже чаще будете взаимодействовать именно с указателями на структуры), для него есть свой синтаксис <code>-&gt;</code>.</p>