<p>Для манипуляций с битами чисел используются битовые операторы. Они взаимодействуют на каждую позицию чисел-аргументов независимо и действуют аналогично одноименным логическим операторам.</p>

<ul>
	<li><code>&amp;</code> — оператор И. Например, <code>0b10110 &amp; 0b11010 = 0b10010</code>.</li>
	<li><code>|</code> — оператор ИЛИ. Например, <code>0b10101 | 0xb11001 = 0x11101</code>.</li>
	<li><code>^</code> — оператор исключающее ИЛИ. Например, <code>0x1001 ^ 0x1100 = 0x0101</code>.</li>
	<li><code>~</code> — унарный оператор НЕ. Например, для типа <code>char</code>, <code>~0b1010 = 0b11110101</code>. (Обратите внимание на зависимость от размера типа данных.)</li>
	<li><code>&lt;&lt;</code> — оператор сдвига числа налево (в сторону увеличения числа). Например, <code>0b1001 &lt;&lt; 2 = 0b100100</code>. Сдвиг не циклический. Если никакие единичные биты не пропадают, то <code>a &lt;&lt; b</code><span class="math-tex">\(= a \cdot 2 ^ b\)</span>.</li>
	<li><code>&gt;&gt;</code> — оператор сдвига числа направо (в сторону уменьшения числа). Например, <code>0b1001 &gt;&gt; 2 = 0b10</code>. Сдвиг не циклический. <code>a &gt;&gt; b</code><span class="math-tex">\(= \lfloor \frac{a}{2^b} \rfloor\)</span>.</li>
</ul>

<p>Проверить наличие <code>i</code>-го бита в числе можно так: <code>if (a &amp; (1 &lt;&lt; i))</code>.</p>

<p>Битовые операторы имеют неочевидные приоритеты. Например, если вы хотите проверить, что <code>i</code>-й бит отсутствует, то такая проверка <code>if (a &amp; (1 &lt;&lt; i) == 0)</code> некорректна, так как оператор сравнения выполнится до оператора битового И.</p>

<p>Если вы проверяете наличие <code>i</code>-го бита в числе типа <code>long long</code>, то следует делать сдвиг так: <code>1ll &lt;&lt; i</code>. Суффикс <code>ll</code> делает число <code>1</code> типа <code>long long</code>. Если же не приписать этот суффикс и проверить, например, <code>40</code>-й бит, то сначала выполнится сдвиг числа <code>1</code> типа <code>int</code> на <code>40</code> позиций, в результате чего получится ноль, который затем будет переведен в тип <code>long long</code>.</p>

<p>Подобные суффиксы есть и у других типов. Дробные числа, записанные так — <code>4.3</code> — имеют тип <code>double</code>, а не <code>float</code>, что не позволит написать, например, так: <code>const float a = 4.3;</code>(возможно, не во всех компиляторах). Числа типа <code>float</code> следует завершать символом <code>f</code>.</p>