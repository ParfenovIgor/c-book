<p>До компиляции программы выполняется её препроцессирование, которое заключается в выполнении всех строк, которые начинаются с символа <code>#</code>. Помимо включения файлов с помощью <code>#include</code>, препроцессор даёт возможность писать макросы. Макросы могут напоминать функции, но у них есть и различия.</p>

<pre><code class="language-cpp">#define FOO 5
#define DOUBLE1(x) (x * 2)
#define DOUBLE2(x) ((x) * 2)

int main() {
    printf("%d ", FOO);
    printf("%d ", DOUBLE1(4 + 1));
    printf("%d\n", DOUBLE2(4 + 1));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>5 6 10</code></p>

<p><code>#define</code> выполняет подстановку своего третьего аргумента заместо второго в каждом его вхождении в программу. Например, все вхождения <code>FOO</code> заменятся на <code>5</code>. Макросы могут иметь аргументы, которые будут также подставлены без каких либо изменений.</p>

<p>Здесь сразу обратите внимание на второе число в выводе и попробуйте самостоятельно понять, почему в результате получилось оно.</p>

<p>Чтобы это понять, раскроем макрос вручную: <code>DOUBLE1(4 + 1) -&gt; {x = "4 + 1"} -&gt; (4 + 1 * 2) = 6</code>. Это одна из главных проблем использования макросов — необходимость продумывать, как будет выполнено раскрытие. Конкретно эта проблема решается заключением аргумента макроса в скобки, чтобы сначала выполнить вычисление аргумента. Однако, не всегда решение подобных проблем простое и вообще возможное.</p>

<p>Чем макрос может быть хорош по сравнению с функцией? Он может позволить создавать подобие функции для обобщенного типа (то есть, без уточнения типа). Например, обычно с помощью макроса реализовывают функции <code>min</code> и <code>max</code>.</p>

<pre><code class="language-cpp">#define MIN(X, Y) \
    (X &lt; Y) ? X : Y

int main() {
    printf("%d %d\n", MIN(3, 5), MIN('b', 'a'));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>3 97</code></p>

<p>Символ <code>\</code> продолжает действие конструкции препроцессора на следующую строку. Здесь мы с помощью тернарного оператора написали подобие функции, которое на самом деле будет просто подставлять в код выражение с тернарным оператором: <code>MIN(3, 5) -&gt; {X = 3, Y = 5} -&gt; (3 &lt; 5) ? 3 : 5</code>.</p>

<p>Тернарный оператор <code>A ? B : C</code> похож на if-statement, но является expression. В случае, если <code>A != 0</code>, он вернёт <code>B</code>. В противном случае он вернёт <code>C</code>.</p>

<p>Если требуется в макросе выполнить последовательность действий, обычно делают так:</p>

<pre><code class="language-cpp">#define PRINT(X, Y)        \
    {                      \
        printf("%d ", X);  \
        printf("%d\n", Y); \
    }

int main() {
    PRINT(4, 7)
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>4 7</code></p>