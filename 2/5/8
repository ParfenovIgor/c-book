<p>Для выполнения таких же операций с массивами любого типа используются&nbsp;<code>mem***</code>&nbsp;функции. Естественно, функции&nbsp;<code>memlen</code>&nbsp;нет, так как только строки завершаются нулём. Не забывайте о том, что размер массива принимается в байтах, поэтому нужно домножать количество элементов на размер одного элемента.</p>

<p>Функция&nbsp;<code>void *memset(void *buf, int ch, size_t count)</code>&nbsp;устанавливает <code>len</code>&nbsp;байт массива&nbsp;<code>buf</code>&nbsp;равными младшему байту числа&nbsp;<code>ch</code>&nbsp;(старшие байты при этом игнорируются).</p>

<pre>
<code class="language-cpp">int main() {
    int a[4];
    memset(a, 0x1234, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", a[i]);
    }
    printf("%d", 0x34343434);
    
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>875836468 875836468 875836468 875836468 875836468</code></p>

<p>Функция&nbsp;<code>void *memcpy(void *dest, const void *source, size_t count)</code>&nbsp;копирует&nbsp;<code>count</code>&nbsp;байт массива&nbsp;<code>source</code>&nbsp;в массив&nbsp;<code>dest</code>.</p>

<pre>
<code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4];
    memcpy(b, a, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", b[i]);
    }
    
    return 0;
}</code></pre>

<p>Вывод этой программы будет состоять из четырёх чисел, первый три из которых:&nbsp;<code>1 2 3</code></p>

<p>Функция&nbsp;<code>int memcmp(const void *buf1, const void *buf2, size_t count)</code>&nbsp;сравнивает первые&nbsp;<code>count</code>&nbsp;элементов массивов&nbsp;<code>buf1</code>&nbsp;и&nbsp;<code>buf2</code>&nbsp;лексикографически так же, как и функция&nbsp;<code>strcmp</code>.</p>

<pre>
<code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4] = {1, 2, 3, 5};
    printf("%d ", memcmp(a, b, 3 * sizeof(int)));
    printf("%d ", memcmp(a, b, 4 * sizeof(int)));
    
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>0 -1</code></p>

<p>Следует отдавать предпочтение&nbsp;<code>mem***</code>&nbsp;функциям, так как они используют специальные ассемблерные инструкции (которые мы ещё увидим), и потому более быстрые. (Хотя <code>str***</code>&nbsp;функции в то же время тоже имеют некоторые хитрые оптимизации, связанные с итерированием не по одному символу, а по машинному слову. Но это не так сильно влияет.)</p>