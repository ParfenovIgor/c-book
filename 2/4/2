<p>В языке C присутствуют массивы, но работают они довольно странно и неочевидно. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a[10];
    a[4] = 32;
    printf("%d %d\n", a[4], sizeof(a));
    return 0;
}</code></pre>

<p>Первая строка тела функции <code>main</code> объявляет массив размера <code>10</code>. Массив — это занумерованная последовательность объектов одинакового типа. Размер массива должен быть константой, то есть известным до компиляции (<code>4 + 6</code>, например, тоже является константой).</p>

<p>На второй строке мы присваиваем четвертому элементу массива значение <code>32</code>. Массивы нумеруются с нуля. Последний индекс массива в данном случае равен <code>9</code>.</p>

<p>На третьей строке мы выводим четвертый элемент и размер массива. Вывод этой программы: <code>32 40</code>. Обратите внимание: в качестве размера массива выводится не количество его элементов, а именно занимаемая им память в байтах (напомним, что размер типа <code>int</code> равен <code>4</code> байта).</p>

<p>Что произойдет, если мы выйдем за пределы массива, сделав, например <code>a[10] = 32</code>? В конкретно этом случае, на самом деле, ничего. Точнее, присвоение произойдет, но то, что оно происходит за пределами массива, никак не будет проверено. Массив, как и все локальные переменные, а также адреса возврата функций, лежит на стеке, а в этом месте стека ничего важного не будет. Однако, в некоторых случаях, можно все-таки, перезаписать что-либо важное. Эта особенность делает программирование на C коварным, так как можно создать "отложенные ошибки": пока некорректный код работает, так как ничего не затирает, а с другими исходными данными уже будет затирать.</p>

<p>Можно создавать многомерные массивы:</p>

<pre><code class="language-cpp">int main() {
    const int n = 4, m = 5;
    int a[n][m];
    a[2][3] = 5;
    a[0][5] = 3;
    printf("%d %d\n", a[2][3], a[1][0]);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>5 3 80</code></p>

<p>Здесь мы создали двумерный массив размера <code>4x5</code>. Оперативная память адресуется линейно, и данный двумерный массив расположен в ней следующим образом: <code>a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[2][5], ...</code>. Именно поэтому, так как C не обращает внимания на выходы за границы, присваивание некорректного индекса <code>a[0][5]</code> приводит к присваиванию индекса <code>a[1][0]</code>.</p>

<p>Так как размер массива должен быть известен на момент компиляции, я должен объявить числа <code>m</code> и <code>n</code>, как константы. Значения констант нельзя менять.</p>

<p>Обратите внимания на то, что размер массива равен <code>80</code>, или <code>20</code> <code>int</code>-ов. Этот факт нам пригодится позже.</p>