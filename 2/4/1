<p>Переходим к самой интересной части языка C — указателям/адресам (pointers).</p>

<p>Указатель — это число, обозначающее ячейку в оперативной памяти. Любая локальная переменная имеет адрес, так как ей нужно где-то находиться. То же относится и к аргументам функций. (На самом деле иногда данные находятся в регистрах, но компилятор здесь будет подстраиваться под наши желания.)</p>

<p>Для взятия адреса используется унарный (с одним аргументом) оператор <code>&amp;</code>, который мы уже видели, когда использовали функцию <code>scanf</code>.</p>

<p>Тип указателя обозначается символом <code>*</code> (asterisk). Например, указатель на <code>int</code> выглядит так: <code>int*</code>. При этом синтаксис объявления указателей неочевидный и часто вызывает ошибки.</p>

<ul>
	<li>Так мы объявляем два указателя: <code>int *a, *b;</code></li>
	<li>Так мы объявляем два указателя: <code>int* a, *b;</code></li>
	<li>Так мы объявляем указатель и число: <code>int* a, b;</code></li>
</ul>

<p>Чтобы переместить данные по указателю (то есть положить их в ячейку оперативной памяти с тем же номером, что и значение указателя), используется такая запись: <code>*a = b</code>, где <code>a</code> это указатель, а <code>b</code> это данные.</p>

<p>Рассмотрим программу:</p>

<pre><code class="language-cpp">void set(int *a, int val) {
    *a = val;
}

int main() {
    int a;
    set(&amp;a, 5);
    printf("%d\n", a);
    return 0;
}</code></pre>

<p>Данная программа демонстрирует то, что я показывал выше. Функция <code>set</code> принимает аргумент типа <code>int*</code> (можно было также написать <code>int* a</code>). В функции <code>set</code> используется перемещение (этот термин не имеет отношения к тому, что с данными что-то происходит: они остаются в том же состоянии) по указателю <code>*a = val</code>. При вызове функции <code>set</code> в качестве аргумента передается адрес локальной переменной, который добывается оператором <code>&amp;</code>.</p>

<p>Вывод этой программы: <code>5</code></p>