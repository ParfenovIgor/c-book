<p>Массивы можно создавать динамически. В C нет операторов для этого, но есть стандартные функции <code>malloc</code> и <code>free</code>.</p>

<p>Функция <code>void *malloc(size_t size)</code> создает массив размера <code>size</code> байт и возвращает указатель типа <code>void</code> на его начало. <code>size_t</code> здесь — это <code>unsigned int</code>, то есть, беззнаковое (неотрицательное) целое число. Все численные типы имеют соответствующий <code>unsigned</code> тип.</p>

<p><code>void*</code> указатель обозначает указатель на "что-то", и мы должны будем определить, на что он указывает, самостоятельно. Кроме того, добавление числа <code>x</code> к <code>void*</code> указателю добавит к нему именно <code>x</code>, поэтому этот тип часто используется для создания структур данных.</p>

<p>В отличии от локальных массивов, динамические массивы выделяются не на стеке. Возможные их положения зависят от операционной системы. Как можно делать динамические выделения памяти, и как работает <code>malloc</code>, мы узнаем позже.</p>

<p>Функция <code>void free(void *ptr)</code> освобождает массив, на начало которого указывает <code>ptr</code>. Это значение должно быть ранее получено от <code>malloc</code>. В случае, если такое значение ранее не было получено от <code>malloc</code>, и, соответственно, такого массива не существует, будет ошибка исполнения.</p>

<pre><code class="language-cpp">int main() {
    int *a = (int*)malloc(10 * sizeof(int));
    a[5] = 23;
    printf("%d\n", a[5]);
    free(a);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>23</code></p>

<p>На первой строке мы выделили массив int-ов, состоящий из 10 элементов (не забывает домножать на размер элемента). Чтобы не было предупреждений от компилятора, необходимо перевести тип указателя из <code>void*</code> в <code>int*</code> с помощью <code>(int*)</code>. (При этом при переводе типа с любого указателя на любой указатель значение не изменится. Для других базовых типов это не всегда так.) Далее мы можем оперировать массивом, как любым другим. На четвертой строке мы освобождаем массив.</p>

<p>Что будет, если выйти за границы динамического массива? Обычно место, в котором выделился ваш массив, это куча — большой отрезок, на операции с которым у вашей программы есть права, а у других программ нет, и в котором выделяются куски на каждый ваш вызов функции <code>malloc</code>. Если вы попытаетесь выполнить операцию за пределами массива, но попадёте в ваш отрезок кучи, то операция будет успешной. При этом эта точка может принадлежать другому массиву, который используется в вашей программе.</p>

<p>Это ещё одна коварность языка C: вы промазали по массиву, но операция выполнилась успешно, и вы повредили память, которая позже будет использоваться. В таком случае, если вы попробуете использовать <em>дебаггер</em> для определения проблемы, он покажет тот, скорее всего корректный, код, память которого была затёрта, а не тот код, который затёр память.</p>

<p>Если же вы попадёте не в ваш отрезок кучи, то программа просто завершится из-за сигнала <em>SIGSEGV</em>.</p>

<p>Что произойдет, если вы не освободите память? На самом деле, ничего, и нет никакой проблемы не освобождать память в однопроходной программе. Вся выделенная память все равно освободится при завершении программы. Однако, если ваша программа работает длительное время, часто создавая и удаляя объекты, необходимо освобождать память, чтобы она не закончилась. Вызов функции <code>malloc</code> может вернуть <code>0</code>, что означает отказ в выделении памяти, скорее всего, по причине превышения лимита.</p>