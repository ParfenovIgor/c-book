<p>Сама архитектура задаёт только инструкции, которые мы будем видить при дизассемблировании. Однако, даже ассемблеры имеют конструкции для структуризации кода, которые называются директивами. Проблема в том, что хоть все ассемблеры имеют одинаковые инструкции (ведь их задаёт архитектура), директивы в них отличаются.</p>

<p>Мы будем пользоваться ассемблером <code>GNU Assembler</code>, который и используется в процессе компиляции программы на C компилятором gcc. Существует два основных синтаксиса  языков ассемблера: <code>AT&amp;T</code> и <code>Intel</code>. По умолчанию, gcc использует синтаксис <code>AT&amp;T</code>, с которого мы и начнём, но позже посмотрим и на второй. Чтобы gcc использовал синтаксис <code>Intel</code>, следует добавить флаг <code>-masm=intel</code>.</p>

<p>Когда мы пишем на ассемблере, следует соблюдать некоторые протоколы взаимодействия. ОС Linux использует специальные объектные файлы, поэтому, когда мы пишем программу на Linux, следует генерировать именно объектный файл. Другие ОС имеют другие структуры у подобных файлов. Если мы хотим на своей ОС иметь свой формат, аналогичный объектным файлам, нам придётся написать свой ассемблер. Также ассемблеры могут генерировать flat binary файлы, то есть файлы, состоящие непосредственно из секций, без какой-либо метаинформации. Естественно, мы их не сможем запустить на Linux-е, но они могут быть неплохой отправной точкой, когда мы пишем загрузчик программ для своей ОС.</p>

<p>Итак, перейдем к языку ассемблера.</p>

<p><code>main.s</code></p>

<pre><code class="language-no-highlight">    .text
    .globl  main
main:
    mov     $2, %rax # comment
    mov     $3, %rbx
    add     %rax, %rbx
    ret</code></pre>

<p>Первые три строки являются директивами. То есть, они говорят ассемблеру, что делать, но сами в результирующий объектный файл не попадают.</p>

<p><code>.text</code> говорит о том, что все следующие инструкции следует положить в секцию <code>text</code>. Компоновщик gcc требует наличие этой секции. Но позже мы научимся регулировать это.</p>

<p><code>.globl</code> говорит о том, что label (метка) <code>main</code> должна быть видна извне данного файла. В данном случае она нужно, чтобы компоновщик gcc увидел эту метку и записал, что выполнять программу следует с этого адреса.</p>

<p><code>main</code> — это метка, на которую мы можем ссылаться в других местах нашей программы. Каждое использование слова <code>main</code> будет заменено её адресом (каким адресом, мы узнаем позже).</p>

<p>Комментарии в gnu assembler начинаются с символа <code>#</code>.</p>

<p>Далее идут четыре инструкции. В языке ассемблера у нас есть регистры, в которых мы храним результаты провежуточных вычислений. Это ячейки памяти с самым быстрым доступом. Обычно регистров общего назначения около десяти, но помимо них могут быть десятки более специфических регистров. <code>rax</code> и <code>rbx</code> — это регистры общего назначения. Мы изучим полный их список позже. Можно воспринимать их, как очень глобальные переменные.</p>

<p>Что делают инструкции <code>mov</code> и <code>add</code> догадаться просто. Инструкция <code>mov</code> кладёт значение в первом аргументе (source — источник) во второй аргумент (destination — цель, назначение) (что происходит, когда второй аргумент не является регистром, узнаем чуть позже). Инструкция <code>add</code> складывает оба аргумента и кладёт результат во второй аргумент. Инструкция <code>ret</code> более сложная, мы её изучим позже.</p>

<p>Скомпилируем: <code>gcc main.s -o main</code> и запустим <code>./main</code>. Программа ничего не выведет. Написать ввод и вывод в языке ассемблера несколько сложнее, чем в C, и мы научимся этому позже.</p>