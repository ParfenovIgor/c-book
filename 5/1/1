<p>Начнём изучать язык ассемблера (assembly language). Мы уже знаем, что в процессе компиляции код на C переписывается на язык ассемблера, а затем он переписывается ассемблером в объектный файл с машинным кодом.</p>

<p>Для чего может быть нужно знание ассемблера? На самом деле, ответ такой же, как и на вопрос о том, зачем знать C. Мы очень не хотим писать на языке ассемблера, так как это очень сложно (чуть позже увидим почему). Обычно мы прибегаем к его использованию в следующих случаях:</p>

<ul>
	<li>Мы хотим организовать среду, в которой сможет работать код, написанный на языке C. Это касается embedded programming (встраимоевого программирования).</li>
	<li>Мы хотим изучить результат работы компилятора на предмет возможных недостатков. Иногда специфические математические алгоритмы лучше написать на языке ассемблера, так как компилятор может не догадываться, как их писать правильно.</li>
	<li>Мы пишем непосредственно генерацию кода для ассемблера.</li>
</ul>

<p>Первый случай отличается от двух других гараздо сильнее, чем может показаться на первый взгляд. Остальные случаи относятся к написанию кода на прикладном уровне. Возможно, вы уже слышали такую мудрость: Для написания кода на ассемблере достаточно знать <code>random_range(5, 10)</code> инструкций.  Для прикладного уровня это так, и с него мы и начнём изучение. Организация же среды в embedded program требует взаимодействия с состояниями процессора с помощью инструкций, которые мы, по понятной причине, не можем применять на прикладном уровне.</p>

<p>Существует много различных архитектур процессоров. Все они работают по одной модели, но отличаются множеством состояний и набором инструкций. Самые часто используемые на практике процессоры: <code>x86</code>, <code>arm</code>, <code>risс-v</code>. Подобно тому, как мы можем использовать другие операционные системы с помощью виртуальной машины, мы можем выполнить эмуляцию других процессоров (понятно, что не аппаратно, а программно). Однако, мы будем в основном работать с архитектурой <code>x86</code>, так как, скорее всего, эта архитектура и стоит на вашем компьютере.</p>