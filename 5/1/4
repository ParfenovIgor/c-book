<p>Инструкция <code>mov</code> имеет несколько вариантов. (Мне здесь не особо известна терминология. Возможно, правильно говорить, что есть неколько инструкций с названием <code>mov</code>.) Вариант, который мы использовали, имеет в качестве destination (назначения) регистр. Но назначение может быть также и адрес.</p>

<p>В языке C обычно мы начинаем изучение адресов с адресов локальных переменных. Однако, понятия локальной переменной в языке ассемблера нет — нам нужно организовать стек самостоятельно. Вызывать функции динамического выделения памяти мы тоже пока не можем. Придётся использовать глобальные переменные.</p>

<p>Здесь мы выполним более серьёзный анализ. Начнём с gnu assembly 64-bit.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, (%rax)
    ret</code></pre>

<p>Мы объявляем новую стандартную секцию <code>bss</code>, которая изначально заполнена нулями. С помощью директивы <code>.zero</code> мы объявляем последовательность из восьми байт, на начало которой указывает метка <code>arr</code>.</p>

<p>Посмотрим сначала на инструкцию <code>movq</code>. Мы взяли второй аргумент в скобки. Это означает, что мы хотим записать значение не в сам регистр, а по адресу регистра. Но какая размерность числа, которое мы записываем? (От этого зависит то, сколько старших байт регистра мы занулим.) Это мы явно сообщаем суффиксом <code>q</code> в слове <code>movq</code>.</p>

<p>Посмотрим на строку с инструкцией <code>leaq</code>. Её первый аргумент упоминает метку <code>arr</code>. Может показаться, что здесь упоминается регистр <code>rip</code>, который является адресом текущей инструкции. Но это не так, и это лишь директива ассемблеру, сообщающая о том, что адрес метки <code>arr</code> должен вычисляться относительно регистра <code>rip</code>. (Мы поговорим об этом отдельно. Дело в том, что в 64-bit мы хотим, чтобы все адреса в нашей программе были относительными. Это называется position independent code (PIC).)</p>

<p>Что делает инструкция <code>lea</code>? Она загружает не значение по адресу <code>arr</code> (что сделала бы инструкция <code>mov</code>), а сам адрес <code>arr</code>. (Здесь у знающих ассемблеры может быть вопрос — точно ли <code>mov</code> загружает значение? Да, и я сам не понимаю, почему в gnu assembly это работает так.)</p>

<p>Проверим программу. Запустите дебаггер и выведите память около адреса, равного значению регистра <code>rax</code>, с помощью команды <code>x</code>. (Эта команда имеет много параметров для форматирования вывода. Ищите "gdb cheet sheet".)</p>

<pre><code class="language-no-highlight">(gdb) x $rax
0x555555558011: 0x00000001</code></pre>

<p>Действительно, три нуля и единица.</p>

<p>Замените теперь инструкцию <code>leaq</code> на <code>movq</code>. Убедитесь, что программа получает SIGSEGV и дизассемблируйте её с помощью <code>objdump</code>: <code>objdump -d main</code>.</p>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre>

<p>Посмотрите на <code>opcode</code> этой инструкции: <code>0x8b</code> (число <code>48</code>, очевидно, не может быть opcode-ом, ведь эти две инструкции явно разные). Эта информация нам скоро понадобится.</p>

<p>Чтобы получить значение из ячейки по адресу, следует так же использовать скобки.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, (%rax)
    movq    arr(%rip), %rbx
    movq    (%rax), %rcx
    ret</code></pre>

<p>Так мы запишем значение по адресу <code>arr</code> в регистры <code>rbx</code> и <code>rcx</code>. (Третья и четвёртая инструкция эквивалентны, так как <code>rax</code> хранит адрес <code>arr</code>.)</p>

<p>Так мы можем работать с сдвинутыми адресами (например, обратиться к ненулевому индексу массива).</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   16

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, 8(%rax)
    movq    8+arr(%rip), %rbx
    ret</code></pre>

<p>Здесь мы создали массив для двух 64-bit чисел, и обращаемся ко второму, добавляя <code>8</code> к адресам. (Синтаксис этого, конечно, очень странный. В синтаксисе <code>Intel</code> это выглядит получше.)</p>