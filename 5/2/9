<p>Чтобы получить лучшее представление о том, как следует складировать локальные переменные и аргументы функций на стеке, обратимся к компилятору и посмотрим, как он это делает. Здесь же мы наконец поймем, для чего нужен регистр <code>rbp</code>.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">int boo(int x, int y) {
    return x * y;
}

int foo(int x, int y) {
    int a = x + y;
    int b = x - y;
    return boo(a, b);
}

int main() {
    int x = 2;
    int y = 3;
    int z = foo(x, y);
}</code></pre>

<p>При обычной компиляции вы будете получать такие <code>cfi*</code> директивы, которые используют дебаггеры, чтобы понять, где в стеке какие функции. Для удобства уберём их флагом <code>-fno-asynchronous-unwind-tables</code> .</p>

<p>Начнём в 64-bit.</p>

<pre><code class="language-no-highlight">$ gcc main.c -o main.S -S -masm=intel -fno-asynchronous-unwind-tables</code></pre>

<p>Пойдем по каждой функции.</p>

<pre><code class="language-no-highlight">boo:
	endbr64
	push	rbp
	mov	rbp, rsp
	mov	DWORD PTR -4[rbp], edi
	mov	DWORD PTR -8[rbp], esi
	mov	eax, DWORD PTR -4[rbp]
	imul	eax, DWORD PTR -8[rbp]
	pop	rbp
	ret</code></pre>

<p>Инструкция (не директива) <code>endbr64</code> является защитной: при определенной комбинации флагов в контрольных регистрах процессор будет производить прерывание, если вы совершите инструкцию <code>call</code> не в адрес, на котором стоит <code>endbr64</code>. (Это сделано для предотвращения атаки, при которой вы подменяете адрес и прыгаете не в начало функции.)</p>

<p>Манипуляции с регистром rbp пока не особо понятны. Этот регистр зачем-то временно сохраняется на стек и в него записывается значение регистра rsp.</p>

<p>После выполнения <code>push rbp</code> и <code>mov rbp, rsp</code> по адресу <code>rbp</code> хранится старый rbp, а по адресу <code>rbp + 8</code> хранится адрес возврата. Аргументы передаются в регистрах <code>edi</code> и <code>esi</code> (так как имеют размерность четыре байта) и сразу же сохраняются на стек (обратите внимание, что это делается не инструкцией push, поэтому регистр rsp не меняется, и поэтому выполнение инструкции call здесь затрёт аргументы). После этого выполняется умножение об эти аргументы, сохранённые на стеке.</p>

<p>Почему аргументы были сначала помещены на стек, если можно перемножить сразу регистры? Из-за низкого уровня оптимизации. (Его можно установить флагами <code>-O1</code>, <code>-O2</code> и т.д.) (На самом деле, эта задача весьма сложна, и я плохо понимаю, как её решать.)</p>

<pre><code class="language-no-highlight">foo:
	endbr64
	push	rbp
	mov	rbp, rsp
	sub	rsp, 24

	mov	DWORD PTR -20[rbp], edi
	mov	DWORD PTR -24[rbp], esi

	mov	edx, DWORD PTR -20[rbp]
	mov	eax, DWORD PTR -24[rbp]
	add	eax, edx
	mov	DWORD PTR -8[rbp], eax

	mov	eax, DWORD PTR -20[rbp]
	sub	eax, DWORD PTR -24[rbp]
	mov	DWORD PTR -4[rbp], eax

	mov	edx, DWORD PTR -4[rbp]
	mov	eax, DWORD PTR -8[rbp]
	mov	esi, edx
	mov	edi, eax
	call	boo

	leave
	ret</code></pre>

<p>Здесь я разделил программу на шесть блоков. Я в предыдущей функции говорил: "обратите внимание, что это делается не инструкцией push, поэтому регистр rsp не меняется, и поэтому выполнение инструкции call здесь затрёт аргументы". Теперь компилятор эту проблему исправил: он сдвинул регистр <code>rsp</code> на то расстояние, которое использовал в функции для локальных вычислений, а при выходе использовал инструкцию <code>leave</code> (прочитайте самостоятельно в ISA, что она делает).</p>

<p>Во втором блоке компилятор просто сохранил переданные аргументы на стек, но несколько дальше, чем в прошлый раз.</p>

<p>В третьем блоке компилятор выполнил вычисление <code>int a = x + y;</code>. Для этого он достал аргументы из стека в регистры <code>edx</code> и <code>eax</code>, сложил, и сохранил назад на стек. То же самое он сделал и в четвёртой строке для вычисления <code>int b = x - y</code>.</p>

<p>В пятом блоке компилятор достал <code>a</code> и <code>b</code> в регистры <code>edx</code> и <code>eax</code>, переместил их в регистры <code>edi</code> и <code>esi</code> и выполнил вызов функции <code>boo</code>.</p>

<p>Обратите внимание, что ячейки <code>rbp - 12</code> и <code>rbx - 16</code> не были использованы. Полагаю, это лишь из-за недостаточного уровня оптимизации.</p>

<p>Функцию main можете разобрать самостоятельно.</p>