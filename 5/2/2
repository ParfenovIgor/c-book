<p>Попробуем вызвать функцию <code>printf</code>. В 32-bit правила такие же: все аргументы должны быть положены на стек в обратном порядке их перечисления в сигнатуре (правда, мы видели, что практически сигнатура не налагает никаких ограничений).</p>

<p>Сделать это несколько проблематично: при комбинациях для компиляции и компоновки <code>gcc</code> +  <code>gcc</code> и <code>nasm</code> + <code>ld</code> у меня были нетривиальные проблемы. (В первом случае gcc упорно добавлял PIC, а во втором не получалось нормально прикомпоновать <code>libc</code>.) При комбинации <code>nasm</code> + <code>gcc</code> получилось проще всего.</p>

<p><code>main.asm</code></p>

<pre><code class="language-no-highlight">section .data
format:
    db      "Check... %d", 0xA, 0x0

section .text

extern printf

global main
main:
    push    dword 123
    push    format
    call    printf
    add     esp, 8
    ret</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf32 main.asm -o main.o
$ gcc -m32 -no-pie main.o -o main
$ ./main
Check... 123</code></pre>

<p><strong>Внимание! При выполнении операций со стеком будет поддерживаться инвариант "значение rsp делится на 8". Однако, фунцкия printf требует, чтобы значение rsp делилось на 16. Простой способ этого добиться — добавлять 8 байт на стек, когда нужно. Необходимость таких сдвигов носит случайный характер, поэтому на вашей системе код может быть нерабочим, и вам понадобится выполнить сдвиг стека самостоятельно.</strong></p>

<p>Чтобы <code>nasm</code> поверил, что метка <code>printf</code> появится на этапе компоновки, мы пользуемся директивой <code>extern</code>.</p>

<p>Под меткой <code>format</code> написана строка <code>Check... %d\n\0</code>. (Помните, что ассемблеры обычно сами не добавляют нули в конце строки. Например, в gnu assembly для создания строки без нуля и с нулём на конце используются директивы <code>.ascii</code> и <code>.asciz</code> соответственно.)</p>

<p>Обратите внимание — программа перестала завершаться SIGSEGV-ом. Это произошло потому, что gcc использовал свой скрипт для компоновки (поэтому же я также использовал метку <code>main</code>).</p>

<p>Сейчас мы впервые прикомпоновали нашу программу с функцией во внешнем объектном файле. Функция успешно вызвалась и выполнилась, потому что мы положили аргументы на стек именно так, как она ожидала. Есть некие стандарты о том, как следует передавать аргументы функциям, и как функции должны их считывать. Это необходимо, так как на таком уровне у нас нет никаких автоматических способов это контролировать (подобно тому, как в цельной программе на высокоуровневом языке C компилятор не позволит нам передать что-либо неправильно). Эти стандарты называются <code>Application Binary Interface</code> (<code>ABI</code>).</p>