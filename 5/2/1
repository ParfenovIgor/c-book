<p> Научимся писать функции.</p>

<pre><code class="language-no-highlight">section .text

set_1:
    mov     rax, 1
    ret

global _start
_start:
    mov     rax, 0
    call    set_1
    ret</code></pre>

<p>Здесь мы объявили метку <code>set_1</code>, после которой идёт реализация нашей функции (понятия функции в языке ассемблера нет).</p>

<p>Мы вызываем функцию с помощью инструкции <code>call</code>. Эта инструкция кладёт на вершину стека адрес следующей инструкции (в данном случае, инструкции <code>ret</code> в функции <code>_start</code>) и выполняет прыжок к адресу, равному значению аргумента. Мы выходим из функции с помощью инструкции <code>ret</code>. Эта инструкция вытаскивает адрес с вершины стека и прыгает в него.</p>

<p>Стек — это массив в отдельном сегменте, на который мы можем записывать данные. Мы оперируем с ним так же, как и со структурой данных "стек". Адрес текущей вершины стека хранится в регистре <code>rsp</code> (sp = stack pointer). В отличии от других регистров общего назначения, из-за обилия инструкций, которые влияют на этот регистр, мы не можем его комфортно использовать так, как мы захотим. (Это же часто касается и регистра <code>rbp</code> (bp = base pointer), но о нём позже.)</p>

<p>Проверим это. Запустим программу в дебаггере и выведем стек, находясь в функции <code>set_1</code>. Если мы выполним команду <code>ni</code>, находясь на инструкции <code>call</code>, то мы не войдём в функцию. Чтобы в неё войти, следует использовать команду <code>si</code>.</p>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│rax            0x0                 0                                                                   │
│rbx            0x0                 0                                                                   │
│rcx            0x0                 0                                                                   │
│rdx            0x0                 0                                                                   │
│rsi            0x0                 0                                                                   │
│rdi            0x0                 0                                                                   │
│rbp            0x0                 0x0                                                                 │
│rsp            0x7fffffffdc78      0x7fffffffdc78                                                      │
│r8             0x0                 0                                                                   │
│r9             0x0                 0                                                                   │
│r10            0x0                 0                                                                   │
│r11            0x0                 0                                                                   │
│r12            0x0                 0                                                                   │
│r13            0x0                 0                                                                   │
│r14            0x0                 0                                                                   │
┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│  &gt; 0x401000 &lt;set_1&gt;        mov    $0x1,%eax                                                           │
│    0x401005 &lt;set_1+5&gt;      ret                                                                        │
│B+  0x401006 &lt;_start&gt;       mov    $0x0,%eax                                                           │
│    0x40100b &lt;_start+5&gt;     call   0x401000 &lt;set_1&gt;                                                    │
│    0x401010 &lt;_start+10&gt;    ret                                                                        │
│    0x401011                add    %al,(%rax)                                                          │
│    0x401013                add    %al,(%rax)                                                          │
│    0x401015                add    %al,(%rax)                                                          │
│    0x401017                add    %al,(%rax)                                                          │
│    0x401019                add    %al,(%rax)                                                          │
│    0x40101b                add    %al,(%rax)                                                          │
│    0x40101d                add    %al,(%rax)                                                          │
│    0x40101f                add    %al,(%rax)                                                          │
│    0x401021                add    %al,(%rax)                                                          │
│    0x401023                add    %al,(%rax)                                                          │
│    0x401025                add    %al,(%rax)                                                          │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
native process 16786 In: set_1                                                        L??   PC: 0x401000 
Function "main" not defined.
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--Make breakpoint pending on future shared
library load? (y or [n]) [answered N; input not from terminal]
Breakpoint 1 at 0x401006

Breakpoint 1, 0x0000000000401006 in _start ()
(gdb) ni
0x000000000040100b in _start ()
(gdb) si
0x0000000000401000 in set_1 ()
(gdb) x/32xb $rsp
0x7fffffffdc78: 0x10    0x10    0x40    0x00    0x00    0x00    0x00    0x00
0x7fffffffdc80: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffdc88: 0x34    0xe0    0xff    0xff    0xff    0x7f    0x00    0x00
0x7fffffffdc90: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
</code></pre>

<p>Верхние четыре байта на стеке — <code>0x00401010</code>. Видно, что это же является адресом инструкции <code>ret</code> в функции <code>_start</code>. Также мы видим, что следующие четыре байта на стеке — <code>0x00000000</code>, в которые и прыгнет инструкция <code>ret</code> в функции <code>_start</code>.</p>

<p>Чтобы передать в функцию аргументы, мы должны перед её вызовом положить их в стек. (Если вы ещё не заметили по выводу в дебаггере: когда мы кладём что-либо на стек, адрес его вершины уменьшается, а когда мы вытаскиваем что-либо из стека, адрес его вершины увеличивается.) Тогда эти аргументы будут под адресом возврата, и последний аргумент, который мы положили на стек, в вызванной функции будет находится по адресу <code>[rsp + 8]</code> (или не <code>8</code>, если у вас другая разрядность программы).</p>

<pre><code class="language-no-highlight">section .text

sum:
    mov     rax, [rsp + 8]
    add     rax, [rsp + 16]
    ret

global _start
_start:
    push    2
    push    3
    call    sum
    add     rsp, 16
    ret</code></pre>

<p>Назначение функции <code>push</code> очевидно — она кладёт свой аргумент на вершину стека. Мы можем имитировать её поведение комбинацией из двух инструкций:</p>

<pre><code class="language-no-highlight">    sub     rsp, 8
    mov     dword [rsp], 2</code></pre>

<p>Чтобы вытащить аргументы, можно воспользоваться инструкцией <code>pop</code>. Но нам не нужно их вытаскивать — вместо этого мы можем просто сдвинуть адрес вершины стека.</p>