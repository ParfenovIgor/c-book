<p>Последнее, что мы здесь сделаем, это настроим прерывания (interrupts) и таблицу дескрипторов прерываний (interrupt descriptor table/IDT).</p>

<p>Прерывания приходят из трёх источников:</p>

<ul>
	<li>Ошибочное состояние процессора (обычно, это называют exceptions). Например, eip указывает на некорректную инструкцию, или мы выполнили деление на ноль, или мы пытаемся загрузить в сегментный регистр другой сегмент, который не соответствует правам.</li>
	<li>Прерывание от другого устройства. В этом случае устройство лишь говорит нам о желании "поговорить", а сам разговор выполняется инструкциями <code>in</code> и <code>out</code>. Писать драйверы для устройств сложно (хотя, для PS/2 клавиатуры не слишком сложно), поэтому мы это здесь делать не будем.</li>
	<li>Выполнение инструкции <code>int</code> (обычно, это называют software interrupts). Мы уже выполняли эту инструкцию, когда писали программы на Linux-е. Мы использовали эту инструкцию, как вызов функции, которая сделает то, что мы не имеем права сделать. При использовании этой инструкции на время текущие права меняются на полные, чтобы ОС могла выполнить запрошенную операцию. Это похоже на <code>setuid</code> флаг у программ, который может включить только владелец файла. При запуске таких программ на время их выполнения текущим пользователем становится их владелец.</li>
</ul>

<p>Прерывание характеризуется номером, значение которого от <code>0</code> до <code>255</code>. Также некоторые exceptions имеют код ошибки.</p>

<p>Чтобы настроить прерывания, нам необходимо иметь следующие структуры:</p>

<ul>
	<li>Массив размера <code>256</code>, состоящий из entries — указателей на функции и некоторых флагов. При возникновении прерывания с номером <code>x</code> будет "вызвана" функция по указателю в ячейке <code>x</code>.</li>
	<li>Записанные подряд размер массива в байтах минус один в 16-битном типе и адрес начала массива. Адрес этой структуры мы запишем в регистр таблицы прерывание.</li>
</ul>

<p>По-хорошему, нужно вдумчиво подходить к месту размещения этих двух структур. Но мы просто объявим их глобально в коде, из-за чего компилятор их поместит в секцию <code>.bss</code>. Обычно же таблица прерываний находится в очень маленьких адресах.</p>

<p><code>idt.h</code></p>

<pre><code class="language-cpp">struct _idt_entry_t {
    uint16_t base_low;
    uint16_t selector;
    uint8_t  always0;
    uint8_t  flags;
    uint16_t base_high;
} __attribute__((packed));
typedef struct _idt_entry_t idt_entry_t;

struct _idt_table_t {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));
typedef struct _idt_table_t idt_table_t;

#define N_IDT_ENTRY 256
idt_entry_t idt_entries[N_IDT_ENTRY];
idt_table_t idt_table;

void idt_flush(idt_table_t*);
void handler0();
void handler13();

void idt_set_entry(uint8_t id, uint32_t base, uint16_t selector, uint8_t flags) {
    idt_entries[id].base_low    = base &amp; 0xFFFF;
    idt_entries[id].base_high   = (base &gt;&gt; 16) &amp; 0xFFFF;

    idt_entries[id].selector    = selector;
    idt_entries[id].always0     = 0;
    idt_entries[id].flags       = flags;
}

void idt_init() {
    idt_table.limit = sizeof(idt_entry_t) * N_IDT_ENTRY - 1;
    idt_table.base = (uint32_t)&amp;idt_entries;

    memset(&amp;idt_entries, 0, sizeof(idt_entry_t) * N_IDT_ENTRY);
    idt_set_entry(0, (uint32_t)handler0, 0x10, 0x8E);
    idt_set_entry(13, (uint32_t)handler13, 0x10, 0x8E);
    idt_flush(&amp;idt_table);
}</code></pre>

<p>Итак, первыми объявляются две вышеупомянутые структуры <code>idt_entry_t</code> и <code>idt_table_t</code> и их объекты на стеке: массив <code>idt_entries</code> и одиночный объект <code>idt_table</code>. Обратите внимание, что указатель на функцию в структуре <code>idt_entry_t</code> разделён на два отрезка, которые названы <code>base_low</code> и  <code>base_high</code>. О том, что это за флаги записаны в entries, можете не задумываться.</p>

<p>А вот о поле selector можно задуматься. Это номер сегмента (или селектора), который будет автоматически выбран при возникновении прерывания. Это необходимо для временного повышения прав.</p>

<p>Ещё до установки прерываний нам необходимо настроить глобальную таблицу дескрипторов (global descriptor table/GDT). Однако, grub уже сделал это за нас. Посмотрите ещё раз на сегментные регистры в дебаггере: grub использует в качестве сегмента кода <code>0x10</code>, в качестве сегмента данных <code>0x18</code>. Мы не будем настраивать свою GDT, а воспользуемся трудами grub-а. Нам необходимо в качестве селектора передать сегмент кода <code>0x10</code>.</p>

<p>Сегменты задают уровни прав (на самом деле, когда-то они задавали и сегменты памяти, к которым мы можем обращаться, но так теперь их использовать сложно). Когда мы выполняем код пользовательской программы, должен быть выбран сегмент с низкими правами (которые, в том числе, не позволяют выбрать сегмент с полными правами). При обработке прерывания автоматически будет выбираться тот сегмент, который записан в поле selector в нашей структуре.</p>

<p>На самом деле, речь о user mode может быть достаточно длинной, так как там, помимо сегментов с правами, есть ещё страницы и процессы (tasks). Мы не будем здесь это затрагивать и ограничимся прерываниями.</p>

<p>Функции <code>handlerX</code> — это функции-обработчики, которые будут вызываться при возникновении прерываний. Мы вынуждены реализовать их на языке ассемблера, так как возвращаться из них нужно не так, как из обычных функций. Функция <code>idt_flush</code> также требует использования инструкций, которые нельзя получить на языке C. Я решил для демонстрации реализовать обработчики только для прерываний с номерами <code>0</code> и <code>13</code>.</p>

<p>Здесь используется функция <code>memset</code>. Напишите её самостоятельно.</p>