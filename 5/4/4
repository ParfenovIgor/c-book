<p>Мы можем выполнять отладку нашей ОС с помощью gdb. Добавим дополнительный рецепт в Makefile.</p>

<pre><code class="language-no-highlight">...
debug: image
	qemu-system-i386 -cdrom $(BUILD_DIR)/kernel.iso -gdb tcp::1234 -S
...</code></pre>

<p>Теперь мы можем подключиться к Qemu по порту <code>1234</code>. Для этого добавим дополнительные команды в <code>.gdbinit</code>.</p>

<pre><code class="language-no-highlight">layout asm
layout regs
set disassembly-flavor intel
target remote localhost:1234
symbol-file build/kernel
b _start
c</code></pre>

<p>Команда <code>set disassembly-flavor intel</code> меняет синтакис кода в gdb на intel.</p>

<p>Команда <code>target remote localhost:1234</code> подключает gdb к Qemu на порту <code>1234</code>.</p>

<p>Команда <code>symbol-file build/kernel</code> говорит gdb использовать символы из данного исполняемого файла. В противном случае gdb, например, не будет знать, что <code>0x200000</code> это именно секция <code>.multiboot</code>, и где находится метка <code>_start</code>.</p>

<p>Выполните <code>make debug</code> и в отдельном терминале <code>gdb</code>. Пройдите этап с grub-ом, и Qemu остановится на метке <code>_start</code>.</p>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│eax            0x2badb002          732803074                                                           │
│ecx            0x0                 0                                                                   │
│edx            0x0                 0                                                                   │
│ebx            0x10000             65536                                                               │
│esp            0x7ff00             0x7ff00                                                             │
│ebp            0x0                 0x0                                                                 │
│esi            0x0                 0                                                                   │
│edi            0x0                 0                                                                   │
│eip            0x200010            0x200010 &lt;_start&gt;                                                   │
│eflags         0x46                [ IOPL=0 ZF PF ]                                                    │
│cs             0x10                16                                                                  │
│ss             0x18                24                                                                  │
│ds             0x18                24                                                                  │
│es             0x18                24                                                                  │
│fs             0x18                24                                                                  │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
│B+&gt; 0x200010 &lt;_start&gt;       lea    edi,ds:0xb8000                                                      │
│    0x200016 &lt;_start+6&gt;     mov    BYTE PTR [edi],0x48                                                 │
│    0x200019 &lt;_start+9&gt;     mov    BYTE PTR [edi+0x2],0x65                                             │
│    0x20001d &lt;_start+13&gt;    mov    BYTE PTR [edi+0x4],0x6c                                             │
│    0x200021 &lt;_start+17&gt;    mov    BYTE PTR [edi+0x6],0x6c                                             │
│    0x200025 &lt;_start+21&gt;    mov    BYTE PTR [edi+0x8],0x6f                                             │
│    0x200029 &lt;_start+25&gt;    cli                                                                        │
│    0x20002a &lt;_start.1&gt;     hlt                                                                        │
│    0x20002b &lt;_start.1+1&gt;   jmp    0x20002a &lt;_start.1&gt;                                                 │
│    0x20002d                add    BYTE PTR [eax],al                                                   │
│    0x20002f                add    al,dl                                                               │
│    0x200031                add    BYTE PTR [eax],dl                                                   │
│    0x200033                add    BYTE PTR [esp+ebx*1],dl                                             │
│    0x200036                jl     0x200038                                                            │
│    0x200038                or     BYTE PTR [eax],ch                                                   │
│    0x20003a                cmp    al,0x2d                                                             │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre>

<p>Секция <code>.text</code> действительно находится в <code>0x200010</code>. Выполните инструкцию за инструкцией и посмотрите, как буквы по одной появляются на виртуальной машине.</p>

<p>Пора раскрыть информацию о сегментных регистрах. Обратите внимание на последние шесть регистров в списке (в моём случае, чтобы увидеть шестой, нужно прокрутить вниз): <code>cs</code>, <code>ss</code>, <code>ds</code>, <code>es</code>, <code>fs</code>, <code>gs</code>. Это сегментные регистры и в зависимости от состояния процессора они выполняют одну из двух ролей.</p>

<p>Сразу при запуске процессор находится <code>real mode</code> (реальном режиме). В таком режиме может исполняться только 16-bit код (то есть, мы явно не в этом режиме), а сегментные регистры используются для следующей цели. Так как мы работаем в 16-bit, у нас есть только 16-bit регистры. Это означает, что числом в регистре мы можем кодировать только число до <code>1 &lt;&lt; 16</code>.</p>

<p>Чтобы немного повысить диапазон чисел, которые можно кодировать, для каждой инструкции, использующей обычный регистр, выбрали один из шести сегментных регистров (причём, не всегда очевидным образом). Пусть в инструкции <code>MOV</code> выбран сегментный регистр <code>B</code>. Тогда <code>MOV [A], 0x1</code> выполнит перемещение в адрес <code>A + (B &lt;&lt; 4)</code>. Такой адрес записывают как <code>B:A</code>. (Совсем так же, как записывают, что результат инструкции <code>mul</code> помещается в <code>rdx:rax</code>, хотя это абсолютно разные вещи.)</p>

<p>Идея такого следующая. Обычно, когда мы выполняем какую-то подпрограмму, мы работает с небольшим отрезком памяти. Это означает, что мы можем сразу установить необходимые регистры и при выполнения этой подпрограммы их не трогать. После завершения мы сменим сегментные регистры, чтобы работать с другим отрезком памяти.</p>

<p>На практике же, в добавок к тому, что написание кода на ассемблере сложное, манипуляции с сегментами делают этот процесс ещё больнее. Обычно в обучениях написанию ОС вы будете видеть, что в них просто сразу записывают нули и больше их никогда не трогают.</p>

<p>Существует также <code>protected mode</code> (защищённый режим) работы процессора. Все ОС стараются немедленно в него перейти. (Правда, это ломает вспомогательные функции BIOS-а. Чтобы ими пользоваться, можно временно переключаться на real mode (для чего мы будем иметь чередующиеся куски кода на 16-bit и 32-bit, что также неприятно контролировать).) GRUB уже перешёл для нас в protected mode. О нём мы узнаем подробнее чуть позже.</p>