<p><code>idt.asm</code></p>

<pre><code class="language-no-highlight">global idt_flush
idt_flush:
    mov     eax, [esp + 4]
    lidt    [eax]
    ret</code></pre>

<p>Функция для установки регистра для IDT проста: она вызывает инструкцию <code>lidt</code>, передав ей адрес структуры.</p>

<p>Нам осталось определить обработчики. При возникновении прерывания процессор кладет на стек значения регистров <code>eip</code>, <code>cs</code>, <code>eflags</code>, <code>esp</code>, <code>ss</code>, которые были в момент возникновения прерывания, и адрес возврата. Затем, если это был exception, но на стек код ошибки, если у этого номера он есть (например, у номера <code>13</code>). Интересно отметить, что если прерывание с тем же номером вызвать инструкцией <code>int</code>, то код ошибки положен не будет. Понять в обработчике, есть ли код ошибки, придётся самостоятельно (программирование на x86 — это боль).</p>

<p>При возвращении из обработчика необходимо убрать всё, что было положено на стек. Для этого используют инструкцию <code>iret</code>.</p>

<p><code>idt.asm</code></p>

<pre><code class="language-no-highlight">...
extern handler_c

global handler0
handler0:
    cli
    push    dword 0
    push    dword 0
    call    handler_c
    sti
    add     esp, 0x8
    iret

global handler13
handler13:
    cli
    push    dword 13
    call    handler_c
    sti
    add     esp, 0x8
    iret</code></pre>

<p>Мы хотим иметь общий обработчик на C, который будет знать номер прерывания и код ошибки. Для этого в <code>handler0</code> мы кладём бессмысленный код ошибки. Из-за того, как передаются аргументы в функции, мы сможем использовать эти числа в функции на C. Обработку прерывания по-хорошему нужно проводить с выключенными прерываниями, так как мы можем временно переводить процессор в "промежуточные" состояния. Но здесь мы такого не делаем.</p>

<p>Напомню, что код ошибки кладётся только при возникновении exception-а. Я позже его намеренно вызову. Если же вы выполните инструкцию <code>int 10</code>, то ваш стек съедет.</p>

<p><code>idt.h</code></p>

<pre><code class="language-cpp">...
void handler_c(int id, int error_code) {
    printf("Interrupt: %d %d\n", id, error_code);
}</code></pre>

<p>А вот и обработчик на языке C, который просто выводит информацию. Вы ведь написали написали функции для вывода? (Подставьте здесь свои.)</p>

<p><code>kernel.c</code></p>

<pre><code class="language-cpp">...
#include "idt.h"

void kernel_main() {
    idt_init();
}</code></pre>

<p>Здесь мы просто вызвали функцию, настраивающую ITD.</p>

<p><code>boot.asm</code></p>

<pre><code class="language-no-highlight">...
_start:
    lea     esp, stack_top
    call    kernel_main
    int     0x0
    mov     ax, 0x8
    mov     ss, ax

    cli
.1: hlt
    jmp .1</code></pre>

<p>Теперь демонстрация прерываний. Выполните <code>make qemu</code>.</p>

<p>После выполнения инструкции <code>int 0x0</code>, вы увидете строку <code>Interrupt: 0, 0</code>. Затем выполнения этой функции возобновиться. Далее я пытаюсь сменить сегмент на <code>0x8</code>, но я не имею на это права. При выполнении инструкции <code>mov ss, ax</code> будет выведено <code>Interrupt 13, 8</code>, так как именно это прерывание General Protection Fault вызывается в этом случае. Здесь <code>8</code> — это код ошибки, который, похоже, говорит о том, что мы попытались выбрать сегмент <code>0x8</code>.</p>

<p>Далее происходит интересная вещь — после завершения выполнения обработчика будет предпринята ещё одна попытка выполнения инструкции <code>mov ss, ax</code>. При этом, регистра <code>ax</code> станет равным нулю, но на этот сегмент мы тоже не можем переключаться. Поэтому далее мы будем бесконечно получать <code>Interrupt 13, 0</code>.</p>

<p>Почему после обработки exception-а выполнения продолжается с той же инструкции? На самом деле, при выполнении пользовательских программ много что може потребовать вмешательства прерываний. Иногда при обращении к памяти происходит Page Fault (посмотрите номер этого прерывания). Это означает, что куска памяти, к которому вы обратились, сейчас нет в оперативной памяти. В этом случае обработчик прерывания находит место в оперативной памяти, копирует туда память программы, после чего снова выполняется инструкция обращения к памяти, которая на этот раз не вызывает Page Fault. При этом пользовательская программа никак не может узнать об этом Page Fault-е.</p>