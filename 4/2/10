<p>Рассмотрим программу.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int *a = 0;
    printf("%d\n", *a);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Segmentation fault (core dumped)</code></pre>

<p>Когда наша программа нарушает правила доступа, ей поступает сигнал <code>SIGSEGV</code>. По умолчанию при получении этого сигнала программа завершается. Мы можем сами указать, что следует сделать при получении этого сигнала. Функция <code>signal</code> принимает номер сигнала и функцию, которая будет вызвана при получении этого сигнала. Попробуем перехватит SIGSEGV.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void handler(int s) {
    printf("%d\n", s);
}

int main() {
    signal(SIGSEGV, handler);
    int *a = 0;
    printf("%d\n", *a);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">11
11
11
...</code></pre>

<p>Число <code>11</code> — это номер SIGSEGV-а. Мы не завершаем программу в нашем обработчике. После возвращения из функции handler процессор снова выполняет инструкцию, которая привела к SIGSEGV. На уровне ОС есть способы "передумать" и не выполнять инструкцию, которая приводит к ошибке. Однако у нас, как у прикладной программы, таких способов нет. Поэтому обработчик SIGSEGV-а должен завершать программу.</p>

<p>А вот и квест: программа в таком состоянии не будет слушать сигналов. Как её завершить?</p>

<p>Попробуем поиграться с разными сигналами.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void handler(int s) {
    printf("%d\n", s);
}

int main() {
    signal(SIGSEGV, handler);
    signal(SIGINT,  handler);
    signal(SIGQUIT, handler);
    signal(SIGSTOP, handler);
    signal(SIGCONT, handler);
    signal(SIGTERM, handler);
    signal(SIGKILL, handler);
    signal(SIGPIPE, handler);
    signal(SIGCHLD, handler);
    
    while(1);

    return 0;
}</code></pre>

<p>Пойдем по порядку.</p>

<p>Сигнал SIGINT вызывается при нажатии комбинации <code>Ctrl + C</code> в терминале и по умолчанию прерывает процесс. Нажмите эту комбинацию, и увидете число <code>2</code>.</p>

<p>Сигнал SIGQUIT вызывается при нажатии комбинации <code>Ctrl + \</code> в терминале и по умолчанию прерывает процесс. Нажмите эту комбинацию, и увидете число <code>3</code>.</p>

<p>Сигнал SIGSTOP вызывается при нажатии комбинации <code>Ctrl + Z</code> в терминале, то есть, при переводе процесса на фон. Нажмите эту комбинацию, однако число <code>19</code>(номер этого сигнала) вы не увидете. Дело в том, что этот сигнал особенный — его нельзя перехватить.</p>

<p>Сигнал SIGCONT вызывается при возвращении фонового процесса командой <code>fg</code>. Введите эту команду, и увидете число <code>18</code>.</p>

<p>Сигнал SIGTERM вызывается при вызове программы kill с pid нашей программы. Выполните это и увидете число <code>15</code>.</p>

<p>Сигнал SIGKILL вызывается при вызове программы kill с дополнительным аргументом <code>-9</code>. При выполнении этого программа завершится и не выведет число, так как этот сигнал нельзя перехватить.</p>

<p>Для генерации следующих сигналов потребуется внести изменения в программу.</p>

<p>Сигнал SIGPIPE вызывается при записи в закрытый stream.</p>

<pre><code class="language-cpp">...
    int fds[2];
    pipe(fds);
    close(fds[0]);
    write(fds[1], "Hello\n", 6);
...</code></pre>

<p> Сигнал SIGCHLD вызывается при завершении дочернего процесса.</p>

<pre><code class="language-cpp">...
    if (fork() == 0) {
        return 0;
    }
...</code></pre>

<p>Здесь возникнет интересная ситуация. Посмотрите на таблицу процессов любым способом (например, через <code>ps</code> или <code>top</code>). Вы увидете, что дочерний процесс ещё есть, и, более того, он не будет пропадать при сигнале SIGKILL. Дочерний процесс находиться в состоянии зомби. В этом состоянии процесс уже завершен, но ОС хранит некоторую метаинформацию, которая может быть полезна родительскому процессу. ОС уничтожит эти данные после того, как родительский процесс вызовет СВ wait. Обработчик по умолчанию делает этот вызов, но наш — нет.</p>

<pre><code class="language-cpp">...
void handler(int s) {
    printf("%d\n", s);
    wait(NULL);
}
...</code></pre>