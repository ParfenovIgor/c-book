<p>С помощью системного вызова <code>pipe</code> мы можем получить сразу два таких дескриптора, что при записи данных в один из них, мы сможем считать эти данные из другого. Эта связка дескрипторов называется pipe (канал). Функция pipe принимает указатель на массив двух чисел и записывает в первый элемент принимающего, а во второй отправителя.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fds[2];
    pipe(fds);
    
    write(fds[1], "Hello\n", 6);

    char buffer[1024];
    read(fds[0], buffer, 1024);
    printf("%s", buffer);
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">3 4
Hello</code></pre>

<p>Использование двух полученных дескрипторов никак не отличается от использования stdin/stdout. Нам просто необходимо подставлять нужный дескриптор. Обратите внимание, что если мы поменяем местами write и read, то на вызове write наша программа зависнет в ожидании ввода, который никогда не получит.</p>

<p>Напомню, что все стандартные функции вывода выполняют вывод в stdout, то есть конкретный файловый дескриптор. Пусть мы хотим, чтобы эти функции выполняли вывод в наш pipe, а не в терминал. (Который, кстати, скорее всего тоже связан с нашей программой с помощью своего pipe-а.) С помощью системного вызова <code>dup2</code> мы можем закрыть stdout stream (не путайте с stdout-дескриптором, то есть, с числом <code>1</code>) и связать его дескриптор с отправляющей стороной pipe-а. В результате и при выводе в stdout, и при выводе в <code>fds[1]</code> будет выполнен вывод в pipe.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    dup2(fds[1], STDOUT_FILENO);
    write(STDOUT_FILENO, "Hello\n", 6);
    // write(fds[1], "Hello\n", 6);
    // printf("Hello\n");
    // fflush(stdout);

    char buffer[1024];
    int cnt = read(fds[0], buffer, 1024);
    int fd = open("file", O_WRONLY, 0);
    write(fd, buffer, cnt);

    return 0;
}</code></pre>

<p>После вызова функции <code>dup2</code> и при выводе в <code>1</code>, и при выводе в <code>fds[1]</code>, будет выполнен вывод в pipe, который мы позже сможем считать через <code>fds[0]</code>. По желанию можно закрыть дескриптор <code>fds[1]</code> с помощью функции <code>close</code>: <code>close(fds[1])</code>. В таком случае вывод в <code>fds[1]</code> станет вызывать ошибку.</p>

<p>Так как теперь дескриптор <code>1</code> связан с pipe-ом, функция printf будет выводить в него. Только так как она выполняет буферизацию (то есть, копит текст, и только затем выполняет СВ write), вам необходимо будет потребовать её выполнить write сейчас с помощью функции <code>fflush</code>.</p>

<p>Так как stdout больше не связан с терминалом (и снова его связать простым способом невозможно), мы посмотрим на результат, выполним вывод в файл.</p>

<p>До сих пор мы с помощью pipe-а отправляли данные из процесса в него же. Но такое применение довольно бессмысленное. Обычно мы хотим с помощью pipe-ов передавать данные между процессами. Когда мы выполняем fork, оба процесса наследуют общий pipe, у которого теперь два дескриптора отправителя и два принимающих дескриптора. Имейте ввиду, что когда у вас два процесса считывают данные из одного pipe, то сложность системы сильно увеличивается. Это называется состоянием гонки (race condition).</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    if (fork() != 0) {
        char buffer[1024];
        write(fds[1], "Cat\n", 4);
        read(fds[0], buffer, 1024);
    }
    else {
        char buffer[1024];
        read(fds[0], buffer, 1024);
        write(fds[1], "Dog\n", 4);
    }

    return 0;
}</code></pre>

<p>Если бы отправители и/или принимающие были связаны с разными pipe-ами, какой-то из процессов бы завис в ожидании ввода. Однако, этого не происходит.</p>

<p>При некоторых конфигурациях кода мне необходимо "потыркать" stream-ы, чтобы они немедленно передали данные. Иногда они могут это не сделать сразу, из-за чего программа зависнет. Например, у меня это происходит, если заменить <code>fork() != 0</code> на <code>fork() == 0</code>.</p>

<p>В процессах детях также можно переоткрыть pipe-ы в дескрипторы стандартных потоков с помощью dup2. Вам может это понадобиться, если вы хотите запустить в дочернем процессе другую программу с помощью execve и общаться с ней через её стандартные потоки.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    if (fork() != 0) {
        char buffer[1024];
        write(fds[1], "Cat\n", 4);
        write(fds[1], "Dog\n", 4);
        write(fds[1], "Crab\n", 5);
    }
    else {
        dup2(fds[0], STDIN_FILENO);
        char *argv[] = {"/usr/bin/grep", "a", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/grep", argv, envp);
    }

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Cat
Crab</code></pre>

<p>Здесь мы передаём дочернему процессу, выполняющему программу grep, данные в стандартный ввод через наш pipe.</p>

<p>Когда вы будете сами пробовать работать с pipe-ами, у вас часто будут проблемы с недосброшенными буферами, из-за чего ваши программы будут зависать. Я не знаю, как нормально решать эту проблему. Здесь я не использовал СВ <code>close</code>, который закрывает дескриптор, но иногда он может быть необходим.</p>