<p>Возможности наших программ сильно ограничены. Многие вещи, которые наши программы в прошлом делали, например, считывали ввод или создавали файлы, на самом деле они выполняли не самостоятельно. Программы могут лишь делать что-либо в своих сегментах (если у них есть на это права) и выполнять <em>системные вызовы</em>.</p>

<p>Во время существования программы её оперативная память сильно изолирована. Программа не может получить доступ к памяти других программ. Эта изоляция достигается за счет механизма <em>paging</em>-а. Каждый процесс имеет свою <em>page directory</em>, и, когда ОС переключает процесс, она также переключает и page directory. Подробнее об этом мы узнаем позже.</p>

<p>Системные вызовы — это примерно то же самое, что и функции. Их реализует ОС. Именно с помощью них мы и делаем такие действия, как взаимодействие с stream-ами, файлами, процессами. Самостоятельно вызвать системные вызовы из кода на C мы не можем — на нём просто нет соответствующих конструкций. Мы сможем самостоятельно вызывать их из кода на Assembly, но позже. Пока мы будем пользоваться функциями-обёртками.</p>

<p>Здесь указан список системных вызовов в ОС Linux на разных архитектурах. Набор системных вызовов во всех случаях почти одинаковый, меняется лишь порядок. <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>

<p>Обратите внимание, что все ссылки в этой таблице ведут на документацию функций-обёрток в Linux-е. Многие из них вы скорее всего уже видели.</p>

<p>Важно понять, что механизм системных вызовов предоставляет архитектура (причём, все распространённые на данный момент архитектуры), но то, какие будут системные вызовы и как они будут реализованы, определяет ОС. Сравните системные вызовы в Linux с системными вызовами в Windows: <a href="https://j00ru.vexillium.org/syscalls/nt/64/" rel="noopener noreferrer nofollow">https://j00ru.vexillium.org/syscalls/nt/64/</a></p>

<p>Начнём с простого системного вызова (СВ) <code>fork</code>. Данный СВ:</p>

<ul>
	<li>не принимает никаких аргументов,</li>
	<li>создаёт новый процесс, полностью идентичный  родительскому,</li>
	<li>возвращает родителю pid ребёнка, а ребёнку <code>0</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int x = fork();
    printf("%d\n", x);
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">19025
0</code></pre>

<p>Ребёнок наследует stream-ы, и поэтому выводит в тот же терминал, что и родитель. Порядок вывода случайный. Попробуйте позапускать эту программу многократно.</p>

<p>Рассмотрим пример сложнее.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int t = 2, *v = (int*)malloc(sizeof(int));
    *v = 2;
    int x = fork();
    t++;
    (*v)++;
    printf("%d %d %d\n", x, t, *v);
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">20561 3 3
0 3 3</code></pre>

<p>Обратите внимание, что и переменная на стеке, и переменная на куче, в обоих процессах независимы. (Если бы это было не так, процесс, выполнивший вывод вторым, вывел бы <code>4</code>.) Это показывает, что и стек, и куча, копируются в новый процесс. Также это показывает, что кучи не являются общими для всех процессов. (О том, как работают кучи, и что делает <code>malloc</code>, мы узнаем позже. Обратите внимание, что системного вызова <code>malloc</code> или подобного нет.)</p>