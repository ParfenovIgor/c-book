<p>Запустим программу <code>grep</code> которая принимает как аргумент слово и ищет его в своём стандартном вводе (stdin). Как только она на очередной строке, ограниченной символом <code>\n</code> находит слово, как подстроку, она выводит всю строку.</p>

<p>Как только вы запустим программу, которая ожидает данные в стандартном вводе, мы увидем в терминале не prompt, а пустую строку. Каждая наша строка, которую мы завершаем нажатием enter-а, передаётся программе в её стандартный ввод. В свою очередь, программа может что-то выводить в свой стандартный вывод (stdout), и мы также его будем видеть.</p>

<pre><code class="language-no-highlight">$ grep a  
aaa
aaa
bbb
aba
aba</code></pre>

<p>Первую, третью и четвёртую строку ввёл я. Вторую и пятую строку вывода вывела программа grep. Всё, что мы ввели будет передаваться программе grep, пока она не закроет свой stdin, однако она его никогда не закроет. Чтобы нам закрыть его, мы должны нажать комбинацию <code>Ctrl + D</code>.</p>

<p>Мы пожем связать стандартый вывод программы с файлом. Тогда всё, что она выводит, окажется в файле. Для этого, следует к команде добавить <code>&gt; file</code>.</p>

<pre><code class="language-no-highlight">$ grep a &gt; file
aaa
bbb
aba
$ cat file
aaa
aba</code></pre>

<p>При такой команде всё, что было до этого в файле, удаляется. Чтобы вместо этого выполнить дозапись в файл, следует вместо <code>&gt;</code> написать <code>&gt;&gt;</code>.</p>

<p>Можно также связать стандартный ввод программы с файлом с помощью оператора <code>&lt;</code>. Программа <code>echo</code> выводит в стандартный вывод единственный свой аргумент.</p>

<pre><code class="language-no-highlight">$ echo aaa &gt; file
$ echo bbb &gt;&gt; file
$ echo aba &gt;&gt; file
$ grep a &lt; file
aaa
aba</code></pre>

<p>Можно запустить две программы и связать стандартный вывод одной со стандартным вводом в другой. Для этого необходимо воспользоваться оператором <code>|</code> (pipe).</p>

<pre><code class="language-no-highlight">$ cat file | grep a
aaa
aba</code></pre>

<p>Stdin и stdout — это streams. (Данное слово, как и слова thread и flow переведены на русский язык, как поток. Причём, по смыслу эти три слова совсем не близки.) Есть ещё один частоиспользуемый stream — стандартный вывод ошибок (stderr). В него обычно пишут программы при нарушении правил общения с ними.</p>

<p>В терминале мы видим и stdout и stderr от выполняемой программы, и отличить их нельзя. Попробуем перенаправить stdout у этой команды.</p>

<pre><code class="language-no-highlight">$ ls dirrr &gt; out
ls: cannot access 'dirrr': No such file or directory
$ cat out</code></pre>

<p>Не перенаправилось. Значит, эту строку ls вывел в stderr. Чтобы перенаправить его, следует воспользоваться оператором <code>2&gt;</code>.</p>

<pre><code class="language-no-highlight">$ ls dirrr 2&gt; out
$ cat out
ls: cannot access 'dirrr': No such file or directory</code></pre>

<p>Чтобы перенаправить оба потока в один файл, следует написать так.</p>

<pre><code class="language-no-highlight">$ ls &gt; out 2&gt;&amp;1</code></pre>

<p>Чтобы в программе на C выполнить вывод в stderr, можно воспользоваться функцией <code>fprintf</code>, которая первым аргументом принимет дескриптор stream-а. Дескриптор stderr-а храниться в глобальной переменной <code>stderr</code>.</p>

<pre><code class="language-cpp">fprintf(stderr, "%d\n", 42);</code></pre>

<p>Теперь мы можем понять, что когда мы в самом начале запустили <code>sh</code>, то мы начали с ним интерактивную сессию, такую же, как и с <code>grep</code> здесь. Мы можем её прервать комбинацией <code>Ctrl + D</code>.</p>