<p>Следующая функция  <code>char* strtok( char* str, const char* delim );</code> более сложная в использовании. Эта функция используется для разбиения строки <code>str</code> на токены. Аргумент <code>delim</code> хранит символы-разделители токенов. Рассмотрим программу:</p>

<pre><code class="language-cpp">#define NULL 0

int main() {
    char str[] = "ab;cde,fghi";
    
    char *a = strtok(str, ",;");
    printf("%d ", strlen(str));
    printf("%d ", strlen(a));
    
    char *b = strtok(NULL, ",;");
    printf("%d ", strlen(b));
    
    char *c = strtok(NULL, ",;");
    printf("%d ", strlen(c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>2 2 3 4</code></p>

<p>Пусть разделителями будут символы <code>,</code> и <code>;</code>. Сначала выполним такой вызов функции: <code>strtok(str, ",;");</code>. В результате этого вызова вместо первого разделителя в изначальной строке <code>;</code> будет поставлен нулевой символ, будет возвращен указатель на первый символ, не являющийся разделителем (а наша строка не начинается с разделителей, поэтому будет возвращен <code>str</code>) , а внутри функции <code>strtok</code> будет неким образом создана запись о том, какой последний символ был обработан.</p>

<p>Затем выполним вызов <code>strtok(NULL, ",;");</code>. В результате этого вызова повторятся те же действия, но не с аргумента (который теперь просто <code>0</code>), а с последнего обработанного символа (видимо, с того, который стал нулевым, но это уже нам неизвестно). Сначала пропустятся следующие два разделителя <code>;</code> до первого, не разделительного символа <code>c</code>. Затем будет найден следующий разделительный символ <code>,</code> и заменен на нулевой символ. И наконец, будет возвращён указатель на символ <code>c</code>.</p>

<p>Строка <code>#define NULL 0</code> заменяет все вхождения идентификаторов <code>NULL</code> в нижестоящем коде на <code>0</code> до компиляции программы. Но об этом мы поговорим позже.</p>