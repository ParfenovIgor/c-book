<p>Функции "видят" другие функции, объявленные выше. Но если мы хотим написать две вызывающие друг друга функции, то с помощью только определений функций сделать этого, возможно, не удастся. Такой код в C++ некорректен, но в C корректен (возможно, не во всех компиляторах):</p>

<pre><code class="language-cpp">void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Решить эту проблему можно с помощью объявления функции, или, <em>прототипа</em> функции. Выглядит он так:</p>

<pre><code class="language-cpp">void boo(int n);

void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Прототип функции объявляет лишь сигнатуру. Названия аргументов в нем не важны, и, если мы заменим первую строку на <code>void boo(int);</code>, то это будет по прежнему корректно.</p>

<p>Прототип функции должен соответствовать определению функции. Если прототип здесь будет <code>void boo(long long n);</code>, то это вызовет ошибку компиляции.</p>

<p>Очень важно, что если прототип функции, и её определение будут в разных модулях, то компилятор не сможет заметить несоответствия сигнатур функций. В таком случае во время выполнения программы при вызове функции стек "съедет", и произойдет stack corruption. (Более подробно этот механизм мы изучим позже.)</p>