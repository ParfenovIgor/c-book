<p>Массивы практически являются указателями. Можно перевести массив в указатель. Рассмотрим программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int a[10];
    int *b = a;
    *(b + 4) = 32;
    printf("%d %d %d\n", b[4], sizeof(a), sizeof(b));
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>32 40 4</code> или <code>32 40 8</code>, в зависимости от разрядности вашего компилятора.</p>

<p>Если вы добавляете к указателю типа <code>T*</code> число <code>x</code>, то на самом деле к указателю добавиться число <code>x * sizeof(T)</code>.</p>

<p><code>*(b + 4)</code> сначала добавляет к  <code>b</code> значение <code>4 * sizeof(int)</code>, а затем <em>разыменовывает</em> (берет значение в этой ячейке памяти) его. Комичный факт, что <code>b[4] == *(b + 4) == *(4 + b) == 4[b]</code>.</p>

<p>Обратите внимание: вы можете делать операции с указателями так же, как и с массивами. Но есть одна разница: <code>sizeof</code> для указателя возвращает размер указателя, а не всего массива. Более того, имея только указатель, узнать размер массива невозможно. То есть, тип указатель, в отличии от типа массив, не знает размер.</p>

<p>Массивы нельзя передавать в функции. Поэтому, чтобы знать в функции размер массива, приходится передавать и размер:</p>

<pre><code class="language-cpp">int sum(int n, int *a) {
    int x = 0, i;
    for (i = 0; i &lt; n; i++) {
        x += a[i];
    }
    return x;
}

int main() {
    int a[5] = {2, 5, 1, 4, 3};
    int n = sizeof(a) / sizeof(a[0]);
    printf("%d\n", sum(n, a));
    return 0;
}</code></pre>

<p>Обратите внимание на синтаксис присваивания значений элементам массива <code>int a[5] = {2, 5, 1, 4, 3};</code>, и на то, как можно узнать количество элементов локального массива, разделив его размер на размер одного из его элементов (часто даже создают такой макрос).</p>