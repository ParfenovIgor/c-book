<!DOCTYPE html>

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">    
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <title>C - Язык Программирования</title>
  <style>      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }
      table ul {
        list-style-type: none;
        padding: 0em;
      }
      table li {
        padding-bottom: 1em;
        line-height:1.2em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.5em;
      }
      th[scope=row] {
          text-align: left;
          font-weight: normal;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      a:hover,a:focus {
        background: #fff2a8;
      }
      dt {
        font-weight: bold;
      }
      .sgr-1m {
        font-weight: bold;
      }
      .sgr-2m {
        color: #575757;
      }
      .sgr-31_1m {
        color: #b40000;
      }
      .sgr-32_1m {
        color: green;
      }
      .sgr-36_1m {
        color: #005C7A;
      }
      .file {
        font-weight: bold;
        border: unset;
      }
      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      samp {
        background: #fafafa;
      }
      pre > samp {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      kbd {
        font-weight: normal;
      }
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      figure {
        margin: auto 0;
      }
      figure pre {
        margin-top: 0;
      }

      figcaption {
        padding-left: 0.5em;
        font-size: small;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }
      figcaption.zig-cap {
        background: #fcdba5;
      }
      figcaption.c-cap {
        background: #a8b9cc;
        color: #000;
      }
      figcaption.peg-cap {
        background: #fcdba5;
      }
      figcaption.javascript-cap {
        background: #365d95;
        color: #fff;
      }
      figcaption.shell-cap {
        background: #ccc;
        color: #000;
      }

      aside {
        border-left: 0.25em solid #f7a41d;
        padding: 0 1em 0 1em;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      th pre code {
          background: none;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#121212;
            color: #ccc;
        }
        a {
            color: #88f;
        }
        a:hover,a:focus {
            color: #000;
        }
        table, th, td {
            border-color: grey;
        }
        .sgr-2m {
            color: grey;
        }
        .sgr-31_1m {
            color: red;
        }
        .sgr-32_1m {
            color: #00B800;
        }
        .sgr-36_1m {
            color: #0086b3;
        }
        code {
          background: #222;
          border-color: #444;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        samp {
          background: #000;
          color: #ccc;
        }
        pre > samp {
          border: unset;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        figcaption.zig-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.peg-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.shell-cap {
          background: #2a2a2a;
          color: #fff;
        }
      }
</style>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

<body>
  <header><h1>C - Язык Программирования</h1></header>
  
  <div id="main-wrapper">
    <div id="navigation">        
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Содержание</h2>
        <ul>          
        <li><a href="#1">1. Введение</a>
            <ul>
              <li><a href="#1.1">1.1. Об этом курсе</a>
                <ul>
                  <li><a href="#1.1.1">1.1.1</a></li>
                </ul>
              </li>
              <li><a href="#1.2">1.2. О чём нужно знать</a>
                <ul>
                  <li><a href="#1.2.1">1.2.1</a></li>
                  <li><a href="#1.2.2">1.2.2</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#2">2. Вид сверху на C</a>
            <ul>
              <li><a href="#2.1">2.1. Введение</a>
                <ul>
                  <li><a href="#2.1.1">2.1.1</a></li>
                  <li><a href="#2.1.2">2.1.2</a></li>
                  <li><a href="#2.1.3">2.1.3</a></li>
                  <li><a href="#2.1.4">2.1.4</a></li>
                  <li><a href="#2.1.5">2.1.5</a></li>
                  <li><a href="#2.1.6">2.1.6</a></li>
                  <li><a href="#2.1.7">2.1.7</a></li>
                  <li><a href="#2.1.8">2.1.8</a></li>
                </ul>
              </li>
              <li><a href="#2.2">2.2. Контроль потока</a>
                <ul>
                  <li><a href="#2.2.1">2.2.1</a></li>
                  <li><a href="#2.2.2">2.2.2</a></li>
                  <li><a href="#2.2.3">2.2.3</a></li>
                  <li><a href="#2.2.4">2.2.4</a></li>
                  <li><a href="#2.2.5">2.2.5</a></li>
                  <li><a href="#2.2.6">2.2.6</a></li>
                  <li><a href="#2.2.7">2.2.7</a></li>
                  <li><a href="#2.2.8">2.2.8</a></li>
                  <li><a href="#2.2.9">2.2.9</a></li>
                  <li><a href="#2.2.10">2.2.10</a></li>
                </ul>
              </li>
              <li><a href="#2.3">2.3. Функции</a>
                <ul>
                  <li><a href="#2.3.1">2.3.1</a></li>
                  <li><a href="#2.3.2">2.3.2</a></li>
                  <li><a href="#2.3.3">2.3.3</a></li>
                  <li><a href="#2.3.4">2.3.4</a></li>
                  <li><a href="#2.3.5">2.3.5</a></li>
                  <li><a href="#2.3.6">2.3.6</a></li>
                  <li><a href="#2.3.7">2.3.7</a></li>
                </ul>
              </li>
              <li><a href="#2.4">2.4. Указатели</a>
                <ul>
                  <li><a href="#2.4.1">2.4.1</a></li>
                  <li><a href="#2.4.2">2.4.2</a></li>
                  <li><a href="#2.4.3">2.4.3</a></li>
                  <li><a href="#2.4.4">2.4.4</a></li>
                  <li><a href="#2.4.5">2.4.5</a></li>
                  <li><a href="#2.4.6">2.4.6</a></li>
                  <li><a href="#2.4.7">2.4.7</a></li>
                  <li><a href="#2.4.8">2.4.8</a></li>
                  <li><a href="#2.4.9">2.4.9</a></li>
                  <li><a href="#2.4.10">2.4.10</a></li>
                  <li><a href="#2.4.11">2.4.11</a></li>
                </ul>
              </li>
              <li><a href="#2.5">2.5. Строки</a>
                <ul>
                  <li><a href="#2.5.1">2.5.1</a></li>
                  <li><a href="#2.5.2">2.5.2</a></li>
                  <li><a href="#2.5.3">2.5.3</a></li>
                  <li><a href="#2.5.4">2.5.4</a></li>
                  <li><a href="#2.5.5">2.5.5</a></li>
                  <li><a href="#2.5.6">2.5.6</a></li>
                  <li><a href="#2.5.7">2.5.7</a></li>
                  <li><a href="#2.5.8">2.5.8</a></li>
                </ul>
              </li>
              <li><a href="#2.6">2.6. Структуры</a>
                <ul>
                  <li><a href="#2.6.1">2.6.1</a></li>
                  <li><a href="#2.6.2">2.6.2</a></li>
                  <li><a href="#2.6.3">2.6.3</a></li>
                  <li><a href="#2.6.4">2.6.4</a></li>
                  <li><a href="#2.6.5">2.6.5</a></li>
                  <li><a href="#2.6.6">2.6.6</a></li>
                  <li><a href="#2.6.7">2.6.7</a></li>
                  <li><a href="#2.6.8">2.6.8</a></li>
                </ul>
              </li>
              <li><a href="#2.7">2.7. Функции высшего порядка, макросы, шаблоны</a>
                <ul>
                  <li><a href="#2.7.1">2.7.1</a></li>
                  <li><a href="#2.7.2">2.7.2</a></li>
                  <li><a href="#2.7.3">2.7.3</a></li>
                  <li><a href="#2.7.4">2.7.4</a></li>
                  <li><a href="#2.7.5">2.7.5</a></li>
                  <li><a href="#2.7.6">2.7.6</a></li>
                  <li><a href="#2.7.7">2.7.7</a></li>
                </ul>
              </li>
            </ul>
          </li>
          <li><a href="#3">3. Компиляция, gcc</a>
            <ul>
              <li><a href="#3.1">3.1. Фазы компиляции</a>
                <ul>
                  <li><a href="#3.1.1">3.1.1</a></li>
                  <li><a href="#3.1.2">3.1.2</a></li>
                  <li><a href="#3.1.3">3.1.3</a></li>
                  <li><a href="#3.1.4">3.1.4</a></li>
                  <li><a href="#3.1.5">3.1.5</a></li>
                  <li><a href="#3.1.6">3.1.6</a></li>
                </ul>
              </li>
              <li><a href="#3.2">3.2. Многомодульные программы</a>
                <ul>
                  <li><a href="#3.2.1">3.2.1</a></li>
                  <li><a href="#3.2.2">3.2.2</a></li>
                  <li><a href="#3.2.3">3.2.3</a></li>
                  <li><a href="#3.2.4">3.2.4</a></li>
                  <li><a href="#3.2.5">3.2.5</a></li>
                  <li><a href="#3.2.6">3.2.6</a></li>
                </ul>
              </li>
              <li><a href="#3.3">3.3. GNU make</a>
                <ul>
                  <li><a href="#3.3.1">3.3.1</a></li>
                  <li><a href="#3.3.2">3.3.2</a></li>
                  <li><a href="#3.3.3">3.3.3</a></li>
                  <li><a href="#3.3.4">3.3.4</a></li>
                  <li><a href="#3.3.5">3.3.5</a></li>
                  <li><a href="#3.3.6">3.3.6</a></li>
                  <li><a href="#3.3.7">3.3.7</a></li>
                  <li><a href="#3.3.8">3.3.8</a></li>
                  <li><a href="#3.3.9">3.3.9</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>

    <div id="contents-wrapper">
      <main id="contents">

<h2 id="1">1. Введение</h2>

<h3 id="1.1">1.1. Об этом курсе</h3>
<h3 id="1.1.1">1.1.1</h2><p>Здравствуй, уважаемый читатель. Добро пожаловать на курс по языку программирования C. Однако, скорее всего, если ты ещё не погружен в эту тему, этот курс окажется намного глубже, чем ты сейчас ожидаешь. Здесь мы не ограничимся только такими вещами, как типы данных, ветвления, функции и указатели, а лишь начнём с этого.</p>

<p>Попробуем подумать над такой идеей &mdash; а зачем нужен язык C? При поверхностном взгляде на него кажется, что у него нет таких сторон, с которых его бы не обходил какой-либо другой язык. Когда мы должны его использовать? Ответ &mdash; когда мы не можем развернуть среду для других языков. Язык C очень независимый. Полностью регулировать зависимости програм, написанных на нём, очень просто. То же самое касается и структуры результирующих программ. А это означает, что изучать язык C без понимания о том, как управлять процессом компиляции, не имеет смысла.</p>

<p>Немного о том, как следует работать с этим курсом. Если вы уже можете компилировать и запускать программы на C на какой-либо системе &mdash; можете сразу переходить к модулю <em>Вид сверху на C</em>, минуя пункт 1.2. Даже если вы уже знаете заявленный там контент, всё равно есть смысл пролистать текст, так как в нём есть полезные идеи. После завершения изучения этого модуля читайте пункт 1.2, который расскажет о том, как получить необходимую для нашей работы среду, и переходите к остальным модулям.</p>

<p>Мне было лень писать большое количество текста, поэтому информация в тексте очень концентрированная. Убедитесь, что вы понимаете каждую идею, которую я даю в тексте. То же самое касается и заданий &mdash; обычно это не просто вопросы к тексту параграфа, а задачи, требующие изучения и обдумывания какой-либо идеи. Иногда в качестве заданий будут даваться проекты, которые дают большую свободу действий.</p>
<h3 id="1.2">1.2. О чём нужно знать</h3>
<h3 id="1.2.1">1.2.1</h2><h3>Компилятор для С</h3>

<p>На протяжении первого модуля допустимо использовать любые компиляторы и любые IDE, а также online компиляторы, например, <a href="https://godbolt.org/" rel="noopener noreferrer nofollow">godbolt</a> (обратите внимание на количество доступных компиляторов там).</p>

<p>Для удобства мы будем работать с операционной системой <code>Linux</code>, так как она имеет более простой и сильный <code>shell</code>, более простое и понятное внутреннее устройство, которое мы также будем изучать, и более удобные необходимые нам инструменты.</p>

<p>Важно определить и понять, какие компиляторы мы будем использовать. Хоть и с верхней стороны язык C в них идентичен, с нижней стороны они могут сильно отличаться. Я выбрал компилятор <code>gcc</code>. Это стандартный компилятор в системах <code>Linux</code>, и в большинстве дистрибутивов он установлен изначально.</p>

<p>На <code>Windows</code> имеется компилятор <code>mingw</code>, который заявлен, как порт gcc на Windows. Его можно установить, например, вместе с <code>IDE</code> <code>Codeblocks</code>, а затем добавить исполняемый файл в переменную PATH.</p>

<p>Идея курса в "сквозном" изучении компилятора gcc, поэтому разрешается пользоваться IDE только в течении первого модуля. Далее мы будем запускать gcc только с помощью терминала. До начала второго модуля убедитесь, что gcc доступен в терминале.</p>

<p>Существуют альтернативные компиляторы, которые имеет смысл изучить, но которые не будут покрыты данным курсом.</p>

<ul>
	<li><code>MSVC</code>. О данном компиляторе мне известно мало. Он предназначен только для Windows, и с его установкой могут быть проблемы.</li>
	<li><code>Clang</code>. Данный компилятор имеет другой "путь" компиляции, в процессе которого используется язык <code>llvm</code>. Предназначен для обеих ОС.</li>
	<li><code>Zig</code>. Помимо того, что zig является отдельным языком, его компилятор является хорошей альтернативой другим компиляторам языка C.</li>
</ul><h3 id="1.2.2">1.2.2</h2><h3>Система</h3>

<p>В случае, если ваша основная операционная система — Windows, прочитайте этот раздел.</p>

<p>Все дистрибутивы Linux без проблем позволяют поставить на один диск (HDD/SSD) несколько ОС Linux. В таком случае при запуске компьютера будет загружаться сначала <code>загрузчик</code> (обычно, <code>grub</code>), который будет спрашивать у вас, какую ОС на этот раз загрузить. Однако установка к Linux-у на диск ОС Windows, насколько мне известно, является нестабильным способом, так как Windows иногда затирает загрузчик Linux-а.</p>

<p>Возможные способы:</p>

<ul>
	<li>Если у вас имеется дополнительный диск (HDD/SSD), можете поставить на него вторую ОС. При такой установке Windows не будет трогать другой диск (а в некоторых вариантах установки даже и не сможет его видеть). Так как вы ставите Linux к уже рабочей Windows, либо выберите дистрибутив с хорошим GUI (например, <code>Ubuntu</code>), либо попросите помощи, чтобы случайно не затереть не тот диск.</li>
	<li>Если на вашем компьютере есть хотя бы 8 Gb <code>RAM</code> (оперативной памяти), вы можете поставить виртуальную машину. Я рекомендую программу <code>VirtualBox</code>. В ней выделите виртуальной машине примерно половину своей оперативной памяти, не менее двух процессорных ядер и не менее 30 Gb дисковой памяти (если вы знаете свой дистрибутив, этот размер может быть намного меньше). Лучше поставьте легковесный <code>DE</code> (desktop environment), например, XFCE.</li>
	<li><code>WSL</code>, однако я им никогда не пользовался и ничего о нём не знаю.</li>
</ul>

<p>Что не рекомендуется:</p>

<ul>
	<li>Ставить Linux на один диск с Windows (но может, кто-то сможет убедить меня в обратном)</li>
	<li>Использовать Cygwin. У этого способа виртуализации большие проблемы с пакетами.</li>
	<li>Использовать не аппаратную виртуализацию (например, <code>QEMU</code> имеет аппаратную виртуализацию только на Linux).</li>
</ul>

<p>Возможные проблемы с <code>VirtualBox</code>:</p>

<ul>
	<li>Зависания машины намертво. Это происходит из-за того, как VirtualBox эмулирует диск. Вы можете заметить, что на гостевой ОС заканчивается Swap, а на хостовой ОС потребление диска возрастает до 100%. К сожалению, это не лечится.</li>
	<li>Ошибки запуска виртуальной ОС после неудачного завершения работы (например, вхождения в гибернацию). Оставьте файл диска (его расширение — <code>.vdi</code>), а остальное удалите. Создайте новую машину и добавьте в неё этот файл диска.</li>
	<li>Медленная работа. Это означает, что VirtualBox перешел в программную виртуализацию (в этом случае внизу-справа показывается иконка черепахи, вместо иконки чипа). Это может произойти из-за того, что вы поставили <code>Hyper-V</code> и он занял гипервизор процессора. Удалите Hyper-V.</li>
</ul>
<h2 id="2">2. Вид сверху на C</h2>

<h3 id="2.1">2.1. Введение</h3>
<h3 id="2.1.1">2.1.1</h2><p>Рассмотрим простейшую однофайловую программу на C:</p>

<pre><code class="language-cpp">int main() {
    return 0;
}</code></pre>

<p>Здесь определена функция под названием <code>main</code>. <code>int main()</code> — это сигнатура функции. По ней мы видим, что функция не принимает аргументов, так как круглые скобки ничего не содержат, и возвращает тип <code>int</code> — целое число. В фигурных скобках содержится тело функции, которое содержит лишь один <em>statement </em> <code>return 0</code>, который завершает выполнение функции, возвращая значение <code>0</code>. Пока можно сильно не задумываться обо всем вышенаписанном, мы вернемся к функциям с большими подробностями позже.</p><h3 id="2.1.2">2.1.2</h2><p>Сложно анализировать выполнение программы не имея возможности ввода и вывода. Научимся выводить. Первой функцией для вывода будет <code>int puts(const char *str)</code>. Давайте изучим её сигнатуру.</p>

<p>Во первых, функция принимает один аргумент типа <code>const char *str</code>. Пока не будем расшифровывать этот сложный тип, и поверим, что это строка, известная на этапе компиляции (то есть, мы не сможем её сформировать интерактивно). Очевидно эта строка будет напечатана. Позже мы узнаем, что такое потоки <em>streams</em>, пока будем считать, что вывод идет в консоль.</p>

<p>Во вторых, функция возвращает тип <code>int</code>, и, если мы посмотрим в документацию <em>cppreference</em>, мы увидим, что то, что она возвращает, описано с большой свободой.</p>

<blockquote>
<p>On success, returns a non-negative value.</p>

<p>On failure, returns <a href="https://en.cppreference.com/w/c/io" rel="noopener noreferrer nofollow" title="c/io">EOF</a> and sets the <em>error</em> indicator (see <a href="https://en.cppreference.com/w/c/io/ferror" rel="noopener noreferrer nofollow" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p>
</blockquote>

<p>В свою очередь: </p>

<blockquote>
<table>
	<tbody>
		<tr>
			<td>
			<p>EOF</p>
			</td>
			<td>integer constant expression of type int and negative value</td>
		</tr>
	</tbody>
</table>
</blockquote>

<p>Такую картину мы будем видеть во многих функциях. Можно посмотреть и <code>ferror()</code>, но нам это пока неинтересно.</p>

<p>Давайте, наконец, напечатаем что-либо.</p>

<pre><code class="language-cpp">int main() {
    puts("Hello");
    puts("Test");
    return 0;
}</code></pre>

<p>Обратите внимание: в этой программе я не написал <code>#include &lt;stdio.h&gt;</code>, несмотря на то, что так обычно делают. Дело в том, что мы пока не понимаем, что такое <code>#include</code>, но он и не нужен. Вы получите предупреждение о том, что <code>puts</code>не был объявлен, но исполняемый файл вы все равно получите.</p>

<p>При запуске этой программы будет выполнена функция <code>main</code>, в которой будет вызвана функция <code>puts("Hello")</code>, в результате чего будет выполнена печать строки <em>Hello</em> и перевод строки, а затем будет вызвана функция <code>puts("Test")</code>, в результате чего будет выполнена печать строки <em>Test</em> и перевод строки.</p><h3 id="2.1.3">2.1.3</h2><p>Научимся работать с локальными переменными, а заодно и выводить числа. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a;
    int b = 2 + 3;
    b = a + 8;
    printf("%d %s %d\n", a, "Hello", b + 7);
    return 0;
}</code></pre>

<p>В первой строке тела функции <code>main</code>мы объявляем <em>declare</em> переменную типа <code>int</code> с именем <code>a</code>. Мы не присваиваем <em>define</em> её. Её значение на этом моменте будет неопределенно. Какое значение получит переменная <code>a</code> мы узнаем позже.</p>

<p>Во второй строке мы объявляем <em>declare</em> и сразу определяем <em>define</em> переменную типа <code>int</code> с именем <code>b</code>. Мы присваиваем ей значение <code>5</code>.</p>

<p>В третьей строке мы переопределяем значение переменной <code>b</code>. Так как в вычислении её значения используется неопределенная переменная <code>a</code>, теперь значение переменной <code>b</code> тоже не определено.</p>

<p>В четвертой строке вы используем новую, намного более сложную функцию — <code>printf</code>. Это функция с неопределенным количеством аргументов (vararg функция, эллипсис). Первый её аргумент — это строка, задающая формат. Он имеет достаточно богатые возможности, и мы будем ими пользоваться по мере необходимости. Пока остановимся на том, что подстроки <code>%d</code> будут заменены на число в следующем по счету аргументе, подстроки <code>%s</code> будут заменены на строку в следующем по счету аргументе (первый <code>%d</code> заменится на аргумент <code>a</code>, <code>%s</code> заменится на аргумент <code>"Hello"</code>, второй <code>%d</code> заменится на аргумент <code>b + 7</code>), а <code>\n</code> обозначает символ перехода строки line feed (другие подобные символы мы увидим позже).</p>

<p>Определить вывод этой программы наперед не получится, так как значения переменных зависят от компилятора. В будущем мы часто будем с этим сталкиваться.</p><h3 id="2.1.4">2.1.4</h2><p>Рассмотрим базовые типы данных, которые нам в ближайшее время могут пригодиться.</p>

<ul>
	<li><code>int</code> — целые числа, на хранение котах выделяется <code>4</code> байта</li>
	<li><code>short</code> — целые числа, на хранение которых выделяется <code>2</code> байта</li>
	<li><code>char</code> — целые числа, на хранение которых выделяется <code>1</code> байт</li>
	<li><code>long long</code> — целые числа, на хранение которых выделяется <code>8</code> байт</li>
	<li><code>long</code> — целые числа, на хранение которых выделяется ?? байт</li>
</ul>

<p>Помимо этих типов, на понадобится <code>const char*</code>.</p>

<p>Интересная ситуация с логическим типом <code>_Bool</code> — он был введен не сразу, и в многих программах вводили тип с названием <code>bool</code> самостоятельно с помощью препроцессора, поэтому и было выбрано такое странное название. Логический тип имеет лишь два значения: <code>true</code> и <code>false</code>. (На самом деле, размер этого типа <code>1</code> байт, и <code>false</code> соответствует числу <code>0</code>, в то время как <code>true</code> всем остальным.)</p>

<p>Размер типа <code>long</code> в свою очередь зависит от системы. На <em>Windows</em> он равен 4, а на <em>Linux</em> он равен 8. В целом, встроенные типы на описывают нормально свою размерность, как в языках <em>Rust</em> и <em>Zig</em>, и это бывает проблемой.</p>

<p>Про указатели мы поговорим позже.</p>

<p>С помощью оператора <code>sizeof(x)</code> можно узнать размер типа в байтах, причем в качестве аргумента можно использовать как тип, так и переменную или значение.</p>

<pre><code class="language-cpp">int main() {
    printf("int: %d\n", sizeof(int));
    printf("short: %d\n", sizeof(short));
    printf("char: %d\n", sizeof(char));
    printf("long long: %d\n", sizeof(long long));
    printf("long: %d\n", sizeof(long));
    printf("const char*: %d\n", sizeof(const char*));
    
    const char *str = "Hello";
    printf("const char*: %d\n", sizeof(str));
    return 0;
}</code></pre><h3 id="2.1.5">2.1.5</h2><p>Изучим несколько базовых операторов.</p>

<ol>
	<li><code>+</code> — оператор сложения, складывает два числа. <code>2 + 3</code> равно <code>5</code>.</li>
	<li><code><span style="color: #000000;">-</span></code> — оператор вычитания, вычитает второе число из первого. <code>5 - 3</code> равно <code><span style="color: #000000;">2</span></code>.</li>
	<li><code><span style="color: #000000;">*</span></code> — оператор умножения, умножает два числа. <code>2 * 3</code> равно <code><span style="color: #000000;">6</span></code>.</li>
	<li><code><span style="color: #000000;">/</span></code> — оператор деления, делит второе число на первое с округлением вниз. <code><span style="color: #000000;">5 / 2</span></code> равно <code><span style="color: #000000;">2</span></code>. <code><span style="color: #000000;">6 / 2</span></code> равно <code><span style="color: #000000;">3</span></code>.</li>
	<li><code>%</code> — оператор остатка от деления, делит второе число на первое и даёт остаток от деления. <code><span style="color: #000000;">5 % 2</span></code> равно <code>1</code>. <code><span style="color: #000000;">6 % 2</span></code> равно <code>0</code>.</li>
</ol>

<p>Если второй аргумент у операторов <code>/</code> и <code>%</code> будет равен <code>0</code>, то программа завершится с ошибкой. Какие при этом механизмы происходят, мы узнаем позже.</p>

<p>Также у этих операторов есть странная особенность: на самом деле они округляют не вниз, а к нулю, что может быть неприятным сюрпризом, если в ваших промежуточных вычислениях будут получаться отрицательные числа. Например <code>-5 / 2</code> равно <code>-1</code> и <code>-5 % 3</code> равно <code>-2</code>.</p>

<p>Имейте ввиду, что числа в C ограничены, и при их переполнении вы не получите никаких предупреждений или ошибок. (Когда такое происходит, процессор ставит флаг переполнения, но компилятор C для скорости даже не смотрит на него.) Например, <code>2000000000 + 2000000000</code> равно <code>-294967296</code>.</p>

<p>Помимо арифметических операторов существуют логические операторы для создания сложных условий.</p>

<ol>
	<li><code>&amp;&amp;</code> или <code>and</code> — оператор И, который возвращает <code>1</code>, если оба аргумента не равны нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>||</code> или <code>or</code> — оператор ИЛИ, который возвращает <code>1</code>, если хотя бы один аргумент не равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>!</code> — унарный оператор НЕ, который возвращает <code>1</code>, если аргумент равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>==</code> — оператор равенства, который возвращает <code>1</code>, если аргументы равны, и возвращает <code>0</code> в противном случае.</li>
</ol>

<pre><code class="language-cpp">int main() {
    printf("%d ", 3 + 4);
    printf("%d ", 17 % 7);
    printf("%d ", 3 &amp;&amp; 0);
    printf("%d ", 3 || 0);
    printf("%d ", !4);
    printf("%d ", 5 == 5);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>7 3 0 1 0 1 </code></p><h3 id="2.1.6">2.1.6</h2><p>Напишите программу, которая выведет следующий текст:</p>

<pre><code>123
abracadabra
2 + 5 = 7
ababba</code></pre><h3 id="2.1.7">2.1.7</h2><p>Напомним, что в C не сразу был введен логический тип данных <code>_Bool</code>. Однако при этом также есть возможность получить "тип" <code>bool</code>, добавив файл <code>#include &lt;stdbool.h&gt;</code>. (На самом деле, это не совсем тип.)</p>

<p>Как думаете, зачем этот файл был добавлен?</p><h3 id="2.1.8">2.1.8</h2><p>Пока эту задачу можно пропустить, и вернуться к ней намного позднее.</p>

<p>Я немного наврал, когда сказал, что размер типа <code>int</code> — 4 байта. Это не так при компиляции в разрядности ниже, чем 32. Однако современные компиляторы не имеют возможности компилировать в такие разрядности, поэтому это не является проблемой. Можно попробовать найти древний компилятор (например, Open Watcom), который может компилировать в разрядность 16, и проверить <code>sizeof(int)</code> в таком режиме.</p>
<h3 id="2.2">2.2. Контроль потока</h3>
<h3 id="2.2.1">2.2.1</h2><p>Начнём с введения нескольких терминов. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a = 5 + 8;
    puts("123");
    int b = puts("456");
    return 0;
}</code></pre>

<p>Тело функции <code>main</code> состоит из четырех действий: объявление переменной <code>a</code>, вызов функции <code>puts("123")</code>, объявление переменной <code>b</code>, возвращение значения <code>0</code>. Каждое из этих действий называется <em>statement</em>.</p>

<p>Посмотрим на первый statement: <code>int a = 5 + 8</code>. Часть <code>5 + 8</code> называется <em>expression</em>. Часть этого expression-а <code>5</code> тоже является expression-ом. На третьем statement-е вызов функции <code>puts("456")</code> также является expression-ом (в то время, как другой вызов этой же функции был statement-ом).</p>

<p>Есть проблема в терминологии: оба этих слова не имеют перевода на русский язык, и обычно их обоих называют просто <em>выражение</em>. Позже, когда мы будем более подробно изучать синтаксис, мы увидим смысл такого разделения.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>statement</td>
			<td>expression</td>
		</tr>
		<tr>
			<td>Исполняются сверху вниз</td>
			<td>Порядок исполнения не определен</td>
		</tr>
		<tr>
			<td>Не имеют конечного значения</td>
			<td>Имеют конечное значение (а потому и тип)</td>
		</tr>
		<tr>
			<td>Имеют side effect</td>
			<td>По хорошему, не должны иметь side effect</td>
		</tr>
	</tbody>
</table>

<p><em>Side effect</em> означает, что исполнение фрагмента кода приведет к изменению чего либо за его пределами (изменятся внешние переменные; что-то запишется в память, доступную из внешних переменных; выполнится системный вызов и т.д.).</p><h3 id="2.2.2">2.2.2</h2><p>Control Flow (контроль потока) — это набор statement-ов в языке, которые определяют последовательность выполнения statement-ов.</p>

<p>Пока мы видели следующие типы statement-ов:</p>

<ul>
	<li>Declaration (объявление): <code>int a</code>. Объявление также может быть с определением/присваиванием (по сути, это то же самое, но термин определение в других языках может налагать ограничения):<span style="color: #000000;"> <code>int a = 5</code></span>.</li>
	<li>Assignment/Definition (присваивание/определение): <code>a = 5 + 2</code>.</li>
	<li>Function Call (вызов функции): <code>puts("123")</code>.</li>
	<li>Function Return (возврат из функции): <code>return 2 + puts("456")</code>.</li>
</ul>

<p>Конечно, хочется иметь вариативность в порядке исполнения statement-ов. Делать это можно с помощью ветвлений и циклов, которые являются control flow statements.</p>

<p>Посмотрим на <code>if</code>:</p>

<pre><code class="language-cpp">int main() {
    int a = 4;
    if (a - 4) {
        puts("1");
    }
    else if (a) puts("2");
    else {
        puts("3");
    }
    return 0;
}</code></pre>

<p>Данный <code>if</code> statement состоит из трех ветвей. Эти ветви надо читать так:</p>

<ol>
	<li>Если <code>a - 4</code> не <code>0</code>, то выполнить <code>puts("1")</code> и завершить выполнение <code>if</code></li>
	<li>Если <code>a</code> не <code>0</code>, то выполнить <code>puts("2")</code> и завершить выполнение <code>if</code></li>
	<li>Выполнить <code>puts("3")</code></li>
</ol>

<p>Обратите внимание на следующие вещи:</p>

<ul>
	<li>Можно как обрамлять блок в <code>if</code> в фигурные скобки, так и не делать этого.</li>
	<li>В качестве условия в <code>if</code> должен быть expression, а его тип неважен. Проверка идет лишь на то, что он не <code>0</code>. А в языке C по сути любой тип данных — число.</li>
	<li>Веток <code>else if</code> и <code>else</code> может не быть. Количество веток <code>else if</code> не ограниченно.</li>
</ul>

<p>В результате выполнения этой программы будет напечатано единственное число <code>2</code>.</p><h3 id="2.2.3">2.2.3</h2><p>Вскоре нам потребуется начать решать input/output задачи для проверки знаний. Для этого нужно разобраться, как считывать данные. Для этого используется функция <code>scanf</code>. Посмотрим решение задачи A + B.</p>

<p>Напишите программу, которая считывает два целых числа <span class="math-tex">\(a\)</span> и <span class="math-tex">\(b\)</span> (<span class="math-tex">\(-100 \le a, b \le 100\)</span>), и выводит их сумму.</p>

<pre><code class="language-cpp">int main() {
    int a, b;
    scanf("%d%d", &amp;a, &amp;b);
    printf("%d\n", a + b);
    return 0;
}</code></pre>

<p>Функция <code>scanf</code> имеет первым аргументом формат, по которому сопоставляются данные во входном потоке, а следующими аргументами <em>адреса</em>, по которым необходимо эти данные положить. <code>scanf</code> сам считает произвольное количество пробельных символов (пробел, табуляция, следующая строка, возврат каретки и т.д.) между идущими в формате подряд <code>%d</code>. (Принцип, по которому он это делает, мне не очень понятен, но это и не нужно.)</p>

<p>Пока мы не знаем, что такое адреса, но позже мы подробно их изучим. C не имеет возможности передать в функцию локальную переменную так, чтобы функция изменила её. Вместо этого мы передаем адрес локальной переменной, который мы берем оператором <code>&amp;</code> (амперсанд). Интересно, что функция, получая информацию о местоположении локальной переменной, может работать не только с этой переменной, но и с тем что находится рядом с ней. (Она не получает этим <em>права</em> — права у неё от передачи аргументов не меняются. Она получает информацию, где искать данные.) Но об этом мы поговорим подробно потом.</p>

<p>Нетрудно догадаться, как считывать строки, но там есть неочевидные моменты. Мы поговорим о строках отдельно. Пример некорректной программы, которая может, как выполниться успешно, так и завершиться с ошибкой. Ничего страшного, если вы пока не знаете, что такое массивы, и, соответственно, не понимаете программу.</p>

<pre><code class="language-cpp">int main() {
    char str[10];
    scanf("%s", str);
    return 0;
}</code></pre>

<p>А эта программа гарантированно завершится с ошибкой, так как попытается считать данные в константу. Как функционирует такое ограничение, мы также позже узнаем.</p>

<pre><code class="language-cpp">int main() {
    const char *str = "Hello";
    scanf("%s", str);
    return 0;
}</code></pre><h3 id="2.2.4">2.2.4</h2><p>Улитка ползет по столбу высотой <span class="math-tex">\(h\)</span> единиц и хочет забраться на самый его верх. Днем улитка поднимается на <span class="math-tex">\(a\)</span> единиц, а ночью соскальзывает вниз на <span class="math-tex">\(b\)</span> единиц. На какой день улитка заберется на столб?</p>

<h4>Формат ввода</h4>

<p>Единственная строка входных данных содержит три целых числа: <span class="math-tex">\(a\)</span>, <span class="math-tex">\(b\)</span> и <span class="math-tex">\(h\)</span> (<span class="math-tex">\(1 \le b &lt; a \le h \le 10^9\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — номер дня, на который улитка достигнет верха столба.</p><h3 id="2.2.5">2.2.5</h2><p>В C присутствуют циклы <code>while</code>, <code>do while</code> и <code>for</code>. Выходить их циклов можно с помощью операторов <code>break</code> и <code>continue</code>. К сожалению, нет возможности выйти из нескольких циклов, кроме как с помощью оператора перехода к метке <code>goto</code>.</p>

<p>Цикл <code>while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    while (i &lt; 10) {
        printf("%d", i);
        i++;
    }
    return 0;
}</code></pre>

<p>Читать это надо так. Если<code>i &lt; 10</code>, выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу, а затем прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    do {
        printf("%d", i);
        i++;
    } while (i &lt; 10);
    return 0;
}</code></pre>

<p>Читать это надо так. Выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу. Затем, если<code>i &lt; 10</code>, прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> отличается от цикла <code>while</code> тем, что он в любом случае сделает хотя бы одну итерацию.</p><h3 id="2.2.6">2.2.6</h2><p> Цикл <code>for</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i;
    for (i = 0; i &lt; 10; i++) {
        printf("%d", i);
    }
    i = 0;
    for (; i &lt; 10; printf("%d", i) &amp;&amp; i++);
    return 0;
}</code></pre>

<p>Читать первый цикл <code>for</code> надо так. Сначала выполнить <code>i = 0</code>. Затем выполнить тело цикла, в котором необходимо вывести значение <code>i</code>, а затем выполнить <code>i++</code>. Затем, если <code>i &lt; 10</code>, прыгнуть в начало цикл (не выполняя <code>i = 0</code>). В противном случае, прервать выполнение цикла.</p>

<p>Данный цикл на первый взгляд может выглядеть странным и запутанным, но на самом деле он удобен.</p>

<p>Часто вы будете видеть, что в первом "блоке" цикла <code>for </code>(там, где у нас написано <code>i = 0</code>) выполняют объявление переменной (например <code>int i = 0</code>). Однако, это работает не со всеми стандартами языка C. В некоторых стандартах это может считаться ошибкой.</p>

<p>Посмотрим на второй цикл <code>for</code>. Мы видим, что некоторые блоки могут быть пустыми. Все блоки должны являться expressions. Причина этого ясна для второго блока, ведь он проверяет условие, а значит его содержимое должно иметь значение. Но неужели <code>i = 0</code> и <code>i++</code> это тоже expressions, которые имеют какое-то значение? Да. <code>i = 0</code> возвращает значение своего правого аргумента, а <code>i++</code> возвращает значение <code>i</code> до увеличения. (Чуть позже мы изучим все эти операторы подробнее, но вы уже можете почитать про них.)</p>

<p>Оператор <code>&amp;&amp;</code> — это оператор И. Он выполняет левый аргумент, и, если он не <code>0</code>, выполняет правый аргумент и возвращает его, а иначе, возвращает <code>0</code>. Попробуйте теперь самостоятельно понять логику работы второго цикла.</p>

<p>Вывод этой программы: <code>01234567890123456789</code></p><h3 id="2.2.7">2.2.7</h2><p> Немного изменим второй цикл из программы на предыдущем шаге.</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    for (; i &lt; 10; i++ &amp;&amp; printf("%d", i));
    return 0;
}</code></pre>

<p>Какой будет вывод у этой программы и почему?</p><h3 id="2.2.8">2.2.8</h2><p>С помощью оператора <code>break</code> мы выходим из одного внутреннего цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) break;
        }
    }
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code>001012012301234</code></p>

<p>С помощью оператора <code>continue</code> мы переходим к следующей итерации внутреннего цикла, не выполняя оставшуюся часть тела цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            if (j == i) continue;
            printf("%d", j);
        }
    }
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code>12340234013401240123</code></p>

<p>С помощью оператора <code>goto</code> мы переходим к <em>метке</em>. Метка может быть объявлена в любом месте между statement-ов, и выглядит как идентификатор с двоеточием. С помощью оператора <code>goto</code> можно, например, выйти из двойного цикла:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) goto end;
        }
    }
    end:
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code><span style="color: #000000;">0</span></code></p>

<p>Бывает, что необходимо по выполнению условия выйти из блока кода. Увы, сделать это так не получится:</p>

<pre><code class="language-cpp">int main() {
    {
        int i;
        if (i) break;
    }
    return 0;
}</code></pre>

<p>Обычно, для этой цели используют цикл или оператор <em>goto</em>. (В языке программирования Zig это организовано получше.)</p>

<p>Старайтесь не использовать оператор <code>goto</code> там, где он может серьезно усложнить читаемость программы, с чем он отлично справляется. Обычно в языке C он используется для того, чтобы выйти из вложенного цикла, и для того, чтобы перейти к очистке в конце функции, если она что-то динамически создала, но в процессе её работы произошла ошибка, из-за которой она должна прерваться и вернуть ошибку. Выглядит это примерно так:</p>

<pre><code class="language-cpp">FOOSTATUS foo() {
    void *data = malloc(SIZE);
    int status = FOO_SUCCESS;
    if (!init_foo(data)) {
        status = FOO_ERROR_INIT;
        goto end
    }
    if (!process_foo(data)) {
        status = FOO_ERROR_PROCESS;
        goto end
    }
    end:
    free(data);
    return status;
}</code></pre><h3 id="2.2.9">2.2.9</h2><p>Для более удобной организации ветвлений используются <code>switch case</code> statement-ы.</p>

<pre><code class="language-cpp">int main() {
    int x = 2;
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 3: printf("3 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 ");
        case 3: printf("3 "); break;
        case 4: printf("4 ");
    }
    switch (x) {
        case 1: printf("1 "); break;
        default: printf("- ");
    }
    printf("\n");
}</code></pre>

<p>Здесь написаны четыре <code>switch case</code> statement-а. В своем теле они имеют ветви, каждая из которых состоит из ключевого слова <code>case</code>, выражения, при котором эта ветвь срабатывает, символа двоеточия и блока кода.</p>

<p>При выполнении <code>switch case</code> statement-а выполняется первая ветвь, выражение после слова <code>case</code> у которой равно выражению после слова <code>switch</code>. У первого <code>switch</code> это вторая ветвь, которая содержит блок <code>printf("%d "); break;</code>. (Ключевое слово <code>break</code> тоже часть блока.) У второго <code>switch</code> такой ветви нет, поэтому ничего не будет исполнено.</p>

<p>Как только срабатывает одна из ветвей, выполняются все следующие ветви вплоть до последней (что по моему мнению является довольно странной логикой), либо до встречи ключевого слова <code>break</code>. Так, у третьего <code>switch</code> будет выполнен блок второй ветви <code>printf("2 ");</code>, а затем продолжится выполнение блока третьей ветви, и, так как он завершается словом <code>break</code>, блок четвертой ветви не будет выполнен.</p>

<p>Четвертый <code>switch</code> statement имеет ветвь, которая начинается с ключевого слова <code>default</code>. Блок данной ветви будет выполнен в любом случае, если не было выполнено ни одного блока выше.</p>

<p>Вывод этой программы: <code>2 2 3 - </code></p><h3 id="2.2.10">2.2.10</h2><p>Успешный брокер Василий смотрит курс акций за последние <span class="math-tex">\(n\)</span> дней. Цена акции в день <span class="math-tex">\(i\)</span> равна <span class="math-tex">\(a_i\)</span>. Василий хочет найти два дня <span class="math-tex">\(p &lt; q\)</span>, такие, что <span class="math-tex">\(a_q - a_p\)</span> максимально возможное, ведь именно покупка акций в день <span class="math-tex">\(p\)</span>, а продажа в день <span class="math-tex">\(q\)</span> принесла бы ему максимальную прибыль, будь у него более развитые экстрасенсорные способности.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — наибольшая разность <span class="math-tex">\(a_q - a_p\)</span>.</p>
<h3 id="2.3">2.3. Функции</h3>
<h3 id="2.3.1">2.3.1</h2><p>Мы уже объявляли функции. <code>int main() {}</code> — это объявление функции, которая ничего не принимает. При использовании стандартного <em>linker-скрипта</em> (что это такое, мы узнаем позже) наличие этой функции обязательно.</p>

<p>Cигнатура функции — это список типов аргументов, которые функция принимает, и тип того, что функция возвращает. По умолчанию, функция <code>main</code> возвращает <code>int</code>, и значение <code>0</code> означает успешное выполнение. Это значение называется <em>кодом возврата</em> программы, и в <em>sh</em> можно его посмотреть у запущенной в последний раз программы с помощью переменной <code>$?</code>: <code>echo $?</code>.</p>

<p>Попробуем написать свои функции:</p>

<pre><code class="language-cpp">int foo(int a) {
    return a + 2;
}

int main() {
    int a = 5;
    int b = foo(a);
    foo(a);
    printf("%d %d\n", a, b);
    return 0;
}</code></pre>

<p>Функция <code>foo</code> принимает один аргумент типа <code>int</code> и возвращает его значение, увеличенное на <code>2</code>. В результате выполнения этой программы будет выведено <code>5 7</code></p>

<p>Обратите внимание, что вызов функции может быть как expression-ом, как в первом случае, так и statement-ом, как во втором случае.</p>

<p>Функции используются для организации кода и улучшения читаемости.</p>

<p>Функции можно определять в отдельных файлах, но в C (и Assembly) это делается не так просто, как в остальных языках. Мы поговорим об этом отдельно.</p>

<p>В функции <code>foo</code> можно вызвать функцию <code>foo</code>. Это называется <em>рекурсией</em>. Например, функция вычисления наибольшего общего делителя (greatest common divisor) может быть написана так:</p>

<pre><code class="language-cpp">int gcd(int a, int b) {
    if (a == 0)
        return 0;
    else
        return gcd(b % a, a);
}</code></pre>

<p>Естественно, можно допустить ошибку, при которой вызов функции будет происходить бесконечно. В таком случае, так как на хранение данных о предыдущих (и все ещё идущих) вызовах функции тратится память на стеке, стек вскоре закончится, и возникнет ошибка исполнения.</p>

<p>Функции могут ничего не возвращать. Для этого вместо типа возврата указывается <code>void</code>. В таком случае, нельзя использовать функцию, как expression.</p><h3 id="2.3.2">2.3.2</h2><p>Принято, что функция <code>main</code> принимает два аргумента, и её полная сигнатура на самом деле выглядит так: <code>int main(int argc, char **argv)</code>. Второй аргумент — список строк, длина которого неизвестна, а первый аргумент — длина этого списка. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>Что за список строк имеется ввиду? Это список аргументов программы. Когда мы запускаем программу в терминале, мы передаем их так: <code>./program ababba babba</code>. При таком запуске вывод программы будет такой:</p>

<pre><code>program
ababba
babba</code></pre>

<p>Первый аргумент всегда должен быть названием исполняемого файла. Мы можем нарушить это правило, если сделаем системный вызов <code>exec</code> самостоятельно, и некоторые программы в таком случае могут отказаться работать. (Что такое системные вызовы мы изучим позже.)</p>

<p>Благодаря особенностям <em>ABI</em> (что это такое, мы узнаем позже) мы можем написать в сигнатуру не все аргументы. Однако мы не можем написать большее количество аргументов, иначе они попадут на данные функции, которая нас вызвала, и мы начнем оперировать ими. (<code>main</code> — не первая функция при стандартном linker-скрипте.) Обратите внимание: компилятор никак не помешает нам этого сделать.</p>

<pre><code class="language-cpp">int main(int a, int b, int c, int d) {
    printf("%d %d %d %d\n", a, b, c, d);
    d = 5;
    return 0;
}
</code></pre>

<p>Если использовать 64-битный компилятор, то размер адресов (любых) будет 8 байт (то есть два <code>int</code>-а). Тогда переменные <code>b</code> и <code>c</code> лягут на аргумент <code>argv</code>, а переменная <code>d</code> на вызвавшую функцию. (Если бы функция <code>main</code> была первой, а мы могли бы сделать это, написав свой linker-скрипт, то мы могли бы ткнуться за пределы стека и получить ошибку исполнения.)</p><h3 id="2.3.3">2.3.3</h2><p>Функции "видят" другие функции, объявленные выше. Но если мы хотим написать две вызывающие друг друга функции, то с помощью только определений функций сделать этого, возможно, не удастся. Такой код в C++ некорректен, но в C корректен (возможно, не во всех компиляторах):</p>

<pre><code class="language-cpp">void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Решить эту проблему можно с помощью объявления функции, или, <em>прототипа</em> функции. Выглядит он так:</p>

<pre><code class="language-cpp">void boo(int n);

void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Прототип функции объявляет лишь сигнатуру. Названия аргументов в нем не важны, и, если мы заменим первую строку на <code>void boo(int);</code>, то это будет по прежнему корректно.</p>

<p>Прототип функции должен соответствовать определению функции. Если прототип здесь будет <code>void boo(long long n);</code>, то это вызовет ошибку компиляции.</p>

<p>Очень важно, что если прототип функции, и её определение будут в разных модулях, то компилятор не сможет заметить несоответствия сигнатур функций. В таком случае во время выполнения программы при вызове функции стек "съедет", и произойдет stack corruption. (Более подробно этот механизм мы изучим позже.)</p><h3 id="2.3.4">2.3.4</h2><p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int, int)</code></li>
	<li><code>int max(int, int)</code></li>
	<li><code>int abs(int)</code> — абсолютное значение (модуль)</li>
	<li><code>int lcm(int, int)</code> — наименьшее общее кратное (least common multiplier)</li>
	<li><code>int powmod(int a, int n, int m)</code> — возведение числа <code>a</code> в степень <code>n</code> по модулю <code>m</code></li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(5, 8) == 5);
    assert(min(11, 4) == 4);
    assert(max(5, 8) == 8);
    assert(max(11, 4) == 4);
    assert(abs(43) == 43);
    assert(abs(-41) == 41);
    assert(lcm(14, 21) == 42);
    assert(lcm(1128960, 567000) == 254016000);
    assert(powmod(3, 4, 7) == 4);
    assert(powmod(43259, 64234, 784) == 505);
    return 0;
}</code></pre>

<p>Функция <code>assert</code> завершает выполнение программы с кодом возврата <code>3</code>, если её аргумент равен нулю (то есть, условие провалено). Возможно, для его использования потребуется добавить <code>#include &lt;assert.h&gt;</code>.</p><h3 id="2.3.5">2.3.5</h2><p>Функции <code>printf</code> и <code>scanf </code>— это функции с переменным количеством аргументов (variadic functions, vararg, ellipsis). Синтаксис C позволяет создавать такие функции, но по понятным (когда придет время) причинам, сам C такие функции поддерживать не может. Проблема в том, что при вызове функции на стек кладутся аргументы и адрес возврата, но ничего более. Поэтому по стеку нельзя понять, сколько аргументов было передано в функцию, и какие их типы или, хотя бы, размерности. Это может вызвать различные corruptions.</p>

<p>Пример функции, вычисляющей сумму аргументов:</p>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

int sum(int n, ...) {
    va_list lst;
    va_start(lst, n);
    
    int sum = 0;
    int i;
    for (i = 0; i &lt; n; i++) {
        sum += va_arg(lst, int);
    }
    
    va_end(lst);
    return sum;
}

int main() {
    printf("%d\n", sum(5, 2, 6, 4, 3, 7));
    return 0;
}</code></pre>

<p>Обратим внимание на следующее:</p>

<ul>
	<li>Нам необходим <code>#include &lt;stdarg.h&gt;</code> для того, чтобы иметь макросы <code>va_list</code>, <code>va_start</code>, <code>va_arg</code>, <code>va_end</code>. (Что такое макросы, мы узнаем позже. Пока считайте, что это функции.)</li>
	<li>Первый аргумент <code>n</code> — это длина массива. Напомню, что функция никак не может знать форму того, что ей передано. Количество аргументов надо указать. Обратите внимание, что если подать в функцию не <code>n</code> следующих аргументов, то она никак это не проверит — это приведет к corruption.</li>
	<li>Чтобы пробежать по аргументам, мы пользуемся переменной типа va_list. Это переменную мы передаем всем функциям, связанным с аргументами. По сути, это не более, чем итератор.</li>
	<li>(Второй аргумент макроса <code>va_start</code> оказался мне неизвестен. Документация утверждает, что это аргумент, после которого начнут перебираться "переменные" аргументы, однако простой тест показал, что это не так.)</li>
	<li>Второй аргумент макроса <code>va_arg</code> это тип (обратите внимание: если бы это была функция, он не могла бы принимать тип), следующего аргумента (а также, его размер).</li>
</ul>

<p>В результате выполнения этой программы будет выведено 22.</p>

<p>Функции с переменными аргументами следует использовать ограниченно и с большой осторожностью.</p><h3 id="2.3.6">2.3.6</h2><p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int n, ...)</code></li>
	<li><code>int gcd(int n, ...)</code></li>
	<li><code>int dot_product(int n, ...)</code> — скалярное произведение двух векторов. Например, произведение векторов <code>(1, 4)</code> и <code>(2, -3)</code> должно вычисляться с помощью такого вызова функции: <code>dot_product(2, 1, 4, 2, -3)</code>.</li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(2, 5, 8) == 5);
    assert(min(3, 11, 4, 8) == 4);
    assert(gcd(2, 12, 21) == 3);
    assert(gcd(3, 42, 91, 35) == 7);
    assert(dot_product(2, 1, 4, 2, -3) == -10);
    assert(dot_product(3, 1, 2, 3, 6, 5, 4) == 28);
    return 0;
}</code></pre><h3 id="2.3.7">2.3.7</h2><p>Рассмотрим такую функцию <code>set_args</code>, которая записывает значение второго аргумента по всем остальным аргументам-адресам.</p>

<p>Пока необязательно понимать манипуляции с адресами, но кое-что проясню:</p>

<ul>
	<li><code>int*</code> — это адрес типа <code>int</code>. То есть <code>va_arg(lst, int*)</code> достает следующий адрес.</li>
	<li><code>*a = b</code> выполняет запись значения <code>b</code> в адрес <code>a</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

void set_args(int n, int val, ...) {
    va_list lst;
    va_start(lst, val);
    
    int i;
    for (i = 0; i &lt; n; i++) {
        *va_arg(lst, int*) = val;
    }
    
    va_end(lst);
}

int main() {
    int a, b, c;
    set_args(3, 31, &amp;a, &amp;b, &amp;c);
    printf("%d %d %d\n", a, b, c);
    return 0;
}</code></pre>

<p>Представьте, что пользователь может вводить данные и передавать их в <code>set_args</code> без каких либо проверок. Какую атаку можно здесь произвести (потенциально нехорошее действие)?</p>
<h3 id="2.4">2.4. Указатели</h3>
<h3 id="2.4.1">2.4.1</h2><p>Переходим к самой интересной части языка C — указателям/адресам (pointers).</p>

<p>Указатель — это число, обозначающее ячейку в оперативной памяти. Любая локальная переменная имеет адрес, так как ей нужно где-то находиться. То же относится и к аргументам функций. (На самом деле иногда данные находятся в регистрах, но компилятор здесь будет подстраиваться под наши желания.)</p>

<p>Для взятия адреса используется унарный (с одним аргументом) оператор <code>&amp;</code>, который мы уже видели, когда использовали функцию <code>scanf</code>.</p>

<p>Тип указателя обозначается символом <code>*</code> (asterisk). Например, указатель на <code>int</code> выглядит так: <code>int*</code>. При этом синтаксис объявления указателей неочевидный и часто вызывает ошибки.</p>

<ul>
	<li>Так мы объявляем два указателя: <code>int *a, *b;</code></li>
	<li>Так мы объявляем два указателя: <code>int* a, *b;</code></li>
	<li>Так мы объявляем указатель и число: <code>int* a, b;</code></li>
</ul>

<p>Чтобы переместить данные по указателю (то есть положить их в ячейку оперативной памяти с тем же номером, что и значение указателя), используется такая запись: <code>*a = b</code>, где <code>a</code> это указатель, а <code>b</code> это данные.</p>

<p>Рассмотрим программу:</p>

<pre><code class="language-cpp">void set(int *a, int val) {
    *a = val;
}

int main() {
    int a;
    set(&amp;a, 5);
    printf("%d\n", a);
    return 0;
}</code></pre>

<p>Данная программа демонстрирует то, что я показывал выше. Функция <code>set</code> принимает аргумент типа <code>int*</code> (можно было также написать <code>int* a</code>). В функции <code>set</code> используется перемещение (этот термин не имеет отношения к тому, что с данными что-то происходит: они остаются в том же состоянии) по указателю <code>*a = val</code>. При вызове функции <code>set</code> в качестве аргумента передается адрес локальной переменной, который добывается оператором <code>&amp;</code>.</p>

<p>Вывод этой программы: <code>5</code></p><h3 id="2.4.2">2.4.2</h2><p>В языке C присутствуют массивы, но работают они довольно странно и неочевидно. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a[10];
    a[4] = 32;
    printf("%d %d\n", a[4], sizeof(a));
    return 0;
}</code></pre>

<p>Первая строка тела функции <code>main</code> объявляет массив размера <code>10</code>. Массив — это занумерованная последовательность объектов одинакового типа. Размер массива должен быть константой, то есть известным до компиляции (<code>4 + 6</code>, например, тоже является константой).</p>

<p>На второй строке мы присваиваем четвертому элементу массива значение <code>32</code>. Массивы нумеруются с нуля. Последний индекс массива в данном случае равен <code>9</code>.</p>

<p>На третьей строке мы выводим четвертый элемент и размер массива. Вывод этой программы: <code>32 40</code>. Обратите внимание: в качестве размера массива выводится не количество его элементов, а именно занимаемая им память в байтах (напомним, что размер типа <code>int</code> равен <code>4</code> байта).</p>

<p>Что произойдет, если мы выйдем за пределы массива, сделав, например <code>a[10] = 32</code>? В конкретно этом случае, на самом деле, ничего. Точнее, присвоение произойдет, но то, что оно происходит за пределами массива, никак не будет проверено. Массив, как и все локальные переменные, а также адреса возврата функций, лежит на стеке, а в этом месте стека ничего важного не будет. Однако, в некоторых случаях, можно все-таки, перезаписать что-либо важное. Эта особенность делает программирование на C коварным, так как можно создать "отложенные ошибки": пока некорректный код работает, так как ничего не затирает, а с другими исходными данными уже будет затирать.</p>

<p>Можно создавать многомерные массивы:</p>

<pre><code class="language-cpp">int main() {
    int a[4][5];
    a[2][3] = 5;
    a[0][5] = 3;
    printf("%d %d\n", a[2][3], a[1][0]);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>5 3 80</code></p>

<p>Здесь мы создали двумерный массив размера <code>4x5</code>. Оперативная память адресуется линейно, и данный двумерный массив расположен в ней следующим образом: <code>a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[2][5], ...</code>. Именно поэтому, так как C не обращает внимания на выходы за границы, присваивание некорректного индекса <code>a[0][5]</code> приводит к присваиванию индекса <code>a[1][0]</code>.</p>

<p>Обратите внимания на то, что размер массива равен <code>80</code>, или <code>20</code> <code>int</code>-ов. Этот факт нам пригодится позже.</p><h3 id="2.4.3">2.4.3</h2><p>Массивы практически являются указателями. Можно перевести массив в указатель. Рассмотрим программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int a[10];
    int *b = a;
    *(b + 4) = 32;
    printf("%d %d %d\n", b[4], sizeof(a), sizeof(b));
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>32 40 4</code> или <code>32 40 8</code>, в зависимости от разрядности вашего компилятора.</p>

<p>Если вы добавляете к указателю типа <code>T*</code> число <code>x</code>, то на самом деле к указателю добавиться число <code>x * sizeof(T)</code>.</p>

<p><code>*(b + 4)</code> сначала добавляет к  <code>b</code> значение <code>4 * sizeof(int)</code>, а затем <em>разыменовывает</em> (берет значение в этой ячейке памяти) его. Комичный факт, что <code>b[4] == *(b + 4) == *(4 + b) == 4[b]</code>.</p>

<p>Обратите внимание: вы можете делать операции с указателями так же, как и с массивами. Но есть одна разница: <code>sizeof</code> для указателя возвращает размер указателя, а не всего массива. Более того, имея только указатель, узнать размер массива невозможно. То есть, тип указатель, в отличии от типа массив, не знает размер.</p>

<p>Массивы нельзя передавать в функции. Поэтому, чтобы знать в функции размер массива, приходится передавать и размер:</p>

<pre><code class="language-cpp">int sum(int n, int *a) {
    int x = 0, i;
    for (i = 0; i &lt; n; i++) {
        x += a[i];
    }
    return x;
}

int main() {
    int a[5] = {2, 5, 1, 4, 3};
    int n = sizeof(a) / sizeof(a[0]);
    printf("%d\n", sum(n, a));
    return 0;
}</code></pre>

<p>Обратите внимание на синтаксис присваивания значений элементам массива <code>int a[5] = {2, 5, 1, 4, 3};</code>, и на то, как можно узнать количество элементов локального массива, разделив его размер на размер одного из его элементов (часто даже создают такой макрос).</p><h3 id="2.4.4">2.4.4</h2><p>Реализуйте функцию <code>void sort(int n, int *a)</code>, которая сортирует массив <code>a</code> размера <code>n</code>.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const int n = 10;
    int a[n] = {6, 1, 8, 2, 10, 7, 4, 5, 9, 3};
    int b[n] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    sort(n, a);
    assert(memcmp(a, b, n * sizeof(int)) == 0);
    return 0;
}</code></pre><h3 id="2.4.5">2.4.5</h2><p>Массивы можно создавать динамически. В C нет операторов для этого, но есть стандартные функции <code>malloc</code> и <code>free</code>.</p>

<p>Функция <code>void *malloc(size_t size)</code> создает массив размера <code>size</code> байт и возвращает указатель типа <code>void</code> на его начало. <code>size_t</code> здесь это <code>unsigned int</code>, то есть, беззнаковое (только положительное) целое число. Все численные типы имеют соответствующий <code>unsigned</code> тип.</p>

<p><code>void*</code> указатель обозначает указатель на "что-то", и мы должны будем определить, на что он указывает, самостоятельно. Кроме того, добавление числа <code>x</code> к <code>void*</code> указателю добавит к нему именно <code>x</code>, поэтому этот тип часто используется для создания структур данных.</p>

<p>В отличии от локальных массивов, динамические массивы выделяются не на стеке. Возможные их положения зависят от операционной системы. Как можно делать динамические выделения памяти, и как работает <code>malloc</code>, мы узнаем позже.</p>

<p>Функция <code>void free(void *ptr)</code> освобождает массив, на начало которого указывает <code>ptr</code>. Это значение должно быть ранее получено от <code>malloc</code>. В случае, если такое значение ранее не было получено от <code>malloc</code>, и, соответственно, такого массива не существует, будет ошибка исполнения.</p>

<pre><code class="language-cpp">int main() {
    int *a = (int*)malloc(10 * sizeof(int));
    a[5] = 23;
    printf("%d\n", a[5]);
    free(a);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>23</code></p>

<p>На первой строке мы выделили массив int-ов, состоящий из 10 элементов (не забывает домножать на размер элемента). Чтобы не было предупреждений от компилятора, необходимо перевести тип указателя из <code>void*</code> в <code>int*</code> с помощью <code>(int*)</code>. (При этом  при переводе типа с любого указателя на любой указатель значение не изменится. Для других базовых типов это не всегда так.) Далее мы можем оперировать массивом, как любым другим. На четвертой строке мы освобождаем массив.</p>

<p>Что будет, если выйти за границы динамического массива? Обычно место, в котором выделился ваш массив, это куча — большой отрезок, на операции с которым у вашей программы есть права, а у других программ нет, и в котором выделяются куски на каждый ваш вызов функции <code>malloc</code>. Если вы попытаетесь выполнить операцию за пределами массива, но попадёте в ваш отрезок кучи, то операция будет успешной. При этом эта точка может принадлежать другому массиву, который используется в вашей программе.</p>

<p>Это ещё одна коварность языка C: вы промазали по массиву, но операция выполнилась успешно, и вы повредили память, которая позже будет использоваться. В таком случае, если вы попробуете использовать <em>дебаггер</em> для определения проблемы, он покажет тот, скорее всего корректный, код, память которого была затерта, а не тот код, который затер память.</p>

<p>Если же вы попадете не в ваш отрезок кучи, то программа просто завершится из-за сигнала <em>SIGSEGV</em>.</p>

<p>Что произойдет, если вы не освободите память? На самом деле, ничего, и нет никакой проблемы не освобождать память в однопроходной программе. Вся выделенная память все равно освободится при завершении программы. Однако, если ваша программа работает длительное время, часто создавая и удаляя объекты, необходимо освобождать память, чтобы она не закончилась. Вызов функции <code>malloc</code> может вернуть <code>0</code>, что означает отказ в выделении памяти, скорее всего, по причине превышения лимита.</p><h3 id="2.4.6">2.4.6</h2><p>Найдите все возможные ошибки и утечки памяти в следующем коде:</p>

<pre><code class="language-cpp">int* foo(int x) {
    int *a = malloc(N * sizeof(int));
    if (x &lt; 0) return 0;
    int i;
    for (i = 0; i &lt; N; i++) {
        a[i] = x;
    }
    return a;
}

void boo() {
    int *a = malloc(N * sizeof(int));
    int *b = a;
    int *c = malloc(N * sizeof(int));
    a = c;
    c = b;
    b = a;
    c = b;
    free(a);
    free(b);
}

int flghm_count(int mode, int *result) {
    int status;
    int *buffer;
    status = flghm_init(buffer);
    if (!status) return -1;
    status = flghm_fill(buffer, result);
    if (!status) return -2;
    status = flghm_free(buffer);
    if (!status) return -3;
    return 0;
}
</code></pre><h3 id="2.4.7">2.4.7</h2><p>Изучим алгоритм сортировки слиянием (Merge Sort).</p>

<pre><code class="language-cpp">void merge_sort(int *a, int l, int r) {
    if (r - l == 1) return;
    int m = (l + r) / 2;
    merge_sort(a, l, m);
    merge_sort(a, m, r);
    ...
}</code></pre>

<p>Данный алгоритм является рекурсивным. Он принимает сам массив и границы подотрезка, который данному рекурсивному вызову следует отсортировать. Если длина подотрезка равна <code>1</code>, то он уже отсортирован. Если это не так, то разделим подотрезок на два меньших подотрезка и вызовем <code>merge_sort</code> от каждого из них. В результате мы получим два отсортированных подотрезка. Их необходимо <em>слить</em> в один, после чего сортировка будет завершена.</p>

<p>Здесь я использовал полуинтервалы, то есть индекс <code>r</code> не входит в подотрезок, который необходимо отсортировать. При такой реализации нет необходимости добавлять <code>+1</code> и <code>-1</code> к различным индексам границ.</p>

<p>Реализуйте алгоритм слияния. Он должен по двум отсортированным подотрезкам <code>[l, m)</code> и <code>[m, r)</code> получить один отсортированный подотрезок <code>[l, r)</code>. Здесь <code>[]</code> означают границы включительно, а <code>()</code> — не включительно.</p>

<p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Отсортируйте заданную последовательность.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(b_1, b_2, \ldots, b_n\)</span> (<span class="math-tex">\(b_1 \le b_2 \le \ldots \le b_n\)</span>) — отсортированную последовательность <span class="math-tex">\(a\)</span>.</p><h3 id="2.4.8">2.4.8</h2><p>Помимо многомерных массивов можно пользоваться также многомерными указателями. Однако, как и в одномерном случае, указатели не знают форму массива. Поэтому, например, двумерный массив размера <code>n*m</code> в помощью указателей представляется как массив размера <code>n</code>, состоящий из указателей на массивы размера <code>m</code> (на самом деле, размеры этих массивов могут различаться). Динамическое выделение двумерного массива выглядит так:</p>

<pre><code class="language-cpp">int main() {
    const int n, m;
    int **a = malloc(n * sizeof(int*));
    int i;
    for (i = 0; i &lt; n; i++) {
        a[i] = malloc(m * sizeof(int));
    }
    
    a[2][3] = 12;
    printf("%d\n", a[2][3]);
    
    for (i = 0; i &lt; n; i++) {
        free(a[i]);
    }
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Обратите внимание на следующее:</p>

<ul>
	<li>Я использовал на этот раз идентификаторы <code>n</code> и <code>m</code> в качестве размера массива. Так как размер массива должен быть известен на момент компиляции, я должен объявить их как константы. Значения констант нельзя менять.</li>
	<li>Выделение памяти для массива происходит в два этапа: сначала я создаю массив указателей (поэтому домножение идет на <code>sizeof(int)</code>) размера <code>n</code>, а затем для каждого указателя создаю массив <code>int</code>-ов размера <code>m</code>. Тоже самое касается освобождения памяти.</li>
	<li>Итоговый размер массива не <code>n * m * sizeof(int)</code>, а <code>n * sizeof(int*) + n * m * sizeof(int)</code>.</li>
</ul>

<p>В отличии от локального массива, здесь отдельные ряды не идут друг за другом, а расположены так, как это сделал <code>malloc</code>. Мы можем расположить ряды массива подряд самостоятельно, но тогда нам нужно будет использовать не оператор индексации <code>[]</code>, а свою функцию.</p>

<pre><code class="language-cpp">int offset(int i, int j, int m) {
    return i * m + j;
}

int main() {
    const int n, m;
    int *a = malloc(n * m * sizeof(int));
    
    a[offset(2, 3, m)] = 12;
    printf("%d\n", a[offset(2, 3, m)]);
    
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Попробуйте самостоятельно разобраться с тем, как здесь организован массив.</p><h3 id="2.4.9">2.4.9</h2><p>Задан граф, состоящий из <span class="math-tex">\(n\)</span> вершин и <span class="math-tex">\(m\)</span> ребер. <span class="math-tex">\(i\)</span>-е ребро задается парой вершин <span class="math-tex">\((v_i, u_i)\)</span> — вершины, которые это ребро соединяет. Найдите количество компонент связности данного графа.</p>

<p>Компоненты связности — это разбиение множества вершин графа на попарно непересекающиеся подмножества такие, что для любых двух вершин в одном множестве (в одной компоненте связности) существует путь между ними, а для любых двух вершин в разных множествах не существует пути между ними.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит два целых числа <span class="math-tex">\(n\)</span> и <span class="math-tex">\(m\)</span> (<span class="math-tex">\(1 \le n, m \le 10^3\)</span>)</p>

<p>Следующие <span class="math-tex">\(m\)</span> строк входных данных содержат по два целых числа <span class="math-tex">\(v_i\)</span> и <span class="math-tex">\(u_i\)</span> (<span class="math-tex">\(1 \le v_i, u_i \le n\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — количество компонент связности в заданном графе.</p><h3 id="2.4.10">2.4.10</h2><p>Интересно, и не очень красиво, обстоят дела с указателями-константами. Рассмотрим примеры: </p>

<pre><code class="language-cpp">int main() {
    const int *n;
    int m;
    n = &amp;m;
    
    return 0;
}</code></pre>

<p> <code>const int*</code> объявляет указатель, у которого нельзя менять содержимое. Мы изменить сам указатель (то есть, адрес, на который он указывает), но не можем изменить его содержимое <code>*n = 2</code>.</p>

<pre><code class="language-cpp">int main() {
    int *const n;
    *n = 2;
    
    return 0;
}</code></pre>

<p>Здесь обратная ситуация: <code>int *const</code> позволяет менять содержимое указателя, но не позволяет изменить сам указатель <code>n += 10</code>.</p>

<p>Рассмотрим немного комичный пример:</p>

<pre><code class="language-cpp">int main() {
    const int * *const *n;
    
    n += 2;
    // *n = 2;
    **n += 2;
    // ***n += 2;
    
    return 0;
}</code></pre>

<p>Закомментированные строки нарушают правила константности и вызывают ошибку компиляции.</p><h3 id="2.4.11">2.4.11</h2><p>Мы теперь можем понять смысл типа "строки" — <code>const char*</code>. Это указатель на символ (и, соответственно, следующие символы), содержимое которого (то есть, ни первый символ, ни другие) нельзя менять.</p>

<p>Посмотрим на сигнатуру функции <code>int execv(const char *path, char *const argv[]);</code> (подробнее по <a href="https://linux.die.net/man/3/execv" rel="noopener noreferrer nofollow">ссылке</a>). Что вы можете сказать про её второй аргумент, и как это влияет на использование функции? Попробуйте вызвать эту функцию (необязательно делать что-то осмысленное, главное добиться успешной компиляции).</p>
<h3 id="2.5">2.5. Строки</h3>
<h3 id="2.5.1">2.5.1</h2><p>Представим, что мы печатаем строку, с помощью <code>scanf("%s", str);</code>. <code>str</code> — это не более, чем указатель. Как функция <code>scanf</code> понимает, где кончается строка? Она понимает это с помощью численно равного нулю символа <code>\0</code>, которым строка заканчивается. Когда мы объявляем строку, как <code>const char *str = "aba";</code>, то её длина будет составлять <code>4</code>, и последним символом в ней будет <code>\0</code>.</p>

<p>Что же будет, если мы целенаправленно избавимся от нулевого символа в конце строки? Сделать это мы можем так:</p>

<pre><code class="language-cpp">int main() {
    char a[3];
    a[0] = 'a';
    a[1] = 'b';
    a[2] = 'c';
    printf("%s\n", a);
    return 0;
}</code></pre>

<p>Вывод этой программы будет начинаться с символов <code>abc</code>. То, что пойдет далее, зависит от компилятора и его режима. Здесь происходит довольно простая и очевидная вещь: функция <code>scanf</code> печатает символ за символом, пока не наткнется на нулевой символ где-то дальше за строкой в памяти. В зависимости от того, где расположена строка, это также может вызвать ошибку исполнения, если нулевого символа не найдется вплоть до конца доступной программе памяти.</p>

<p>Из-за такой особенности работа со строками в языке C довольно неприятна. Необходимо всегда помнить о лишнем символе.</p>

<p>Рассмотрим первую стандартную функцию для работы со строками: <code>size_t strlen( const char* str );</code>. С помощью этой функции мы определяем длину строки (не включая нулевой символ). Написать эту функцию очень просто, вот её реализация:</p>

<pre><code class="language-cpp">size_t strlen( const char* str ) {
    const char *x = str;
    while (*x != '\0') {
        x++;
    }
    return x - str;
}</code></pre>

<p>Чтобы проверить эту реализацию, функцию необходимо будет переименовать, либо убрать <code>glibc</code>.</p>

<p>Для использования стандартных функций для работы со строками часто необходимо добавить <code>#include &lt;string.h&gt;</code>.</p><h3 id="2.5.2">2.5.2</h2><p>При выполнении данной программы происходит ошибка исполнения, хотя строка не является константой, и компиляция проходит успешно. (Возможно, наблюдается не на всех компиляторах.) Почему? </p>

<pre><code class="language-cpp">int main() {
    char *a = "abacaba";
    a[3] = 'b';
    
    return 0;
}</code></pre><h3 id="2.5.3">2.5.3</h2><p>Функция <code>int sprintf( char* buffer, const char* format, ... );<span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span></code> работает, как функция <code>printf</code>, но она принимает своим первых аргументом строку <code>buffer</code>, в которую и происходит печать. При этом содержимое строки <code>buffer</code>  никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    char str[100];
    sprintf(str, "%d %d", 32, 85);
    printf("%s\n", str);
}</code></pre>

<p>Вывод этой программы: <code>32 85</code></p>

<p>Функция <code>char *strcpy( char *dest, const char *src );</code> выполняет копирование строки из второго аргумента в первый (поэтому тип первого аргумента лишен <code>const</code>). Копирование выполняется до обнаружения нулевого символа в <code>src</code>. При этом содержимое строки <code>dest</code> никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>abacaba</code></p>

<p>Обратите внимание, что функция <code>strcpy</code> закладывает нулевой символ в конец строки <code>dest</code>. Не забывайте оставлять под него место.</p>

<p>Часто необходимо ограничить длины копируемой строки. Вместо добавления <code>if</code>-а можно использовать стандартную функцию <code>char *strncpy( char *dest, const char *src, size_t count );</code>, которая копирует не более <code>count</code> символов, <strong>включая нулевой символ</strong> (то есть, может оставить строку без нуля на конце).</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[4];
    strncpy(b, a, 3);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>aba</code></p>

<p>Вообще, "n" версии есть у почти каждой строковой функции. Посмотрите функцию <code>strnlen</code>.</p><h3 id="2.5.4">2.5.4</h2><p>Функция <code>int strcmp( const char* lhs, const char* rhs );</code> сравнивает две строки <em>лексикографически</em>.</p>

<blockquote>
<h3>Return value</h3>

<p>Negative value if lhs appears before rhs in lexicographical order.</p>

<p>Zero if lhs and rhs compare equal.</p>

<p>Positive value if lhs appears after rhs in lexicographical order.</p>
</blockquote>

<p>Обратите внимание, что упоминается лишь знак возвращаемого значения. Само же значение не задокументировано.</p>

<p>Так мы проверяем две строки на равенство:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "aba";
    const char *b = "baba";
    const char *c = "aba";
    printf("%d\n", strcmp(a, b));
    printf("%d\n", strcmp(b, a));
    printf("%d\n", strcmp(a, c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>-1 1 0 </code></p>

<p>Перевести строку в число можно с помощью функции <code>int atoi( const char* str );</code>.(В случае некорректной строки она возвращает <code>0</code>.)</p>

<pre><code class="language-cpp">int main() {
    printf("%d\n", atoi("5328"));    
    return 0;
}</code></pre>

<p>Часто необходимо проводить копирование в динамическую строку (вообще, часто приходится работать и с динамическими строками). Вместо такого:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    int n = strlen(a);
    char *b = (char*)malloc((n + 1) * sizeof(char));
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>, можно использовать функцию <code>char * strdup( const char *str1 );</code>, которая делает то же самое: <code>char *b = strdup(a);</code>.</p><h3 id="2.5.5">2.5.5</h2><p>Реализуется функции <code>strcpy</code>, <code>strncpy</code>, <code>strcmp</code> и <code>strncmp</code> так, как ранее была реализована функция <code>strlen</code>. Добавьте в начало из названия символ <code>_</code>, чтобы не было конфликтов имен.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    _strcpy(b, a);
    assert(strcmp(b, "abacaba") == 0);
    b[3] = '\0';
    _strncpy(b, a, 3);
    assert(strcmp(b, "aba") == 0);
    assert(_strcmp("aba", "aba") == 0);
    assert(_strcmp("aba", "abc") &lt; 0);
    assert(_strcmp("abc", "aba") &gt; 0);
    assert(_strncmp("aba", "abc", 2) == 0);
    assert(_strncmp("aba", "abc", 3) &lt; 0);
    return 0;
}</code></pre><h3 id="2.5.6">2.5.6</h2><p>Следующая функция  <code>char* strtok( char* str, const char* delim );</code> более сложная в использовании. Эта функция используется для разбиения строки <code>str</code> на токены. Аргумент <code>delim</code> хранит символы-разделители токенов. Рассмотрим программу:</p>

<pre><code class="language-cpp">#define NULL 0

int main() {
    char str[] = "ab;cde,fghi";
    
    char *a = strtok(str, ",;");
    printf("%d ", strlen(str));
    printf("%d ", strlen(a));
    
    char *b = strtok(NULL, ",;");
    printf("%d ", strlen(b));
    
    char *c = strtok(NULL, ",;");
    printf("%d ", strlen(c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>2 2 3 4</code></p>

<p>Пусть разделителями будут символы <code>,</code> и <code>;</code>. Сначала выполним такой вызов функции: <code>strtok(str, ",;");</code>. В результате этого вызова вместо первого разделителя в изначальной строке <code>;</code> будет поставлен нулевой символ, будет возвращен указатель на первый символ, не являющийся разделителем (а наша строка не начинается с разделителей, поэтому будет возвращен <code>str</code>) , а внутри функции <code>strtok</code> будет неким образом создана запись о том, какой последний символ был обработан.</p>

<p>Затем выполним вызов <code>strtok(NULL, ",;");</code>. В результате этого вызова повторятся те же действия, но не с аргумента (который теперь просто <code>0</code>), а с последнего обработанного символа (видимо, с того, который стал нулевым, но это уже нам неизвестно). Сначала пропустятся следующие два разделителя <code>;</code> до первого, не разделительного символа <code>c</code>. Затем будет найден следующий разделительный символ <code>,</code> и заменен на нулевой символ. И наконец, будет возвращён указатель на символ <code>c</code>.</p>

<p>Строка <code>#define NULL 0</code> заменяет все вхождения идентификаторов <code>NULL</code> в нижестоящем коде на <code>0</code> до компиляции программы. Но об этом мы поговорим позже.</p><h3 id="2.5.7">2.5.7</h2><p>Напишите функцию <code>int strsum(const char *str);</code>, которая принимает строку, состоящую из последовательности целых чисел и пробелов, и возвращает сумму чисел в этой строке.</p>

<p>Подставьте следующую функцию&nbsp;<code>main</code>:</p>

<pre>
<code class="language-cpp">int main() {
    assert(strsum("123") == 123);
    assert(strsum("-6") == -6);
    assert(strsum("  2  2    3 ") == 7);
    assert(strsum("  -6  24    -7 ") == 11);
    return 0;
}</code></pre><h3 id="2.5.8">2.5.8</h2><p>Для выполнения таких же операций с массивами любого типа используются&nbsp;<code>mem***</code>&nbsp;функции. Естественно, функции&nbsp;<code>memlen</code>&nbsp;нет, так как только строки завершаются нулём. Не забывайте о том, что размер массива принимается в байтах, поэтому нужно домножать количество элементов на размер одного элемента.</p>

<p>Функция&nbsp;<code>void *memset(void *buf, int ch, size_t count)</code>&nbsp;устанавливает <code>len</code>&nbsp;байт массива&nbsp;<code>buf</code>&nbsp;равными младшему байту числа&nbsp;<code>ch</code>&nbsp;(старшие байты при этом игнорируются).</p>

<pre>
<code class="language-cpp">int main() {
    int a[4];
    memset(a, 0x1234, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", a[i]);
    }
    printf("%d", 0x34343434);
    
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>875836468 875836468 875836468 875836468 875836468</code></p>

<p>Функция&nbsp;<code>void *memcpy(void *dest, const void *source, size_t count)</code>&nbsp;копирует&nbsp;<code>count</code>&nbsp;байт массива&nbsp;<code>source</code>&nbsp;в массив&nbsp;<code>dest</code>.</p>

<pre>
<code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4];
    memcpy(b, a, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", b[i]);
    }
    
    return 0;
}</code></pre>

<p>Вывод этой программы будет состоять из четырёх чисел, первый три из которых:&nbsp;<code>1 2 3</code></p>

<p>Функция&nbsp;<code>int memcmp(const void *buf1, const void *buf2, size_t count)</code>&nbsp;сравнивает первые&nbsp;<code>count</code>&nbsp;элементов массивов&nbsp;<code>buf1</code>&nbsp;и&nbsp;<code>buf2</code>&nbsp;лексикографически так же, как и функция&nbsp;<code>strcmp</code>.</p>

<pre>
<code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4] = {1, 2, 3, 5};
    printf("%d ", memcmp(a, b, 3 * sizeof(int)));
    printf("%d ", memcmp(a, b, 4 * sizeof(int)));
    
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>0 -1</code></p>

<p>Следует отдавать предпочтение&nbsp;<code>mem***</code>&nbsp;функциям, так как они используют специальные ассемблерные инструкции (которые мы ещё увидим), и потому более быстрые. (Хотя <code>str***</code>&nbsp;функции в то же время тоже имеют некоторые хитрые оптимизации, связанные с итерированием не по одному символу, а по машинному слову. Но это не так сильно влияет.)</p>
<h3 id="2.6">2.6. Структуры</h3>
<h3 id="2.6.1">2.6.1</h2><p>Один байт состоит из восьми бит. Бит принимает одно из двух значений:&nbsp;<code>0</code>&nbsp;или&nbsp;<code>1</code>. Поэтому один байт может принимать&nbsp;<span class="math-tex">\(2^8 = 256\)</span>&nbsp;различных значений.</p>

<p>Рассмотрим, как переводить числа из двоичной в десятичную систему счисления. Мы будем указывать менее значимые цифры справа. (Хотя это и не важно, и часто для удобства менее значимые цифры размещают слева.)</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>0</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>1</code></td>
			<td><code>1</code></td>
		</tr>
		<tr>
			<td><code>10</code></td>
			<td><code>2</code></td>
		</tr>
		<tr>
			<td><code>11</code></td>
			<td><code>3</code></td>
		</tr>
		<tr>
			<td><code>100</code></td>
			<td><code>4</code></td>
		</tr>
		<tr>
			<td><code>101</code></td>
			<td><code>5</code></td>
		</tr>
		<tr>
			<td><code>110</code></td>
			<td><code>6</code></td>
		</tr>
		<tr>
			<td><code>111</code></td>
			<td><code>7</code></td>
		</tr>
		<tr>
			<td><code>1000</code></td>
			<td><code>8</code></td>
		</tr>
	</tbody>
</table>

<p>В общем случае, если&nbsp;<span class="math-tex">\(i\)</span>-й бит числа в двоичной записи равен&nbsp;<span class="math-tex">\(a_i\)</span>, в десятичной записи оно будет равно&nbsp;<span class="math-tex">\(a_0 \cdot 1 + a_1 \cdot 2 + a_2 \cdot 4 + a_3 \cdot 8 + \ldots = \sum{a_i \cdot 2^i}\)</span></p>

<p>Целочисленные типы данных бывают знаковыми (signed) и беззнаковыми (unsigned). Беззнаковые типы принимают значение от&nbsp;<span class="math-tex">\(0\)</span>&nbsp;(когда все биты нулевые) до&nbsp;<span class="math-tex">\(2^{size} - 1\)</span>&nbsp;(когда все биты единицы), где&nbsp;<span class="math-tex">\(size\)</span>&nbsp;&mdash; это размер типа данных в битах. Так, максимальное значение типа&nbsp;<code>unsigned int</code>&nbsp;равно&nbsp;<span class="math-tex">\(2^{32} - 1 = 4294967295\)</span>.</p>

<p>Знаковые типы принимают значение от&nbsp;<span class="math-tex">\(-2^{size - 1}\)</span>&nbsp;до&nbsp;<span class="math-tex">\(2^{size - 1} - 1\)</span>. Как кодируются отрицательные числа покажем на примере типа&nbsp;<code>char</code>.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>00000000</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>11111111</code></td>
			<td><code>-1</code></td>
		</tr>
		<tr>
			<td><code>11111110</code></td>
			<td><code>-2</code></td>
		</tr>
		<tr>
			<td><code>11111101</code></td>
			<td><code>-3</code></td>
		</tr>
		<tr>
			<td><code>11111100</code></td>
			<td><code>-4</code></td>
		</tr>
	</tbody>
</table>

<p>Переводить число из&nbsp;<code>n</code>-й системы счисления в десятичную можно с помощью формулы&nbsp;<span class="math-tex">\(\sum{a_i \cdot n^i}\)</span>. Чтобы писать в коде числа в двоичном, восмеричном и шестнадцатиричном формате, следует перед ними написать&nbsp;<code>0b</code>,&nbsp;<code>0</code>&nbsp;и&nbsp;<code>0x</code>&nbsp;соответственно. Формат&nbsp;<code>%d</code>выполнит печать в десятичном формате, но&nbsp;<code>printf</code>&nbsp;также имеет форматы и для других систем счисления.</p>

<pre>
<code class="language-cpp">int main() {
    printf("%d %d %d\n", 0b1010, 013, 0xC);
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>10 11 12</code></p><h3 id="2.6.2">2.6.2</h2><p>Для манипуляций с битами чисел используются битовые операторы. Они взаимодействуют на каждую позицию чисел-аргументов независимо и действуют аналогично одноименным логическим операторам.</p>

<ul>
	<li><code>&amp;</code> — оператор И. Например, <code>0b10110 &amp; 0b11010 = 0b10010</code>.</li>
	<li><code>|</code> — оператор ИЛИ. Например, <code>0b10101 | 0xb11001 = 0x11101</code>.</li>
	<li><code>^</code> — оператор исключающее ИЛИ. Например, <code>0x1001 ^ 0x1100 = 0x0101</code>.</li>
	<li><code>~</code> — унарный оператор НЕ. Например, для типа <code>char</code>, <code>~0b1010 = 0b11110101</code>. (Обратите внимание на зависимость от размера типа данных.)</li>
	<li><code>&lt;&lt;</code> — оператор сдвига числа налево (в сторону увеличения числа). Например, <code>0b1001 &lt;&lt; 2 = 0b100100</code>. Сдвиг не циклический. Если никакие единичные биты не пропадают, то <code>a &lt;&lt; b</code><span class="math-tex">\(= a \cdot 2 ^ b\)</span>.</li>
	<li><code>&gt;&gt;</code> — оператор сдвига числа направо (в сторону уменьшения числа). Например, <code>0b1001 &gt;&gt; 2 = 0b10</code>. Сдвиг не циклический. <code>a &gt;&gt; b</code><span class="math-tex">\(= \lfloor \frac{a}{2^b} \rfloor\)</span>.</li>
</ul>

<p>Проверить наличие <code>i</code>-го бита в числе можно так: <code>if (a &amp; (1 &lt;&lt; i))</code>.</p>

<p>Битовые операторы имеют неочевидные приоритеты. Например, если вы хотите проверить, что <code>i</code>-й бит отсутствует, то такая проверка <code>if (a &amp; (1 &lt;&lt; i) == 0)</code> некорректна, так как оператор сравнения выполнится до оператора битового И.</p>

<p>Если вы проверяете наличие <code>i</code>-го бита в числе типа <code>long long</code>, то следует делать сдвиг так: <code>1ll &lt;&lt; i</code>. Суффикс <code>ll</code> делает число <code>1</code> типа <code>long long</code>. Если же не приписать этот суффикс и проверить, например, <code>40</code>-й бит то сначала выполниться сдвиг числа <code>1</code> типа <code>int</code> на <code>40</code> позиций, результат чего будет равен нулю, и уже затем он будет переведен в тип <code>long long</code>.</p>

<p>Подобные суффиксы есть и у других типов. Дробные числа, записанные так — <code>4.3</code> — имеют тип <code>double</code>, а не <code>float</code>, что не позволит написать, например, так: <code>const float a = 4.3;</code>(возможно, не во всех компиляторах). Числа типа <code>float</code> следует завершать символом <code>f</code>.</p><h3 id="2.6.3">2.6.3</h2><p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Найдите минимальный размер такого множества чисел <span class="math-tex">\(b_1, b_2, \ldots, b_m\)</span>, что <span class="math-tex">\(a_{b_1} | a_{b_2} | \ldots | a_{b_m} = a_1 | a_2 | \ldots | a_n\)</span></p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 20\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 2^{30} - 1\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное целое число <span class="math-tex">\(m\)</span> — минимальный размер подходящего множества.</p><h3 id="2.6.4">2.6.4</h2><p>Рассмотрим перевод дробного числа из двоичной записи в десятичную. Здесь используется та же формула, но теперь она распространяется и на отрицательные индексы.<span class="math-tex">\(0b10.1011 = 1 \cdot 2^1 + 0 \cdot 2^0 + 1 \cdot 2^{-1} + 0 \cdot 2^{-2} + 1 \cdot 2^{-3} + 1 \cdot 2^{-4} = 2 + 0 + 0.5 + 0 + 0.125 + 0.0625 = 2.6875\)</span></p>

<p>Рассмотрим структуру стандартного типа данных с плавающей точкой: <code>float</code>. Он состоит из <code>32</code>-х бит:</p>

<ul>
	<li>1 бит — знак, как у целых чисел</li>
	<li>2-9 биты — порядок (exponent)</li>
	<li>10-32 биты — мантисса (fraction)</li>
</ul>

<p>Порядок кодируется таким же образом, как и целое беззнаковое число. Обозначим его как <span class="math-tex">\(A\)</span>. Мантисса кодирует дробное число, меньшее единицы: первый бит кодирует <span class="math-tex">\(\frac{1}{2}\)</span>, второй бит кодирует <span class="math-tex">\(\frac{1}{4}\)</span> и так далее. Обозначим его как <span class="math-tex">\(B\)</span>. Тогда значение числа равно <span class="math-tex">\(2^{A - 127} \cdot (1 + B)\)</span></p>

<p>Посмотрим на такое значение типа <code>float</code>: <code>0 01111100 01000000000000000000000</code></p>

<ul>
	<li>Первый бит равен <code>0</code>, поэтому число неотрицательное.</li>
	<li>В порядке стоит число <span class="math-tex">\(A = 0 \cdot 2^7 + 1 \cdot 2^6 + 1 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0 = 124\)</span></li>
	<li>В мантиссе стоит число <span class="math-tex">\(B = 0 \cdot \frac{1}{2^1} + 1 \cdot \frac{1}{2^2} + 0 \cdot \frac{1}{2^3} + 0 \cdot \frac{1}{2^4} + \ldots = 0.25\)</span></li>
	<li>Итого данное число равно <span class="math-tex">\(2^{124 - 127} \cdot (1 + 0.25) = 0.15625\)</span></li>
</ul>

<p>Есть отдельные два случая:</p>

<ul>
	<li>Если <span class="math-tex">\(A = 0\)</span>, то формула выглядит так: <span class="math-tex">\(2^{A - 127} \cdot B\)</span></li>
	<li>Если <span class="math-tex">\(A = 255\)</span>, то это особое число, соответствующее, например, бесконечности или <code>nan</code> (not a number), которые возникают при некоторых некорректных математических операциях. Чтобы проверить число на <code>nan</code> следует сравнить его с собой: <code>if (x != x) { "x is nan" }</code>.</li>
</ul>

<p>Чтобы использовать тип <code>float</code> в функциях <code>printf</code> и <code>scanf</code>, следует использовать формат <code>%f</code>.</p>

<p>Существуют и другие типы чисел с плавающей точкой:</p>

<ul>
	<li><code>double</code> — 8 байт</li>
	<li><code>long double</code> — не определено (обычно 10 байт)</li>
</ul><h3 id="2.6.5">2.6.5</h2><p>Ранее я рассказывал об отдельном способе кодирования числа типа <code>float</code>, когда его показатель равен нулю. Зачем это необходимо?</p><h3 id="2.6.6">2.6.6</h2><p>Перечисления (enumerations) — это способ задать числам идентификатор, привязав их при этом к контексту. Рассмотрим программу:</p>

<pre><code class="language-cpp">enum E {
    A,
    B,
    C = 10,
    D,
    E
};

int main() {
    enum E e = A;
    printf("%d %d %d %d %d %d\n", A, B, C, D, E, e);
    return 0;
}</code></pre>

<p>Мы объявляем перечисление с помощью ключевого слова <code>enum</code>, затем мы даем ему название <code>E</code> и в фигурных скобках перечисляем значение. Сами значения в перечислении используются так же, как и переменные типа число-константа <code>const int</code>. Эти значения мы можем вывести без ограничений, как и если бы это были константы. Посмотрите на логику присваивания значений им. Мы можем также объявлять объекты или инстансы (instances) перечисления, указывая их тип как <code>enum E</code>. Этот тип это всего лишь число.</p>

<p>Вывод этой программы: <code>0 1 10 11 12 0</code></p>

<p>Здесь может возникнуть вопрос: а где же привязка к контексту (названию перечисления), ведь их содержимое ведет себя как глобальные переменные? Этой привязки нет, что является недостатком перечислений в языке C. Тем не менее, в C++ были введены классы перечислений (enum classes), которые решают этот недостаток.</p>

<p>Перейдем к структурам (structures). Они необходимы для объединения группы переменных для того, чтобы манипулировать ими одновременно. В отличии от массивов, типы переменных в структурах разные, и их количество сильно ограничено.</p>

<pre><code class="language-cpp">struct S {
    int a;
    long long b;
};

int main() {
    struct S s1;
    s1.a = 4;
    s1.b = 7;
    printf("%d %d ", s1.a, s1.b);
    
    struct S *s2 = (struct S*)malloc(sizeof(struct S));
    (*s2).a = 12;
    s2-&gt;b = 17;
    printf("%d %d\n", s2-&gt;a, s2-&gt;b);
    free(s2);
    
    return 0;
}</code></pre>

<p>Мы объявляем структуру с помощью ключевого слова <code>struct</code>, следом за которым указываем название структуры и её содержимое в фигурных скобках. Объект или инстанс структуры объявляются с указыванием типа <code>struct S</code> и названия структуры: <code>struct S s1;</code>. Как только мы объявили этот объект, у нас появились сразу две связанные переменные, к которым мы обращаемся через идентификатор <code>struct</code>.  Хоть структуры и является сложным типом, их можно передавать в функции и возвращать из них. К полям (field) структуры мы обращаемся через символ <code>.</code>.</p>

<p>Можно объявлять объекты структуры динамически. Тогда, чтобы получить доступ к полям структуры, необходимо выполнить разыменование. Так как это распространенное действие (вы даже чаще будете взаимодействовать именно с указателями на структуры), для него есть свой синтаксис <code>-&gt;</code>.</p><h3 id="2.6.7">2.6.7</h2><p>Есть последовательность чисел, которая изначально состоит из единственного числа <span class="math-tex">\(0\)</span>, указатель, который изначально указывает на первую позицию последовательности, и счетчик <span class="math-tex">\(x\)</span>, изначально равный <span class="math-tex">\(1\)</span>.</p>

<p>Необходимо обработать <span class="math-tex">\(q\)</span> запросов четырех типов:</p>

<ol>
	<li>Сдвинуть указатель налево. Перед этим действием указатель находится не на первой позиции.</li>
	<li>Сдвинуть указатель направо. Перед этим действием указатель находится не на последней позиции.</li>
	<li>Вставить элемент <span class="math-tex">\(x\)</span> после указателя, а затем увеличить значение <span class="math-tex">\(x\)</span> на единицу.</li>
	<li>Удалить элемент, на который указывает указатель, сдвинув его на предыдущий элемент. Перед этим действием указатель находится не на первой позиции.</li>
</ol>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(q\)</span> (<span class="math-tex">\(1 \le q \le 1000\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(q\)</span> целых чисел <span class="math-tex">\(k_1, k_2, \ldots, k_q\)</span> (<span class="math-tex">\(1 \le k_i \le 4\)</span>) — запросы, которые необходимо обработать. Гарантируется, что запросы удовлетворяют ограничениям, указанным в условии.</p>

<h4>Формат вывода</h4>

<p>Выведите последовательность чисел после выполнения всех запросов.</p><h3 id="2.6.8">2.6.8</h2><p>Один из способов изменить битовую запись числа типа <code>float</code> напрямую следующий:</p>

<pre><code class="language-cpp">int main() {
    float a;
    int *b = (int*)(&amp;a);
    *b = 0x3FFFFFFF;
    printf("%f\n", a);
    return 0;
}</code></pre>

<p>(Попробуйте самостоятельно выяснить, какое число будет выведено.)</p>

<p>В C++ подобные манипуляции можно делать с помощью оператора <code>reinterpret_cast</code>. В C также можно сделать это с помощью объединений <code>union</code>.</p>

<p>Объединение реализует сумму типов (sum types), то есть её содержимое является одним из нескольких типов. Однако, в силу простоты языка C и того, как в нем объединения реализованы:</p>

<ul>
	<li>Узнать, какой тип храниться в конкретном объекте объединения, без дополнительной информации невозможно.</li>
	<li>Само обращение к объединению является лишь приведением одного и того же адреса в тип, который мы запрашиваем.</li>
</ul>

<p>Таким образом, объединения отличаются от просто приведения типа тем, что выбор типов ограничен, и у них есть псевдонимы.</p>

<pre><code class="language-cpp">union U {
    float a;
    int b;
};

int main() {
    union U u;
    u.b = 0x3FFFFFFF;
    printf("%f\n", u.a);
    return 0;
}</code></pre>

<p>Можно типам данных давать псевдонимы. Например, если мы напишем <code>typedef int i32;</code>, то мы сможем, написав <code>i32</code> создать переменную типа <code>int</code>: <code>i32 a = 3;</code>.</p>

<p>К перечислениям, структурам и объединения можно применять такой синтаксис:</p>

<pre><code class="language-cpp">typedef int i32;

typedef struct {
    i32 a;
} S;

int main() {
    S s;
    s.a = 7;
    return 0;
}</code></pre>

<p>При таком объявлении структуры мы не должны писать ключевое слово <code>struct</code> в типе.</p>
<h3 id="2.7">2.7. Функции высшего порядка, макросы, шаблоны</h3>
<h3 id="2.7.1">2.7.1</h2><p>В C можно передавать в функции указатели на другие функции, чтобы строить функции высших порядков.</p>

<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

int apply(int x, int(*f)(int)) {
    return f(x);
}

int main() {
    printf("%d\n", apply(5, square));
    return 0;
}</code></pre>

<p>Функция <code>square</code> возвращает квадрат аргумента и интереса не представляет. Посмотрим на второй аргумент функции <code>apply</code>. Тип этого аргумента — <code>int(*)(int)</code> — указатель на функцию, которая принимает один аргумент типа <code>int</code>, и возвращает тип <code>int</code>. <code>f</code> — это название аргумента. Функция <code>apply</code> применяет свой второй аргумент к первому аргументу.</p>

<p>Указатели на функции можно объявлять и как обычные локальные переменные.</p>

<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

int main() {
    int(*foo)(int) = square;
    printf("%d\n", foo(5));
    return 0;
}</code></pre>

<p>Выводы обеих программ — <code>25</code></p>

<p>Указатели на функции обычно используются для двух целей:</p>

<ul>
	<li>Создание функций высшего порядка</li>
	<li>Создание наследования</li>
</ul><h3 id="2.7.2">2.7.2</h2><p>В языке C нет синтаксиса для создания вложенных функций (объявления функции в теле другой функции). Как можно добиться похожего функционала?</p><h3 id="2.7.3">2.7.3</h2><p>До компиляции программы выполняется её препроцессирование, которое заключается в выполнении всех строк, которые начинаются с символа <code>#</code>. Помимо включения файлов с помощью <code>#include</code>, препроцессор даёт возможность писать макросы. Макросы могут напоминать функции, но у них есть и различия.</p>

<pre><code class="language-cpp">#define FOO 5
#define DOUBLE1(x) (x * 2)
#define DOUBLE2(x) ((x) * 2)

int main() {
    printf("%d ", FOO);
    printf("%d ", DOUBLE1(4 + 1));
    printf("%d\n", DOUBLE2(4 + 1));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>5 6 10</code></p>

<p><code>#define</code> выполняет подстановку своего третьего аргумента заместо второго в каждом его вхождении в программу. Например, все вхождения <code>FOO</code> заменятся на <code>5</code>. Макросы могут иметь аргументы, которые будут также подставлены без каких либо изменений.</p>

<p>Здесь сразу обратите внимание на второе число в выводе и попробуйте самостоятельно понять, почему в результате получилось оно.</p>

<p>Чтобы это понять, раскроем макрос вручную: <code>DOUBLE1(4 + 1) -&gt; {x = "4 + 1"} -&gt; (4 + 1 * 2) = 6</code>. Это одна из главных проблем использования макросов — необходимость продумывать, как будет выполнено раскрытие. Конкретно эта проблема решается заключение аргумента макроса в скобки, чтобы сначала выполнить вычисление аргумента. Однако, не всегда решение подобных проблем простое и вообще возможное.</p>

<p>Чем макрос может быть хорош по сравнению с функцией? Он может позволить создавать подобие функции для обобщенного типа (то есть, без уточнения типа). Например, обычно с помощью макроса реализовывают функции <code>min</code> и <code>max</code>.</p>

<pre><code class="language-cpp">#define MIN(X, Y) \
    (X &lt; Y) ? X : Y

int main() {
    printf("%d %d\n", MIN(3, 5), MIN('b', 'a'));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>3 97</code></p>

<p>Символ <code>\</code> продолжает действие конструкции препроцессора на следующую строку. Здесь мы с помощью тернарного оператора написали подобие функции, которое на самом деле будет просто подставлять в код выражение с тернарным оператором: <code>MIN(3, 5) -&gt; {X = 3, Y = 5} -&gt; (3 &lt; 5) ? 3 : 5</code>.</p>

<p>Если требуется в макросе выполнить последовательность действий, обычно делают так:</p>

<pre><code class="language-cpp">#define PRINT(X, Y)        \
    {                      \
        printf("%d ", X);  \
        printf("%d\n", Y); \
    }

int main() {
    PRINT(4, 7)
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>4 7</code></p><h3 id="2.7.4">2.7.4</h2><p>В языке C нет встроенных способов создания функций для обобщенных типов. Мы можем написать макрос, который будет объявлять функцию для заданного типа (ведь в качестве аргументов макроса можно использовать не только значение). Однако до определенного стандарта в языке C не было автоматического определения функции на основе типа. (В языке C++ для этого есть перегрузка функций. Как она работает, и почему она отсутствует в языке C, мы узнаем позже.)</p>

<p>Есть разные способы организации функции для обобщенных типов, и в разных проектах используются разные. Вот один из способов.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE(X) \
        sizeof(X) / sizeof(X[0])
        
typedef struct {
    int x;
} S;

typedef struct {
    int x;
} T;

T foo(S s) {
    T t;
    t.x = s.x * 2;
    return t;
}

int boo(int x) {
    return x + 1;
}

#define MAP(F, A, B)                    \
B* F(B(*f)(A), A* l1, int sz) {         \
    B* l2 = (B*)malloc(sz * sizeof(B)); \
    for (int i = 0; i &lt; sz; i++) {      \
        l2[i] = f(l1[i]);               \
    }                                   \
    return l2;                          \
}

MAP(map_ii, int, int)
MAP(map_st, S, T)

int main() {
    int i;
    int lst1[4] = {1, 4, 6, 11};
    int *lst1_out = map_ii(boo, lst1, SIZE(lst1));
    for (i = 0; i &lt; SIZE(lst1); i++) {
        printf("%d ", lst1_out[i]);
    }
    printf("\n");
    
    S lst2[4] = {{1}, {3}, {5}, {9}};
    T *lst2_out = map_st(foo, lst2, SIZE(lst2));
    for (i = 0; i &lt; SIZE(lst2); i++) {
        printf("%d ", lst2_out[i].x);
    }
    printf("\n");
    
    return 0;
}</code></pre>

<p>Реализуем функцию <code>map</code> из функциональных языков, которая принимает функцию и массив элементов, после чего создает новый массив, полученный поэлементным применением функции к исходному массиву. Посмотрим на сам макрос:</p>

<pre><code class="language-cpp">#define MAP(F, A, B)                    \
B* F(B(*f)(A), A* l1, int sz) {         \
    B* l2 = (B*)malloc(sz * sizeof(B)); \
    for (int i = 0; i &lt; sz; i++) {      \
        l2[i] = f(l1[i]);               \
    }                                   \
    return l2;                          \
}</code></pre>

<p>Макрос принимает название функции <code>F</code>, которую следует объявить, и входной и выходной типы <code>A</code> и <code>B</code>. Сигнатура функции выглядит так: <code>B* F(B(*f)(A), A* l1, int sz)</code>, то есть она принимает функцию из типа <code>A</code> в тип <code>B</code> и массив типа <code>A</code> с его размером, а возвращает массив типа <code>B</code>. То есть, функция <code>map</code> параметризована двумя типами.</p>

<p>Мы создаем функцию <code>map</code> для типов <code>int</code> и <code>int</code> так: <code>MAP(map_ii, int, int)</code>. После раскрытия макроса вручную мы получим такое:</p>

<pre><code class="language-cpp">int* map_ii(int(*f)(int), int* l1, int sz) {
    int* l2 = (int*)malloc(sz * sizeof(int));
    for (int i = 0; i &lt; sz; i++) {
        l2[i] = f(l1[i]);
    }
    return l2;
}</code></pre>

<p>Обратите внимание на то, что <code>map</code> не освобождает входной массив. Следует ли это делать зависит от вашего стиля создания функций обобщенных типов.</p>

<p>Вызвать функцию <code>map</code> для типов <code>int</code> и <code>int</code> мы можем так: <code>map_ii(boo, lst1, SIZE(lst1));</code>. К сожалению, нам необходимо самостоятельно подбирать правильное название функции на основе типа. В более современном языка C есть ключевое слово <code>_Generic</code>, которое выполняет эту работу за нас.</p>

<p>Вывод этой программы:</p>

<pre><code>2 5 7 12 
2 6 10 18 
</code></pre><h3 id="2.7.5">2.7.5</h2><p>Реализуйте с помощью макроса функцию <code>zip</code>, которая принимает вторым и третьим аргументом массивы типа <code>A</code> и <code>B</code>, а первым аргументом [функцию, которая принимает два аргумента типа <code>A</code> и <code>B</code>, и возвращает тип <code>C</code>], и создает новый массив, полученный поиндексным применением функции к элементам массивов (первый к первому, второй ко второму и т.д.). Подставьте эту программу.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

#define SIZE(X) \
        sizeof(X) / sizeof(X[0])
        
typedef struct {
    int x;
} S;

typedef struct {
    int x;
} T;

typedef struct {
    int x;
} U;

U doo(S s, T t) {
    U u;
    u.x = s.x * t.x;
    return u;
}

ZIP(zip_stu, S, T, U);

int main() {
    int i;
    S lst1[4] = {{1}, {3}, {5}, {9}};
    T lst2[4] = {{2}, {6}, {10}, {17}};
    U *lst3 = zip_stu(doo, lst1, lst2, SIZE(lst1));
    assert(lst3[0].x == 2);
    assert(lst3[1].x == 18);
    assert(lst3[2].x == 50);
    assert(lst3[3].x == 153);
    
    return 0;
}</code></pre><h3 id="2.7.6">2.7.6</h2><p>Указатели на функции дают возможность сделать подобие наследования. Мы можем написать функции-конструкторы, которые будут подставлять в объекты структур указатели на необходимые функции. Однако, функции через указатели не могут видеть содержимое структур, поэтому придется передавать объект структуры вместе с каждым вызовом её функции вручную. (На самом деле, в языке C++ указатель на объект, функция которого вызывается, всегда передается в функцию и называется <code>this</code>.)</p>

<pre><code class="language-cpp">#include &lt;stdlib.h&gt;

const float pi = 3.14f;

struct Figure;

typedef struct {
    float x;
    float (*square)(struct Figure*);
} Figure;

float circle_square(Figure *f) {
    return pi * f-&gt;x * f-&gt;x;
}

float square_square(Figure *f) {
    return f-&gt;x * f-&gt;x;
}

Figure *build_circle(float x) {
    Figure *f = (Figure*)malloc(sizeof(Figure));
    f-&gt;x = x;
    f-&gt;square = circle_square;
    return f;
}

Figure *build_square(float x) {
    Figure *f = (Figure*)malloc(sizeof(Figure));
    f-&gt;x = x;
    f-&gt;square = square_square;
    return f;
}

int main() {
    Figure *circle = build_circle(3);
    Figure *square = build_square(3);
    printf("%f %f\n", circle-&gt;square(circle), square-&gt;square(square));
    
    return 0;
}</code></pre>

<p>Функции <code>circle_square</code> и <code>square_square</code> — это соответствующие реализации функции <code>square</code> (площадь) для структур <code>circle</code> (окружность) и <code>square</code> (квадрат). Функции <code>build_circle</code> и <code>build_square</code> — это конструкторы, которые создают объект структуры и подставляют нужные реализации функций.</p>

<p>В результате этих манипуляций нам не нужно указывать вручную, какую функцию подсчета площади вызывать. На самом деле, в языке C++ выбор нужной функции организован похожим образом: объекты содержат указатели на нужные функции. Это называется виртуальными таблицами (virtual tables), и позже мы узнаем, как они устроены.</p>

<p>Тем не менее, несоответствие локальных переменных у структур в языке C решить нельзя. Если бы мы хотели ввести структуру <code>rectangle</code> (прямоугольник), которая задается двумя числами, сделать это красиво у нас не получится.</p><h3 id="2.7.7">2.7.7</h2><p>Подобно функциям для обобщенных типов можно с помощью макросов организовать структуры для обобщенных типов. Для создания объектов таких структур потребуется также генерация их конструкторов. Попробуйте реализовать это любым способом.</p>
<h2 id="3">3. Компиляция, gcc</h2>

<h3 id="3.1">3.1. Фазы компиляции</h3>
<h3 id="3.1.1">3.1.1</h2><p>Напомню, что мы работает с компилятором <code>gcc</code>.</p>

<p>Компиляция состоит из четырёх шагов:</p>

<ol>
	<li>Препроцессирование (preprocessing)</li>
	<li>Компиляция</li>
	<li>Ассемблирование</li>
	<li>Компоновка (linking)</li>
</ol>

<p>Мы запускаем компиляцию командой <code>gcc &lt;filename&gt;</code>, где filename — название файла с кодом. Его расширение должно быть <code>.c</code>. При таком запуске мы получим исполняемый файл с неким именем по умолчание. Имя выходного файла можно задать явно флагом <code>-o &lt;filename&gt;</code>.</p>

<ul>
	<li>Чтобы выполнить только первый этап, необходимо добавить флаг <code>-E</code>.</li>
	<li>Чтобы выполнить первый и второй этап, необходимо добавить флаг <code>-S</code>.</li>
	<li>Чтобы выполнить первый, второй и третий этапы, необходимо ввести флаг <code>-c</code>.</li>
</ul>

<p> Далее мы изучим каждый из этапов подробнее.</p>

<p>С этого момента наши программы будут состоять из нескольких файлов.</p><h3 id="3.1.2">3.1.2</h2><p> <code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Препроцессирование выполняет все строки, которые начинаются с символа <code>#</code>(и следующие за ними, если они заканчиваются символом <code>\</code>). Это могут быть инструкции <code>#include</code>, <code>#define</code>, <code>#ifdef</code> и некоторые другие.</p>

<p>Инструкция <code>#include</code> вставляет содержимое файла. Если название файла заключено в <code>""</code>, то путь файла указывается относительно текущего файла (в примере файл <code>foo.h</code> должен находиться в одной директории с файлом <code>main.c</code>). Если название файла заключено в <code>&lt;&gt;</code>, то компилятор попытается найти файл относительно стандартной глобальной директории заголовочных файлов (там, где лежат файлы <code>stdio.h</code>, <code>stdlib.h</code> и т.д.) и относительно переданных ему директорий заголовочных файлов с помощью флага <code>-I</code> (например, <code>gcc -I. main.c</code>, что означает, искать заголовочные файлы в директории <code>.</code> (то есть, в текущей)).</p>

<p>Выполните <code>gcc main.c -E</code>, чтобы выполнить препроцессирование. Вы получите такой вывод:</p>

<pre><code class="language-cpp"># 0 "main.c"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "&lt;command-line&gt;" 2
# 1 "main.c"
# 1 "foo.h" 1
int foo(int x) {
    return x + 1;
}
# 2 "main.c" 2

int main() {
    printf("%d\n", foo(2));
    return 0;
}
</code></pre>

<p>Результатом препроцессирования всегда является один файл. Обратите внимание, что содержимое файла <code>foo.h</code> непосредственно вставилось в выходной файл без каких-либо изменений.</p>

<p>Рассмотрим такую программу.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#ifdef FOO
#define DOO 4
#elif BOO
#define DOO 5
#else
#define DOO 6
#endif

#define FOO 3

#ifdef FOO
#define BOO 4
#endif

int main() {
    printf("%d %d %d\n", FOO, BOO, DOO);
    return 0;
}</code></pre>

<p>В результате её препроцессирования "переменные" <code>FOO</code>, <code>BOO</code>, <code>DOO</code> заменятся на, соответственно, значения <code>3</code>, <code>4</code>, <code>6</code>. В целом, логика работы таких ветвлений очевидна. Обратим лишь внимание на то, что обрабатываются они просто сверху вниз, и поэтому в блоке, который определяет переменную <code>DOO</code>, переменные <code>FOO</code> и <code>BOO</code> ещё не определены, и переменная <code>DOO</code> получает значение <code>6</code>.</p>

<p>Если вы не определите значение какой либо переменной, то её замены в коде не произойдет. При этом, полученный код может оказаться корректным.</p>

<p>Инструкции <code>#define</code> могут принимать аргументы. Такие инструкции называются макросами, и мы их уже видели.</p><h3 id="3.1.3">3.1.3</h2><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компиляция переписывает код в язык ассемблера (Assembly). Язык ассемблера мы изучим позже.</p>

<p>Выполните <code>gcc main.c -S</code>, чтобы выполнить компиляцию. Вы получите такой вывод (содержимое обрезано):</p>

<pre><code class="language-no-highlight">	.file	"main.c"
	.text
	.globl	foo
	.type	foo, @function
foo:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...</code></pre>

<p>Кратко охаректеризовать язык ассемблера можно так. У нас есть порядка десяти ячеек памяти, которые называются регистрами, и доступ к этим ячейкам самый быстрый. Кроме того у нас есть оперативная память (RAM), которая представляет собой большую ленту пронумерованных ячеек. Наша программа является последовательностью инструкций в оперативной памяти, которые имеют следующий вид:</p>

<ul>
	<li>Записать в регистр <code>D</code> значение, равное сумме значений в регистрах <code>B</code> и <code>I</code>.</li>
	<li>Записать в регистр <code>E</code> значение, записанное в оперативной памяти в ячейке под номером, который записан в регистре <code>A</code>.</li>
	<li>Если значение в регистре <code>H</code> равно нулю, то продолжить выполнение программы с инструкции, которая находится в оперативной памяти в ячейке под номером, который записан в регистре <code>C</code>.</li>
</ul>

<p>Понятно, что с одной стороны такой язык легко выучить из-за его простоты, с другой стороны его очень тяжело читать из-за отсутствия конструкций, отвечающих за высокоуровневую организацию кода.</p><h3 id="3.1.4">3.1.4</h2><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Ассемблирование переписывает код, написанный на языке ассемблера, в объектный файл (имеет расширение <code>.o</code> или <code>.obj</code>). Объектный файл состоит из сегментов, которые содержат инструкции, из которых состоит наша программа, а также некоторую метаинформацию.</p>

<p>Выполните <code>gcc main.c -c</code>, чтобы выполнить ассемблирование. Выходной файл не состоит из читаемого текста. Выполним сначала <code>hd main.o</code>, чтобы посмотреть содержимое, как есть (содержимое обрезано):</p>

<pre><code class="language-no-highlight">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|
00000020  00 00 00 00 00 00 00 00  e0 02 00 00 00 00 00 00  |................|
00000030  00 00 00 00 40 00 00 00  00 00 40 00 0e 00 0d 00  |....@.....@.....|
00000040  f3 0f 1e fa 55 48 89 e5  89 7d fc 8b 45 fc 83 c0  |....UH...}..E...|
00000050  01 5d c3 f3 0f 1e fa 55  48 89 e5 bf 02 00 00 00  |.].....UH.......|
00000060  e8 00 00 00 00 89 c6 48  8d 05 00 00 00 00 48 89  |.......H......H.|
00000070  c7 b8 00 00 00 00 e8 00  00 00 00 b8 00 00 00 00  |................|
00000080  5d c3 25 64 0a 00 00 47  43 43 3a 20 28 55 62 75  |].%d...GCC: (Ubu|
00000090  6e 74 75 20 31 31 2e 34  2e 30 2d 31 75 62 75 6e  |ntu 11.4.0-1ubun|
000000a0  74 75 31 7e 32 32 2e 30  34 29 20 31 31 2e 34 2e  |tu1~22.04) 11.4.|
000000b0  30 00 00 00 00 00 00 00  04 00 00 00 10 00 00 00  |0...............|
000000c0  05 00 00 00 47 4e 55 00  02 00 00 c0 04 00 00 00  |....GNU.........|
...</code></pre>

<p>Это мало что нам говорит. Для анализа объектных файлов есть специальные программы.</p>

<p><code>readelf</code> покажет нам структуру файла и содержимое некоторых секций (sections). Выполните <code>readelf main.o -a</code>.</p>

<pre><code class="language-no-highlight">ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
...
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000042  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000001f0
       0000000000000048  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000082
       0000000000000000  0000000000000000  WA       0     0     1
...
Relocation section '.rela.text' at offset 0x1f0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000021  000400000004 R_X86_64_PLT32    0000000000000000 foo - 4
00000000002a  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000037  000600000004 R_X86_64_PLT32    0000000000000000 printf - 4
...
Symbol table '.symtab' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     4: 0000000000000000    19 FUNC    GLOBAL DEFAULT    1 foo
     5: 0000000000000013    47 FUNC    GLOBAL DEFAULT    1 main
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
...</code></pre>

<p>Мы изучим это содержимое позже.</p>

<p><code>objdump</code> покажет нам машинный код на языке ассемблера. Выполните <code>objdump main.o -d</code>.</p>

<pre><code class="language-no-highlight">
main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt; foo&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 01             	add    $0x1,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    

0000000000000013 &lt; main&gt;:
  13:	f3 0f 1e fa          	endbr64 
  17:	55                   	push   %rbp
  18:	48 89 e5             	mov    %rsp,%rbp
  1b:	bf 02 00 00 00       	mov    $0x2,%edi
  20:	e8 00 00 00 00       	call   25 &lt;main+0x12&gt;
  25:	89 c6                	mov    %eax,%esi
  27:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 2e &lt;main+0x1b&gt;
  2e:	48 89 c7             	mov    %rax,%rdi
  31:	b8 00 00 00 00       	mov    $0x0,%eax
  36:	e8 00 00 00 00       	call   3b &lt;main+0x28&gt;
  3b:	b8 00 00 00 00       	mov    $0x0,%eax
  40:	5d                   	pop    %rbp
  41:	c3                   	ret</code></pre>

<p>Здесь объявлены две функции. В <code>&lt;&gt;</code> скобках показаны названия функций. Сравните их содержимое с результатом выполнения команды <code>gcc main.c -S</code>.</p><h3 id="3.1.5">3.1.5</h2><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компоновка объединяет несколько объектных файлов, подставляет реализации функций, формирует сегменты (segments) из секций в объектных файлах. В результате мы получаем исполняемый файл (но можно получить и, например, shared object), который на ОС Linux не имеет расширения, а его формат называется <code>elf</code>; на ОС Windows имеет расширение <code>.exe</code>, а его формат называется <code>PE</code> (Portable Executable).</p>

<p>Выполните <code>gcc main.c</code>, чтобы выполнить компоновку. Выходной файл не состоит из читаемого текста. Рассматривать его мы не будем. Вместо этого выполним <code>readelf a.out -a</code>. (По умолчанию, выходной исполняемый файл называется <code>a.out</code>. Вы можете задать название явно с помощью флага <code>-o</code>: <code>gcc main.c -o program</code>.)</p>

<pre><code class="language-no-highlight">...
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000628 0x0000000000000628  R      0x1000
...
 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got</code></pre>

<p>Структура исполняемого файла похожа на структуру объектного файла. Однако здесь помимо секций у нас присутствуют и сегменты (по какой то причине, program headers это section headers). Обратите внимание на таблицу внизу, которая показывает, из каких секций состоит каждый сегмент. Например, сегмент под номером <code>01</code> (в первой таблице мы видим, что это сегмент с названием <code>INTERP</code> (по какой-то причине, они не пронумерованы, нумерация идет с <code>00</code>)) состоит из одной секции <code>.interp</code>. То, как происходит это сопоставление, написано в linker script-е. <code>gcc</code> имеет стандартный linker script, но мы можем написать свой (и мы это сделаем).</p>

<p>Выполним <code>objdump a.out -d</code>.</p>

<pre><code class="language-no-highlight">...
Disassembly of section .init:

0000000000001000 &lt;_init&gt;:
    1000:	f3 0f 1e fa          	endbr64 
    1004:	48 83 ec 08          	sub    $0x8,%rsp
    1008:	48 8b 05 d9 2f 00 00 	mov    0x2fd9(%rip),%rax        # 3fe8 &lt;__gmon_start__@Base&gt;
    100f:	48 85 c0             	test   %rax,%rax
    1012:	74 02                	je     1016 &lt;_init+0x16&gt;
    1014:	ff d0                	call   *%rax
    1016:	48 83 c4 08          	add    $0x8,%rsp
    101a:	c3                   	ret
...
Disassembly of section .text:

0000000000001060 &lt;_start&gt;:
    1060:	f3 0f 1e fa          	endbr64 
    1064:	31 ed                	xor    %ebp,%ebp
    1066:	49 89 d1             	mov    %rdx,%r9
    1069:	5e                   	pop    %rsi
    106a:	48 89 e2             	mov    %rsp,%rdx
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1071:	50                   	push   %rax
    1072:	54                   	push   %rsp
    1073:	45 31 c0             	xor    %r8d,%r8d
    1076:	31 c9                	xor    %ecx,%ecx
    1078:	48 8d 3d dd 00 00 00 	lea    0xdd(%rip),%rdi        # 115c &lt;main&gt;
    107f:	ff 15 53 2f 00 00    	call   *0x2f53(%rip)        # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;
    1085:	f4                   	hlt    
    1086:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    108d:	00 00 00
...
0000000000001149 &lt; foo&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
    1151:	89 7d fc             	mov    %edi,-0x4(%rbp)
    1154:	8b 45 fc             	mov    -0x4(%rbp),%eax
    1157:	83 c0 01             	add    $0x1,%eax
    115a:	5d                   	pop    %rbp
    115b:	c3                   	ret    

000000000000115c &lt; main&gt;:
    115c:	f3 0f 1e fa          	endbr64 
    1160:	55                   	push   %rbp
    1161:	48 89 e5             	mov    %rsp,%rbp
    1164:	bf 02 00 00 00       	mov    $0x2,%edi
    1169:	e8 db ff ff ff       	call   1149 &lt;foo&gt;
    116e:	89 c6                	mov    %eax,%esi
    1170:	48 8d 05 8d 0e 00 00 	lea    0xe8d(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1177:	48 89 c7             	mov    %rax,%rdi
    117a:	b8 00 00 00 00       	mov    $0x0,%eax
    117f:	e8 cc fe ff ff       	call   1050 &lt;printf@plt&gt;
    1184:	b8 00 00 00 00       	mov    $0x0,%eax
    1189:	5d                   	pop    %rbp
    118a:	c3                   	ret
...</code></pre>

<p>Количество кода резко увеличилось. Даже в секции <code>.text</code>, в которой раньше находились наши две функции, теперь присутствует множество новых функций. Все они были сгенерированы в результате выполнения linker script-а.</p>

<p>Обратите внимание на значение <code>Entry point address: 0x1060</code> в начале вывода программы <code>readelf</code>. Это адрес инструкции, с которой начнется выполнение программы. Попобуйте найти соответствующий адрес в выводе программы <code>objdump</code>. Это не функция <code>main</code>!</p><h3 id="3.1.6">3.1.6</h2><p>Вспомним строку <code>Entry point address: 0x1060</code> из вывода программы <code>readelf</code> на исполняемый файл. Здесь имеется ввиду адрес в оперативной памяти (RAM). Значит ли это, что программа этой строкой уже решила, что она будет находится именно в этом месте памяти? А что будет, если мы запустим её дважды — как удовлетворить условие для обоих процессов?</p>
<h3 id="3.2">3.2. Многомодульные программы</h3>
<h3 id="3.2.1">3.2.1</h2><p><code>main.c</code></p>

<pre><code class="language-cpp">int foo(int);

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p>В этой программе объявлена функция <code>foo</code>. Но её реализация отсутствует. Попробуем выполнить компиляцию без компоновки: <code>gcc main.c -c</code>. Компиляция завершена успешно и мы получили объектный файл <code>main.o</code>!</p>

<p>Если же мы попытаемся выполнить компоновку <code>gcc main.c</code>, то получим ошибку:</p>

<pre><code class="language-no-highlight">/usr/bin/ld: /tmp/cchwCA2L.o: in function `main':
main.c:(.text+0xe): undefined reference to `foo'
collect2: error: ld returned 1 exit status</code></pre>

<p>Задача компоновщика подставить реализации функций из других модулей, которые мы ему подали. Мы подали компоновщику единственный модуль, в котором он не нашел реализацию функции <code>foo</code>.</p>

<p>Как же выглядит функция <code>foo</code> в объектном файле, когда её реализация отсутствует? В инструкциях вызова этой функции не указывается её адрес (ведь он неизвестен). А информация о том, что этот адрес должен быть подставлен на этапе компоновки, хранится в секциях, в названии которых есть подстрока <code>rel</code> (проверьте, есть ли такие секции в вашем объектном файле).</p>

<p>Реализуем функцию <code>foo</code> в другом модуле.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}
</code></pre>

<p>Если мы попытаемся скомпилировать это в исполняемый файл, то получим ошибку   <code>undefined reference to `main' </code>. Скомпилируем в объектный файл <code>gcc foo.c -c</code>.      </p>

<p>Чтобы выполнить компоновку обоих объектных файлов, просто напишем их всех при вызове <code>gcc</code>: <code>gcc main.o foo.o</code>. Полученный исполняемый файл можно запустить.</p><h3 id="3.2.2">3.2.2</h2><p>В предыдущем примере мы, чтобы иметь возможность вызывать функцию <code>foo</code> в модуле <code>main.c</code>, объявили её: <code>int foo(int);</code>. Делать это таким способом не удобно. Для каждого <code>.c</code> файла создают заголовочный (header) <code>.h</code> файл, в котором записаны объявления функций, и который мы добавляем с помощью <code>#include</code>, чтобы получить эти объявления.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p>Скомпилировать такой проект можно так:</p>

<pre><code class="language-no-highlight">gcc main.c -c
gcc foo.c -c
gcc main.o foo.o</code></pre>

<p>, либо так: <code>gcc main.c foo.c</code></p>

<p>Обычно, внешние библиотеки распространяются только в виде заголовочных и объектных файлов; без исходного кода реализаций функций. (При этом объектные файлы могут быть объединены в архивы и/или быть shared.) При этом сами реализации функций могут быть и не на языке C (мы это сделаем позже).</p>

<p>Но как компилятор может удостовериться в том, что сигнатура функции в заголовочном файле соответствует её сигнатуре в реализации, когда компилятор видит только объектный файл? (Вам придется пока поверить мне, что общих способов узнать сигнатуру функции по объектному файлу нет.) Ответ простой — никак!</p>

<p>Изменим только файл <code>foo.c</code></p>

<pre><code class="language-cpp">void foo(int x) {
    
}</code></pre>

<p>Это успешно скомпилируется и скомпонуется, а значение, которое <code>printf</code> выведет, не имеет отношения к функции <code>foo</code>.</p><h3 id="3.2.3">3.2.3</h2><p>Разрешается объявлять функции в программе многократно, а определять их только единожды. По хорошему, реализации функций должны быть только в <code>.c</code> файлах (хотя в C++ есть способы делать это и в <code>.h</code> файлах).</p>

<p>Однако, в заголовочных файлах мы также объявляем структуры (ведь, если они используются другими модулями, они должны знать содержимое структуры). Структуры можно объявлять лишь единожды, что может вызвать проблемы.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">#include "boo.h"

int foo(int x) {
    if (x == 0)
        return x + 1;
    else
        return x + boo(x - 1);
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">struct foo {
    int x;
};</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">#include "boo.h"

void add(struct boo *b) {
    b-&gt;f.x++;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">#include "foo.h"

struct boo {
    struct foo f;
};

void add(struct boo *b);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"
#include "boo.h"

int main() {
    struct foo f;
    struct boo b;
    b.f.x = 3;
    add(&amp;b);
    return 0;
}</code></pre>

<p>В этой программе в модуле <code>main.c</code> структура <code>foo</code> объявлена дважды, что приводит к ошибке. Проблема в том, что и модулю <code>main.c</code>, и модулю <code>boo.c</code> необходима эта структура. Мы не можем убрать <code>#include "foo.h"</code> из <code>boo.h</code>, так как тогда в модуле <code>boo.c</code> не будет определена эта структура.</p>

<p>Данную проблему решают с помощью header guard-а (или include guard-а). Это простая конструкция для препроцессора.</p>

<pre><code class="language-cpp">#ifndef FOO
#define FOO

struct foo {
    int x;
};

#endif</code></pre>

<p>Напомню, что препроцессинг происходит независимо для каждого модуля, поэтому содержимое этого <code>if</code>-а будет добавлено лишь по одному разу в каждый из модулей.</p>

<p>Ещё один случай, при котором пригодится header guard: структура <code>foo</code> содержит указатель на <code>boo</code>, а структура <code>boo</code> содержит указатель на <code>foo</code>. В таком случае у нас будет два header файла, которые include друг-друга. Попробуйте проверить, что произойдет в таком случае при отсутствии header guard-а.</p>

<p>Иногда, вместо такой конструкции в самое начало файла вставляют такую строку: <code>#pragma once</code>, однако она есть не во всех компиляторах.</p><h3 id="3.2.4">3.2.4</h2><p>Пусть мы хотим написать библиотеку, которая будет состоять из нескольких файлов, а соответственно, будет компилироваться в несколько объектных файлов. Хоть мы и можем написать под них общий заголовочный файл, пользователю всё равно придется добавить множество наших объектных файлов. Эту проблему можно решить, объединив наши объектные файлы в <code>.a</code> архив с помощью программы <code>ar</code>, что часто называют статической библиотекой.</p>

<p>Пусть наша библиотека выглядит так:</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p>Скомпилируем файлы нашей библиотеки в объектные файлы, а затем создадим архив с помощью программы <code>ar</code>:</p>

<pre><code class="language-no-highlight">gcc foo.c -c
gcc boo.c -c
ar -rc libfboo.a foo.o boo.o</code></pre>

<p>Флаг <code>-r</code> означает добавить указанные файлы в архив, заместив ими файлы с теми же названиями. Флаг <code>-c</code> означает создать архив, если его нет.</p>

<p>Файл библиотеки обязан начинаться с <code>lib</code>.</p>

<p>Пусть теперь пользователь хочет воспользоваться нашей библиотекой.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Тогда для выполнения компиляции ему необходимо будет упомянуть только архив:</p>

<pre><code class="language-no-highlight">gcc main.c -L. -lfboo</code></pre>

<p><code>-L.</code> означает искать файлы статических библиотек в директории <code>.</code> (то есть, в текущей). <code>-lfboo</code> означает прикомпоновать эту библиотеку. Обратите внимание на странный формат названий: <code>libfboo.a</code> -&gt; <code>lfboo</code>.</p>

<p>IDE Visual Studio имеет свой формат для статических библиотек — <code>.lib</code>, в то время как MinGW имеет формат <code>.a</code>.</p><h3 id="3.2.5">3.2.5</h2><p>Shared object — это объектные файлы, которые прикомпоновываются к программам при их запуске. Они используются для оптимизации места на диске, так как их могут использовать различные программы, не повторяя реализации тех же функций. Часто shared objects называют динамическими библиотеками.</p>

<p>Оформим пример из предыдущего шага в виде динамической библиотеки. Скомпилируем библиотеку:</p>

<pre><code class="language-no-highlight">gcc foo.c boo.c -c
gcc -shared -o libfboo.so foo.c boo.c</code></pre>

<p>Во втором вызове <code>gcc</code> мы, с помощью флага <code>-shared</code>, создаём shared object.</p>

<p>Выполним <code>readelf libfboo.so -a</code>.</p>

<pre><code class="language-no-highlight">...
  Type:                              DYN (Shared object file)
...</code></pre>

<p>Полученный объектный файл пользователь может положить в директорию со своей программой и попросить <code>gcc</code> искать его там. Но это неправильно. Для того, чтобы библиотека была shared, она должна находиться в месте, где глобально хранятся все shared objects (в директории проекта должны быть только заголовочные файлы). Скопируем файл туда:</p>

<pre><code class="language-no-highlight">cp libfboo.so /usr/lib</code></pre>

<p>Теперь пользователь может скомпилировать свою программу:</p>

<pre><code class="language-no-highlight">gcc main.c -lfboo</code></pre>

<p>Чтобы посмотреть, какие shared objects требует исполняемый файл, введём <code>ldd a.out</code>.</p>

<pre><code class="language-no-highlight">	linux-vdso.so.1 (0x00007ffc58396000)
	libfboo.so =&gt; /lib/libfboo.so (0x00007171575e0000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x0000717157200000)
	/lib64/ld-linux-x86-64.so.2 (0x0000717157606000)</code></pre>

<p>Помимо <code>libfboo.so</code> здесь присутствует, например, <code>libc.so.6</code>.</p>

<p>Когда мы запускаем программу, загрузчик ищет shared objects:</p>

<ul>
	<li>В директориях <code>/lib*</code> и <code>/usr/lib*</code></li>
	<li>В директориях в environmental variable <code>LD_LIBRARY_PATH</code></li>
	<li>В директориях в <code>rpath</code>, который пишется в исполняемый файл в процессе компиляции с помощью флага <code>-rpath</code></li>
</ul>

<p>В ОС Windows формат динамических библиотек — <code>.dll</code>, и его использование выглядит значительно менее приятно, чем использование <code>.so</code> на Unix, так как требует использование директив компилятора. (Можете изучить пример: <a href="https://github.com/TransmissionZero/MinGW-DLL-Example" rel="noopener noreferrer nofollow">https://github.com/TransmissionZero/MinGW-DLL-Example</a>)</p><h3 id="3.2.6">3.2.6</h2><p>В современных системных языках отсутствуют заголовочные файлы. Импорт модуля в них обозначает обычно лишь добавление сигнатур функций. Есть ли реальная необходимость в заголовочных файлах?</p>
<h3 id="3.3">3.3. GNU make</h3>
<h3 id="3.3.1">3.3.1</h2><p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Продолжим работать с той же программой. Можно сделать вывод, что процесс сборки такой программы уже нетривиальный, и мы тратим много времени на ввод повторяющегося набора команд. Чтобы решить эту проблему, мы можем написать все команды в один <code>shell</code> скрипт, и запускать его.</p>

<p><code>build.sh</code></p>

<pre><code class="language-no-highlight">rm foo.o boo.o main.o a.out
gcc foo.c -c
gcc boo.c -c
gcc main.c -c
gcc foo.o boo.o main.o</code></pre>

<p>Все команды, кроме первой, можно объединить в одну, но в целях наглядности проблемы я намеренно напишу их так.</p>

<p>Обратите внимание на первую команду: удаление всех файлов, полученных в результате компиляции. Зачем это необходимо? Если мы допустим ошибку компиляции в одном из модулей, то соответствующий объектный файл не сформируется. Однако старый не будет удален, и скрипт продолжит выполняться. В результате мы получим либо ошибку компоновки, либо скомпонованную программу, один из модулей в которой устаревший.</p>

<p>Обратите внимание на такую проблему. Пусть мы изменили реализацию функции <code>foo</code> (но не её сигнатуру). Конечно, модуль <code>foo</code> следует перекомпилировать. Но нет смысла в перекомпиляции других модулей, ведь они никак не изменились.</p>

<p>Обратите внимание на строки 2-4 скрипта — их выполнение является независимым, и мы можем их выполнить одновременно. Сделать это с помощью <code>shell</code> скрипта непросто.</p>

<p>Пусть у нас программа является составной. Например, у нас есть компилятор и его стандартная библиотека. Скорее всего компилятору понадобиться стандартная библиотека, но в то же время, если мы хотим собрать стандартную библиотеку, нам не требуется собирать компилятор.</p>

<p>Итак, мы сформировали несколько проблем, которые решает программа <code>make</code>:</p>

<ol>
	<li>Выполнение этапа сборки только в том случае, если её результат устарел.</li>
	<li>Автоматическое распараллеливание этапов сборки.</li>
	<li>Разделение сборки на этапы и автоматическое рекурсивное определение необходимых этапов для сборки текущего этапа.</li>
</ol><h3 id="3.3.2">3.3.2</h2><p>В большинстве дистрибутивов программа <code>make</code> отсутствует. Поставьте её. Из-за особенности её названия, более разумным будет использовать <code>GNU make</code> как ключевую строку.</p>

<p>Начнём с простого make-файла. Для наглядности будем компилировать модули <code>foo</code> и <code>boo</code> с статическую библиотеку.</p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">lib:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o
	gcc main.c -L. -lfboo</code></pre>

<p>Здесь определены два рецепта: <code>lib</code> и <code>program</code>. Чтобы выполнить их, необходимо ввести <code>make lib</code> или <code>make program</code> соответственно. Первый рецепт собирает только библиотеку (пусть, например, пользователю может пригодиться только она), а второй и библиотеку, и саму программу.</p>

<p>Важно: в make-файлах требуется использовать символы табуляции, вместо пробелов. Добавьте соответствующую настройку в ваш text editor, если требуется (VS Code, например, сам ставит табуляции в make-файлах).</p>

<p>Содержимое рецептов — это почти обычные <code>shell</code> команды. Однако они запускаются не в одной <code>shell</code>-сессии, а в разных, что иногда важно.</p>

<p>Мы можем упростить наш make-файл: рецепт сборки программы включает в себя содержимое рецепта сборки библиотеки. Мы можем в требование одного рецепта вписать название другого рецепта.</p>

<pre><code class="language-makefile">lib:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program: lib
	gcc main.c -L. -lfboo</code></pre>

<p>В этом случае, перед выполнением рецепта <code>program</code> будет выполнен рецепт <code>lib</code>. Важно отметить, что рецепт <code>lib</code> будет выполнен в любом случае и полностью, а значит, экономии ресурсов мы пока не добились.</p>

<p>Добавим рецепт на удаление временных файлов:</p>

<pre><code class="language-makefile">...
clean:
	rm libfboo.a foo.o boo.o main.o a.out</code></pre>

<p>Его не следует добавлять в зависимости другим рецептам, так как удаление всех файлов сделает необходимой полную перекомпиляцию.</p>

<p>Обратите внимание, что <code>make</code> является ленивым языком. (Можете теперь рассказывать программистам на <code>haskell</code>-е, что тоже в некотором смысле пишете на ленивом языке.)</p><h3 id="3.3.3">3.3.3</h2><p>Заменим название рецепта <code>lib</code> на <code>libfboo.a</code>.</p>

<pre><code class="language-makefile">libfboo.a:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program: libfboo.a
	gcc main.c -L. -lfboo
...</code></pre>

<p>На самом деле, <code>lib</code> и <code>libfboo.a</code> в этом месте обозначает не просто название рецепта, а файл, который эти рецепты производят. Конечно, на прошлом шаге рецепт <code>lib</code> не производил файл <code>lib</code>, и так делать разрешено. Теперь же, когда файл в процессе выполнения рецепта производится, логика его выполнения усложняется. Рецепт выполняется только если его целевой файл отсутствует, либо один из файлов, от которых рецепт зависит, стал новее его целевого файла (это мы увидим чуть позже).</p>

<p>Выполните <code>make program</code> несколько раз. Вы увидите, что инструкции в рецепте <code>libfboo.a</code> были выполнены лишь при первой сборке, так как уже после неё файл <code>libfboo.a</code> был создан.</p>

<p>Таким образом мы впервые добились того, что перекомпиляция происходит только для обновленных модулей. Сделаем то же самое и для итогового файла <code>a.out</code>, так как он по прежнему собирается в любом случае.</p>

<pre><code class="language-makefile">libfboo.a:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Теперь, при втором вызове <code>make program</code> вы получите сообщение: <code>make: Nothing to be done for 'program'.</code>. Обратите внимание, что инструкции в рецепте <code>program</code> исполняются, ведь файла <code>program</code> нет (можете это проверить, вставив в рецепт любые инструкции). Но рецепт <code>a.out</code> не был выполнен, так как файл <code>a.out</code> моложе всех зависимостей — единственного файла <code>libfboo.a</code>.</p>

<p>Изменим файл <code>libfboo.a</code>. Здесь есть проблема: его пересборка на <code>make libfboo.a</code> будет выполнена только в том случае, если файла <code>libfboo.a</code> нет, ведь мы не написали для этого рецепта никаких зависимостей (сейчас мы это исправим). Поэтому просто удалим <code>libfboo.a</code> и сделаем <code>make libfboo.a</code>. Теперь при вызове <code>make program</code> будет выполнена перекомпиляция <code>a.out</code>.</p>

<p>Добавим зависимости для рецепта <code>libfboo.a</code>.</p>

<pre><code class="language-makefile">libfboo.a: foo.c boo.c
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o
...</code></pre>

<p>Теперь при изменения файла <code>foo.c</code> или <code>boo.c</code> будет выполнена пересборка <code>libfboo.a</code> на команду <code>make libfboo.a</code>. Но, более того, будет выполнена пересборка <code>libfboo.a</code> и на команду <code>make program</code>. Это означает, что <code>make</code> проверяет необходимость пересборки не только в текущей точке, но и по всему дереву.</p><h3 id="3.3.4">3.3.4</h2><p>Попробуем добиться распараллеливания. Мы хотим, чтобы компиляция модулей <code>foo</code>  и <code>boo</code> велась параллельно. Сделать это легко.</p>

<pre><code class="language-makefile">foo.o: foo.c
	gcc foo.c -c

boo.o: boo.c
	gcc boo.c -c

libfboo.a: foo.o boo.o
	ar -rc libfboo.a foo.o boo.o

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Сделаем новые рецепты на компиляцию каждого их этих модулей. Пусть сборка библиотеки зависит от объектных файлов этих модулей. Теперь <code>make</code> будет распараллеливать выполнение рецептов <code>foo.o</code> и <code>boo.o</code>, так как для них обоих удовлетворены условия. Чтобы выполнить сборку с помощью двух процессов, введите <code>make program -j 2</code>.</p>

<p>Для того, чтобы удостовериться, что сборка действительно идёт параллельно, напишем такой make-файл.</p>

<pre><code class="language-makefile">foo.o: foo.c
	sleep 3
	gcc foo.c -c

boo.o: boo.c
	sleep 3
	gcc boo.c -c
...</code></pre>

<p>Обе паузы при запуске <code>sleep</code> пройдут одновременно.</p>

<p>Предствавьте теперь, что у вас много модулей. Писать для каждого из них такой рецепт долго и усложняет чтение make-файла. <code>make</code> имеет способ решения этого.</p>

<pre><code class="language-makefile">%.o: %.c
	gcc $&lt; -c

libfboo.a: foo.o boo.o
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Посмотрите на первый "универсальный" рецепт. Он означает следующее: для того, чтобы собрать файл с названием <code>xxx.o</code> необходим файл <code>xxx.c</code>. Чтобы иметь доступ к необходимому файлу <code>xxx.c</code> в самом скрипте, необходимо использовать оператор <code>$&lt;</code>.</p>

<p>Посмотрите на рецепт <code>libfboo.a</code>. Вместо оператора <code>$^</code>, будут подставлены все требования, то есть, <code>foo.o boo.o</code>. Если бы мы написали оператор <code>$^</code>, то было бы подставлено только первое требование: <code>foo.o</code>.</p>

<p>Существует ещё один оператор: <code>$@</code>, вместо которого подставляется файл-цель. В примере с рецептом <code>xxx.o</code> вместо оператора <code>$@</code> будет подставлено <code>xxx.o</code>.</p><h3 id="3.3.5">3.3.5</h2><p>Мы добились поставленныъ целей с помощью <code>make</code>. Тем не менее продолжим улучшать читаемость и организацию make-скриптов.</p>

<pre><code class="language-makefile">OBJS=foo.o boo.o

%.o: %.c
	gcc $&lt; -c

libfboo.a: $(OBJS)
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Мы можем вынести список целевых объектных файлов в отдельную переменную, и писать её, вместо файлов. (Важно: это не environmental variables, хоть и их синтаксис похож. Они не будут проталкиваться в программы, которые вы запускаете.)</p>

<p>Пойдем дальше. Если мы перенесем файлы <code>foo.c</code> и <code>boo.c</code> в отдельную директорию, то мы можем определять целевые файлы автоматически по контенту этой директории. Тогда, когда мы добавим в директорию (и, соответственно, в библиотеку) новый файл, нам не придется изменять make-файл. Перенесем <code>foo.c</code> и <code>boo.c</code> в директорию <code>lib</code>.</p>

<p>Для определения списка файлов мы можем написать что-то вроде <code>SRCS=$(shell ls lib)</code>. (Оператор <code>shell</code> запускает программу и возвращает её вывод. Присутствует не во всех программах <code>make</code>.) Вместо этого воспользуемся оператором <code>wildcard</code>.</p>

<pre><code class="language-makefile">SRCS=$(wildcard lib/*.c)</code></pre>

<p>Смысл этого оператора очевиден. В результате его выполнения, переменная <code>SRCS</code> будет равна <code>lib/foo.c lib/boo.c</code>. Для удобства вывода значений переменных можно воспользоваться оператором <code>info</code>.</p>

<pre><code class="language-makefile">$(info $(SRCS))</code></pre>

<p>Однако, нам необходимы не исходные <code>.c</code> файлы, а объектные файлы. Можно снова пошаминить со строками, а можно воспользоваться оператором <code>patsubst</code>.</p>

<pre><code class="language-makefile">OBJS=$(patsubst lib/%.c, %.o, $(SRCS))</code></pre>

<p>Смысл этого оператора тоже почти очевиден. Вы пробегаемся по каждому слову в третьем аргументе <code>$(SRCS)</code>, и преобразовываем каждое слово из формата <code>lib/xxx.c</code> в  <code>xxx.o</code>.</p>

<p>Обратите внимание, что в результате такого вызова <code>OBJS=$(patsubst %.c, %.o, $(SRCS))</code> значение <code>OBJS</code> будет <code>lib/boo.o  lib/foo.o</code>, что немного не то, что мы хотим.</p>

<p>Обратите внимание на то, что переменная <code>SRCS</code>, кроме формирования переменной <code>OBJS</code>, больше ни на что не влияет, и в рецепте <code>%.o</code> в требованиях теперь находятся несуществующие файлы (например, <code>foo.o</code> требует <code>foo.c</code>, когда его настоящее имя теперь <code>lib/foo.c</code>). Заменим требование на <code>lib/%.c</code>.</p>

<p>Наш итоговый make-файл на текущий момент:</p>

<pre><code class="language-makefile">SRCS=$(wildcard lib/*.c)
OBJS=$(patsubst lib/%.c, %.o, $(SRCS))

%.o: lib/%.c
	gcc $&lt; -c

libfboo.a: $(OBJS)
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre><h3 id="3.3.6">3.3.6</h2><p>На предыдущем шаге мы начали изменять организацию нашего проекта в лучшую сторону, когда переместили файлы библиотеки <code>lfboo</code> в отдельную директорию. Выполним теперь правильную организацию проекта полностью. К сожалению, в языке C нет стандарта организации проекта. Я покажу один из способов. Для большей наглядности в некоторых местах я добавлю больше файлов и модулей.</p>

<p>Начнем с основной программы. Её <code>.c</code> файлы будут лежать в директории <code>src</code>, а <code>.h</code> файлы будут лежать в директории <code>include</code>. Мы добавим туда ещё один модуль <code>goo</code>.</p>

<p><code>src/goo.c</code></p>

<pre><code class="language-cpp">int goo(int x) {
    return x + 4;
}</code></pre>

<p><code>include/goo.h</code></p>

<pre><code class="language-cpp">int goo(int x);</code></pre>

<p><code>src/main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;fboo/fboo.h&gt;
#include &lt;doo/doo.h&gt;
#include &lt;goo.h&gt;

int main() {
    printf("%d\n", foo(2) + boo(2) + doo(2) + goo(2));
    return 0;
}</code></pre>

<p>Создадим директорию <code>build</code>, в которую будем складировать объектные файлы и финальный исполняемый файл. В результате компиляции файла <code>xxx/src/yyy.c</code> будет получаться файл <code>build/xxx/yyy.o</code>. (Например, <code>src/main.c</code> -&gt; <code>build/main.o</code>, <code>lib/fboo/src/foo.c</code> -&gt; <code>build/fboo/foo.o</code>.)</p>

<p>Библиотеки мы будем хранить в директории <code>lib</code>. В директории каждой библиотеки также будут директории <code>src</code> и <code>include</code>. Кроме того, библиотеки будут иметь публичный заголовочный файл (в данном случае <code>lib/fboo/fboo.h</code>) в корне директории библиотеки, на который мы и будем ссылаться из основной программы.</p>

<p><code>lib/fboo/src/foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>lib/fboo/src/boo.c</code></p>

<pre><code class="language-cpp">#include &lt;box.h&gt;

int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>lib/fboo/include/box.h</code></p>

<pre><code class="language-cpp">struct box {
    int x;
};</code></pre>

<p><code>lib/fboo/fboo.h</code></p>

<pre><code class="language-cpp">int foo(int x);
int boo(int x);</code></pre>

<p>Для удобства в директории каждой библиотеки будет свой <code>Makefile</code>.</p>

<p><code>lib/fboo/Makefile</code></p>

<pre><code class="language-makefile">SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/fboo/%.o, $(SRCS))
CFLAGS+=-Iinclude

$(BUILD_DIR)/fboo/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/fboo/libfboo.a: $(OBJS)
	ar -rc $@ $^

prepare:
	mkdir -p $(BUILD_DIR)/fboo

clean:
	rm -rf $(BUILD_DIR)/fboo</code></pre>

<p>Здесь переменная <code>$(BUILD_DIR)</code> равна абсолютному пути директории <code>build</code>, и будет нам передана "верхним" make-файлом. Для того, чтобы уже сейчас проверить этот файл, мы можем добавить <code>BUILD_DIR=../../build</code> и вызвать <code>make</code> из директории <code>lib/fboo</code>. В данном случае, если мы вызовем <code>make</code> без названия рецепта, будут выполнены все рецепты. (В общем случае это не так: там упоротые правила, которые я не знаю.) Флаг <code>-Iinclude</code> нам необходим, чтобы файлы в директории <code>lib/fboo/include</code> были видимы. С помощью рецепта <code>prepare</code> мы создаём директорию <code>build/fboo</code>, так как <code>gcc</code> не создает её самостоятельно.</p>

<p>Организуем таким же образом библиотеку <code>doo</code>.</p>

<p><code>lib/doo/src/doo.c</code></p>

<pre><code class="language-cpp">int doo(int x) {
    return x + 3;
}</code></pre>

<p><code>lib/doo/doo.h</code></p>

<pre><code class="language-cpp">int doo(int x);</code></pre>

<p><code>lib/doo/Makefile</code></p>

<pre><code class="language-makefile">SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/doo/%.o, $(SRCS))
CFLAGS+=-Iinclude

$(BUILD_DIR)/doo/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/doo/libdoo.a: $(OBJS)
	ar -rc $@ $^

prepare:
	mkdir -p $(BUILD_DIR)/doo

clean:
	rm -rf $(BUILD_DIR)/doo</code></pre>

<p>Здесь также можно абстрагировать название модуля <code>doo</code>.</p>

<p>Напишем, наконец, главный <code>Makefile</code></p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">BUILD_DIR=$(abspath build)
SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/%.o, $(SRCS))
LIBS=$(BUILD_DIR)/fboo/libfboo.a $(BUILD_DIR)/doo/libdoo.a
CFLAGS+=-Iinclude -Ilib

$(BUILD_DIR)/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/fboo/libfboo.a:
	$(MAKE) -C lib/fboo BUILD_DIR=$(BUILD_DIR)

$(BUILD_DIR)/doo/libdoo.a:
	$(MAKE) -C lib/doo BUILD_DIR=$(BUILD_DIR)

$(BUILD_DIR)/program: $(OBJS) $(LIBS)
	gcc $(OBJS) $(LIBS) -o $@

program: $(BUILD_DIR)/program

prepare:
	mkdir -p $(BUILD_DIR)

clean:
	rm -rf $(BUILD_DIR)</code></pre>

<p>Для начала, мы создаём переменную <code>BUILD_DIR</code>, в которую записываем абсолютный путь директории <code>build</code>, который мы добываем с помощью функции <code>abspath</code>. К флагам мы добавляем флаг <code>-Ilib</code>, чтобы мы могли добавлять файлы из библиотек. С помощью <code>$(MAKE) -C dir</code> мы рекурсивно вызываем <code>make</code> в директории <code>dir</code>. Для того, чтобы получить исполняемый файл <code>build/program</code> необходимо ввести <code>make program</code> (либо <code>make dir</code>, где <code>dir</code> это абсолютный путь до исполняемого файла, но так менее удобно).</p>

<p>В этом make-файле есть недостатки. Например, названия библиотек недостаточно абстрагированы. Я намеренно не стал этим усложнять пример.</p><h3 id="3.3.7">3.3.7</h2><p>Попробуйте найти недостатки в организации проекта, который показан на предыдущем шаге, и исправить их.</p><h3 id="3.3.8">3.3.8</h2><p>До сих пор мы рассматривали только зависимости от <code>.c</code> файлов. Пусть теперь мы изменили <code>.h</code> файл. В тако случае, необходима перекомпиляция всех модулей, которые его добавляют. К сожалению, нет адекватных общих способов определить это множество модулей. Исследуйте способы, как эта проблема может быть решена.</p><h3 id="3.3.9">3.3.9</h2><h3>Проект: Программа со структурой</h3>

<p>Напишите любую программу (полная свобода мысли) вместе с несколькими её библиотеками и систему сборки для неё. Используйте контент шестого шага в качестве образца.</p>
      </main>
    </div>
  </div>
</body>

</html>
