<!DOCTYPE html>

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">    
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <title>C - Язык Программирования</title>
  <style>      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }
      table ul {
        list-style-type: none;
        padding: 0em;
      }
      table li {
        padding-bottom: 1em;
        line-height:1.2em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.5em;
      }
      th[scope=row] {
          text-align: left;
          font-weight: normal;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      a:hover,a:focus {
        background: #fff2a8;
      }
      dt {
        font-weight: bold;
      }
      .sgr-1m {
        font-weight: bold;
      }
      .sgr-2m {
        color: #575757;
      }
      .sgr-31_1m {
        color: #b40000;
      }
      .sgr-32_1m {
        color: green;
      }
      .sgr-36_1m {
        color: #005C7A;
      }
      .file {
        font-weight: bold;
        border: unset;
      }
      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      samp {
        background: #fafafa;
      }
      pre > samp {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      kbd {
        font-weight: normal;
      }
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      figure {
        margin: auto 0;
      }
      figure pre {
        margin-top: 0;
      }

      figcaption {
        padding-left: 0.5em;
        font-size: small;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }
      figcaption.zig-cap {
        background: #fcdba5;
      }
      figcaption.c-cap {
        background: #a8b9cc;
        color: #000;
      }
      figcaption.peg-cap {
        background: #fcdba5;
      }
      figcaption.javascript-cap {
        background: #365d95;
        color: #fff;
      }
      figcaption.shell-cap {
        background: #ccc;
        color: #000;
      }

      aside {
        border-left: 0.25em solid #f7a41d;
        padding: 0 1em 0 1em;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      th pre code {
          background: none;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#121212;
            color: #ccc;
        }
        a {
            color: #88f;
        }
        a:hover,a:focus {
            color: #000;
        }
        table, th, td {
            border-color: grey;
        }
        .sgr-2m {
            color: grey;
        }
        .sgr-31_1m {
            color: red;
        }
        .sgr-32_1m {
            color: #00B800;
        }
        .sgr-36_1m {
            color: #0086b3;
        }
        code {
          background: #222;
          border-color: #444;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        samp {
          background: #000;
          color: #ccc;
        }
        pre > samp {
          border: unset;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        figcaption.zig-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.peg-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.shell-cap {
          background: #2a2a2a;
          color: #fff;
        }
      }
</style>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>

<body>
  <header><h1>C - Язык Программирования</h1></header>
  
  <div id="main-wrapper">
    <div id="navigation">        
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Содержание</h2>
        <ul>          
          <li><a href="#1">1. Вид сверху на C</a>
            <ul>
              <li><a href="#1.1">1.1. Введение</a>
                <ul>
                  <li><a href="#1.1.1">1.1.1</a></li>
                  <li><a href="#1.1.2">1.1.2</a></li>
                  <li><a href="#1.1.3">1.1.3</a></li>
                  <li><a href="#1.1.4">1.1.4</a></li>
                  <li><a href="#1.1.5">1.1.5</a></li>
                  <li><a href="#1.1.6">1.1.6</a></li>
                  <li><a href="#1.1.7">1.1.7</a></li>
                  <li><a href="#1.1.8">1.1.8</a></li>
                </ul>
              </li>
              <li><a href="#1.2">1.2. Контроль потока</a>
                <ul>
                  <li><a href="#1.2.1">1.2.1</a></li>
                  <li><a href="#1.2.2">1.2.2</a></li>
                  <li><a href="#1.2.3">1.2.3</a></li>
                  <li><a href="#1.2.4">1.2.4</a></li>
                  <li><a href="#1.2.5">1.2.5</a></li>
                  <li><a href="#1.2.6">1.2.6</a></li>
                  <li><a href="#1.2.7">1.2.7</a></li>
                  <li><a href="#1.2.8">1.2.8</a></li>
                  <li><a href="#1.2.9">1.2.9</a></li>
                  <li><a href="#1.2.10">1.2.10</a></li>
                </ul>
              </li>
              <li><a href="#1.3">1.3. Функции</a>
                <ul>
                  <li><a href="#1.3.1">1.3.1</a></li>
                  <li><a href="#1.3.2">1.3.2</a></li>
                  <li><a href="#1.3.3">1.3.3</a></li>
                  <li><a href="#1.3.4">1.3.4</a></li>
                  <li><a href="#1.3.5">1.3.5</a></li>
                  <li><a href="#1.3.6">1.3.6</a></li>
                  <li><a href="#1.3.7">1.3.7</a></li>
                </ul>
              </li>
              <li><a href="#1.4">1.4. Указатели</a>
                <ul>
                  <li><a href="#1.4.1">1.4.1</a></li>
                  <li><a href="#1.4.2">1.4.2</a></li>
                  <li><a href="#1.4.3">1.4.3</a></li>
                  <li><a href="#1.4.4">1.4.4</a></li>
                  <li><a href="#1.4.5">1.4.5</a></li>
                  <li><a href="#1.4.6">1.4.6</a></li>
                  <li><a href="#1.4.7">1.4.7</a></li>
                  <li><a href="#1.4.8">1.4.8</a></li>
                  <li><a href="#1.4.9">1.4.9</a></li>
                  <li><a href="#1.4.10">1.4.10</a></li>
                  <li><a href="#1.4.11">1.4.11</a></li>
                </ul>
              </li>
              <li><a href="#1.5">1.5. Строки</a>
                <ul>
                  <li><a href="#1.5.1">1.5.1</a></li>
                  <li><a href="#1.5.2">1.5.2</a></li>
                  <li><a href="#1.5.3">1.5.3</a></li>
                  <li><a href="#1.5.4">1.5.4</a></li>
                  <li><a href="#1.5.5">1.5.5</a></li>
                  <li><a href="#1.5.6">1.5.6</a></li>
                  <li><a href="#1.5.7">1.5.7</a></li>
                  <li><a href="#1.5.8">1.5.8</a></li>
                </ul>
              </li>
              <li><a href="#1.6">1.6. Структуры</a>
                <ul>
                  <li><a href="#1.6.1">1.6.1</a></li>
                  <li><a href="#1.6.2">1.6.2</a></li>
                  <li><a href="#1.6.3">1.6.3</a></li>
                  <li><a href="#1.6.4">1.6.4</a></li>
                  <li><a href="#1.6.5">1.6.5</a></li>
                  <li><a href="#1.6.6">1.6.6</a></li>
                  <li><a href="#1.6.7">1.6.7</a></li>
                  <li><a href="#1.6.8">1.6.8</a></li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </div>

    <div id="contents-wrapper">
      <main id="contents">

<h2 id="1">1. Вид сверху на C</h2>

<h3 id="1.1">1.1. Введение</h3>

<h3 id="1.1.1">1.1.1</h2>
<p>Рассмотрим простейшую однофайловую программу на C:</p>

<pre><code class="language-cpp">int main() {
    return 0;
}</code></pre>

<p>Здесь определена функция под названием <code>main</code>. <code>int main()</code> — это сигнатура функции. По ней мы видим, что функция не принимает аргументов, так как круглые скобки ничего не содержат, и возвращает тип <code>int</code> — целое число. В фигурных скобках содержится тело функции, которое содержит лишь один <em>statement </em> <code>return 0</code>, который завершает выполнение функции, возвращая значение <code>0</code>. Пока можно сильно не задумываться обо всем вышенаписанном, мы вернемся к функциям с большими подробностями позже.</p><h3 id="1.1.2">1.1.2</h2>
<p>Сложно анализировать выполнение программы не имея возможности ввода и вывода. Научимся выводить. Первой функцией для вывода будет <code>int puts(const char *str)</code>. Давайте изучим её сигнатуру.</p>

<p>Во первых, функция принимает один аргумент типа <code>const char *str</code>. Пока не будем расшифровывать этот сложный тип, и поверим, что это строка, известная на этапе компиляции (то есть, мы не сможем её сформировать интерактивно). Очевидно эта строка будет напечатана. Позже мы узнаем, что такое потоки <em>streams</em>, пока будем считать, что вывод идет в консоль.</p>

<p>Во вторых, функция возвращает тип <code>int</code>, и, если мы посмотрим в документацию <em>cppreference</em>, мы увидим, что то, что она возвращает, описано с большой свободой.</p>

<blockquote>
<p>On success, returns a non-negative value.</p>

<p>On failure, returns <a href="https://en.cppreference.com/w/c/io" rel="noopener noreferrer nofollow" title="c/io">EOF</a> and sets the <em>error</em> indicator (see <a href="https://en.cppreference.com/w/c/io/ferror" rel="noopener noreferrer nofollow" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p>
</blockquote>

<p>В свою очередь: </p>

<blockquote>
<table>
	<tbody>
		<tr>
			<td>
			<p>EOF</p>
			</td>
			<td>integer constant expression of type int and negative value</td>
		</tr>
	</tbody>
</table>
</blockquote>

<p>Такую картину мы будем видеть во многих функциях. Можно посмотреть и <code>ferror()</code>, но нам это пока неинтересно.</p>

<p>Давайте, наконец, напечатаем что-либо.</p>

<pre><code class="language-cpp">int main() {
    puts("Hello");
    puts("Test");
    return 0;
}</code></pre>

<p>Обратите внимание: в этой программе я не написал <code>#include &lt;stdio.h&gt;</code>, несмотря на то, что так обычно делают. Дело в том, что мы пока не понимаем, что такое <code>#include</code>, но он и не нужен. Вы получите предупреждение о том, что <code>puts</code>не был объявлен, но исполняемый файл вы все равно получите.</p>

<p>При запуске этой программы будет выполнена функция <code>main</code>, в которой будет вызвана функция <code>puts("Hello")</code>, в результате чего будет выполнена печать строки <em>Hello</em> и перевод строки, а затем будет вызвана функция <code>puts("Test")</code>, в результате чего будет выполнена печать строки <em>Test</em> и перевод строки.</p><h3 id="1.1.3">1.1.3</h2>
<p>Научимся работать с локальными переменными, а заодно и выводить числа. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a;
    int b = 2 + 3;
    b = a + 8;
    printf("%d %s %d\n", a, "Hello", b + 7);
    return 0;
}</code></pre>

<p>В первой строке тела функции <code>main</code>мы объявляем <em>declare</em> переменную типа <code>int</code> с именем <code>a</code>. Мы не присваиваем <em>define</em> её. Её значение на этом моменте будет неопределенно. Какое значение получит переменная <code>a</code> мы узнаем позже.</p>

<p>Во второй строке мы объявляем <em>declare</em> и сразу определяем <em>define</em> переменную типа <code>int</code> с именем <code>b</code>. Мы присваиваем ей значение <code>5</code>.</p>

<p>В третьей строке мы переопределяем значение переменной <code>b</code>. Так как в вычислении её значения используется неопределенная переменная <code>a</code>, теперь значение переменной <code>b</code> тоже не определено.</p>

<p>В четвертой строке вы используем новую, намного более сложную функцию — <code>printf</code>. Это функция с неопределенным количеством аргументов (vararg функция, эллипсис). Первый её аргумент — это строка, задающая формат. Он имеет достаточно богатые возможности, и мы будем ими пользоваться по мере необходимости. Пока остановимся на том, что подстроки <code>%d</code> будут заменены на число в следующем по счету аргументе, подстроки <code>%s</code> будут заменены на строку в следующем по счету аргументе (первый <code>%d</code> заменится на аргумент <code>a</code>, <code>%s</code> заменится на аргумент <code>"Hello"</code>, второй <code>%d</code> заменится на аргумент <code>b + 7</code>), а <code>\n</code> обозначает символ перехода строки line feed (другие подобные символы мы увидим позже).</p>

<p>Определить вывод этой программы наперед не получится, так как значения переменных зависят от компилятора. В будущем мы часто будем с этим сталкиваться.</p><h3 id="1.1.4">1.1.4</h2>
<p>Рассмотрим базовые типы данных, которые нам в ближайшее время могут пригодиться.</p>

<ul>
	<li><code>int</code> — целые числа, на хранение котах выделяется <code>4</code> байта</li>
	<li><code>short</code> — целые числа, на хранение которых выделяется <code>2</code> байта</li>
	<li><code>char</code> — целые числа, на хранение которых выделяется <code>1</code> байт</li>
	<li><code>long long</code> — целые числа, на хранение которых выделяется <code>8</code> байт</li>
	<li><code>long</code> — целые числа, на хранение которых выделяется ?? байт</li>
</ul>

<p>Помимо этих типов, на понадобится <code>const char*</code>.</p>

<p>Интересная ситуация с логическим типом <code>_Bool</code> — он был введен не сразу, и в многих программах вводили тип с названием <code>bool</code> самостоятельно с помощью препроцессора, поэтому и было выбрано такое странное название. Логический тип имеет лишь два значения: <code>true</code> и <code>false</code>. (На самом деле, размер этого типа <code>1</code> байт, и <code>false</code> соответствует числу <code>0</code>, в то время как <code>true</code> всем остальным.)</p>

<p>Размер типа <code>long</code> в свою очередь зависит от системы. На <em>Windows</em> он равен 4, а на <em>Linux</em> он равен 8. В целом, встроенные типы на описывают нормально свою размерность, как в языках <em>Rust</em> и <em>Zig</em>, и это бывает проблемой.</p>

<p>Про указатели мы поговорим позже.</p>

<p>С помощью оператора <code>sizeof(x)</code> можно узнать размер типа в байтах, причем в качестве аргумента можно использовать как тип, так и переменную или значение.</p>

<pre><code class="language-cpp">int main() {
    printf("int: %d\n", sizeof(int));
    printf("short: %d\n", sizeof(short));
    printf("char: %d\n", sizeof(char));
    printf("long long: %d\n", sizeof(long long));
    printf("long: %d\n", sizeof(long));
    printf("const char*: %d\n", sizeof(const char*));
    
    const char *str = "Hello";
    printf("const char*: %d\n", sizeof(str));
    return 0;
}</code></pre><h3 id="1.1.5">1.1.5</h2>
<p>Изучим несколько базовых операторов.</p>

<ol>
	<li><code>+</code> — оператор сложения, складывает два числа. <code>2 + 3</code> равно <code>5</code>.</li>
	<li><code><span style="color: #000000;">-</span></code> — оператор вычитания, вычитает второе число из первого. <code>5 - 3</code> равно <code><span style="color: #000000;">2</span></code>.</li>
	<li><code><span style="color: #000000;">*</span></code> — оператор умножения, умножает два числа. <code>2 * 3</code> равно <code><span style="color: #000000;">6</span></code>.</li>
	<li><code><span style="color: #000000;">/</span></code> — оператор деления, делит второе число на первое с округлением вниз. <code><span style="color: #000000;">5 / 2</span></code> равно <code><span style="color: #000000;">2</span></code>. <code><span style="color: #000000;">6 / 2</span></code> равно <code><span style="color: #000000;">3</span></code>.</li>
	<li><code>%</code> — оператор остатка от деления, делит второе число на первое и даёт остаток от деления. <code><span style="color: #000000;">5 % 2</span></code> равно <code>1</code>. <code><span style="color: #000000;">6 % 2</span></code> равно <code>0</code>.</li>
</ol>

<p>Если второй аргумент у операторов <code>/</code> и <code>%</code> будет равен <code>0</code>, то программа завершится с ошибкой. Какие при этом механизмы происходят, мы узнаем позже.</p>

<p>Также у этих операторов есть странная особенность: на самом деле они округляют не вниз, а к нулю, что может быть неприятным сюрпризом, если в ваших промежуточных вычислениях будут получаться отрицательные числа. Например <code>-5 / 2</code> равно <code>-1</code> и <code>-5 % 3</code> равно <code>-2</code>.</p>

<p>Имейте ввиду, что числа в C ограничены, и при их переполнении вы не получите никаких предупреждений или ошибок. (Когда такое происходит, процессор ставит флаг переполнения, но компилятор C для скорости даже не смотрит на него.) Например, <code>2000000000 + 2000000000</code> равно <code>-294967296</code>.</p>

<p>Помимо арифметических операторов существуют логические операторы для создания сложных условий.</p>

<ol>
	<li><code>&amp;&amp;</code> или <code>and</code> — оператор И, который возвращает <code>1</code>, если оба аргумента не равны нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>||</code> или <code>or</code> — оператор ИЛИ, который возвращает <code>1</code>, если хотя бы один аргумент не равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>!</code> — унарный оператор НЕ, который возвращает <code>1</code>, если аргумент равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>==</code> — оператор равенства, который возвращает <code>1</code>, если аргументы равны, и возвращает <code>0</code> в противном случае.</li>
</ol>

<pre><code class="language-cpp">int main() {
    printf("%d ", 3 + 4);
    printf("%d ", 17 % 7);
    printf("%d ", 3 &amp;&amp; 0);
    printf("%d ", 3 || 0);
    printf("%d ", !4);
    printf("%d ", 5 == 5);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>7 3 0 1 0 1 </code></p><h3 id="1.1.6">1.1.6</h2>
<p>Напишите программу, которая выведет следующий текст:</p>

<pre><code>123
abracadabra
2 + 5 = 7
ababba</code></pre><h3 id="1.1.7">1.1.7</h2>
<p>Напомним, что в C не сразу был введен логический тип данных <code>_Bool</code>. Однако при этом также есть возможность получить "тип" <code>bool</code>, добавив файл <code>#include &lt;stdbool.h&gt;</code>. (На самом деле, это не совсем тип.)</p>

<p>Как думаете, зачем этот файл был добавлен?</p><h3 id="1.1.8">1.1.8</h2>
<p>Пока эту задачу можно пропустить, и вернуться к ней намного позднее.</p>

<p>Я немного наврал, когда сказал, что размер типа <code>int</code> — 4 байта. Это не так при компиляции в разрядности ниже, чем 32. Однако современные компиляторы не имеют возможности компилировать в такие разрядности, поэтому это не является проблемой. Можно попробовать найти древний компилятор (например, Open Watcom), который может компилировать в разрядность 16, и проверить <code>sizeof(int)</code> в таком режиме.</p>
<h3 id="1.2">1.2. Контроль потока</h3>

<h3 id="1.2.1">1.2.1</h2>
<p>Начнём с введения нескольких терминов. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a = 5 + 8;
    puts("123");
    int b = puts("456");
    return 0;
}</code></pre>

<p>Тело функции <code>main</code> состоит из четырех действий: объявление переменной <code>a</code>, вызов функции <code>puts("123")</code>, объявление переменной <code>b</code>, возвращение значения <code>0</code>. Каждое из этих действий называется <em>statement</em>.</p>

<p>Посмотрим на первый statement: <code>int a = 5 + 8</code>. Часть <code>5 + 8</code> называется <em>expression</em>. Часть этого expression-а <code>5</code> тоже является expression-ом. На третьем statement-е вызов функции <code>puts("456")</code> также является expression-ом (в то время, как другой вызов этой же функции был statement-ом).</p>

<p>Есть проблема в терминологии: оба этих слова не имеют перевода на русский язык, и обычно их обоих называют просто <em>выражение</em>. Позже, когда мы будем более подробно изучать синтаксис, мы увидим смысл такого разделения.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>statement</td>
			<td>expression</td>
		</tr>
		<tr>
			<td>Исполняются сверху вниз</td>
			<td>Порядок исполнения не определен</td>
		</tr>
		<tr>
			<td>Не имеют конечного значения</td>
			<td>Имеют конечное значение (а потому и тип)</td>
		</tr>
		<tr>
			<td>Имеют side effect</td>
			<td>По хорошему, не должны иметь side effect</td>
		</tr>
	</tbody>
</table>

<p><em>Side effect</em> означает, что исполнение фрагмента кода приведет к изменению чего либо за его пределами (изменятся внешние переменные; что-то запишется в память, доступную из внешних переменных; выполнится системный вызов и т.д.).</p><h3 id="1.2.2">1.2.2</h2>
<p>Control Flow (контроль потока) — это набор statement-ов в языке, которые определяют последовательность выполнения statement-ов.</p>

<p>Пока мы видели следующие типы statement-ов:</p>

<ul>
	<li>Declaration (объявление): <code>int a</code>. Объявление также может быть с определением/присваиванием (по сути, это то же самое, но термин определение в других языках может налагать ограничения):<span style="color: #000000;"> <code>int a = 5</code></span>.</li>
	<li>Assignment/Definition (присваивание/определение): <code>a = 5 + 2</code>.</li>
	<li>Function Call (вызов функции): <code>puts("123")</code>.</li>
	<li>Function Return (возврат из функции): <code>return 2 + puts("456")</code>.</li>
</ul>

<p>Конечно, хочется иметь вариативность в порядке исполнения statement-ов. Делать это можно с помощью ветвлений и циклов, которые являются control flow statements.</p>

<p>Посмотрим на <code>if</code>:</p>

<pre><code class="language-cpp">int main() {
    int a = 4;
    if (a - 4) {
        puts("1");
    }
    else if (a) puts("2");
    else {
        puts("3");
    }
    return 0;
}</code></pre>

<p>Данный <code>if</code> statement состоит из трех ветвей. Эти ветви надо читать так:</p>

<ol>
	<li>Если <code>a - 4</code> не <code>0</code>, то выполнить <code>puts("1")</code> и завершить выполнение <code>if</code></li>
	<li>Если <code>a</code> не <code>0</code>, то выполнить <code>puts("2")</code> и завершить выполнение <code>if</code></li>
	<li>Выполнить <code>puts("3")</code></li>
</ol>

<p>Обратите внимание на следующие вещи:</p>

<ul>
	<li>Можно как обрамлять блок в <code>if</code> в фигурные скобки, так и не делать этого.</li>
	<li>В качестве условия в <code>if</code> должен быть expression, а его тип неважен. Проверка идет лишь на то, что он не <code>0</code>. А в языке C по сути любой тип данных — число.</li>
	<li>Веток <code>else if</code> и <code>else</code> может не быть. Количество веток <code>else if</code> не ограниченно.</li>
</ul>

<p>В результате выполнения этой программы будет напечатано единственное число <code>2</code>.</p><h3 id="1.2.3">1.2.3</h2>
<p>Вскоре нам потребуется начать решать input/output задачи для проверки знаний. Для этого нужно разобраться, как считывать данные. Для этого используется функция <code>scanf</code>. Посмотрим решение задачи A + B.</p>

<p>Напишите программу, которая считывает два целых числа <span class="math-tex">\(a\)</span> и <span class="math-tex">\(b\)</span> (<span class="math-tex">\(-100 \le a, b \le 100\)</span>), и выводит их сумму.</p>

<pre><code class="language-cpp">int main() {
    int a, b;
    scanf("%d%d", &amp;a, &amp;b);
    printf("%d\n", a + b);
    return 0;
}</code></pre>

<p>Функция <code>scanf</code> имеет первым аргументом формат, по которому сопоставляются данные во входном потоке, а следующими аргументами <em>адреса</em>, по которым необходимо эти данные положить. <code>scanf</code> сам считает произвольное количество пробельных символов (пробел, табуляция, следующая строка, возврат каретки и т.д.) между идущими в формате подряд <code>%d</code>. (Принцип, по которому он это делает, мне не очень понятен, но это и не нужно.)</p>

<p>Пока мы не знаем, что такое адреса, но позже мы подробно их изучим. C не имеет возможности передать в функцию локальную переменную так, чтобы функция изменила её. Вместо этого мы передаем адрес локальной переменной, который мы берем оператором <code>&amp;</code> (амперсанд). Интересно, что функция, получая информацию о местоположении локальной переменной, может работать не только с этой переменной, но и с тем что находится рядом с ней. (Она не получает этим <em>права</em> — права у неё от передачи аргументов не меняются. Она получает информацию, где искать данные.) Но об этом мы поговорим подробно потом.</p>

<p>Нетрудно догадаться, как считывать строки, но там есть неочевидные моменты. Мы поговорим о строках отдельно. Пример некорректной программы, которая может, как выполниться успешно, так и завершиться с ошибкой. Ничего страшного, если вы пока не знаете, что такое массивы, и, соответственно, не понимаете программу.</p>

<pre><code class="language-cpp">int main() {
    char str[10];
    scanf("%s", str);
    return 0;
}</code></pre>

<p>А эта программа гарантированно завершится с ошибкой, так как попытается считать данные в константу. Как функционирует такое ограничение, мы также позже узнаем.</p>

<pre><code class="language-cpp">int main() {
    const char *str = "Hello";
    scanf("%s", str);
    return 0;
}</code></pre><h3 id="1.2.4">1.2.4</h2>
<p>Улитка ползет по столбу высотой <span class="math-tex">\(h\)</span> единиц и хочет забраться на самый его верх. Днем улитка поднимается на <span class="math-tex">\(a\)</span> единиц, а ночью соскальзывает вниз на <span class="math-tex">\(b\)</span> единиц. На какой день улитка заберется на столб?</p>

<h4>Формат ввода</h4>

<p>Единственная строка входных данных содержит три целых числа: <span class="math-tex">\(a\)</span>, <span class="math-tex">\(b\)</span> и <span class="math-tex">\(h\)</span> (<span class="math-tex">\(1 \le b &lt; a \le h \le 10^9\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — номер дня, на который улитка достигнет верха столба.</p><h3 id="1.2.5">1.2.5</h2>
<p>В C присутствуют циклы <code>while</code>, <code>do while</code> и <code>for</code>. Выходить их циклов можно с помощью операторов <code>break</code> и <code>continue</code>. К сожалению, нет возможности выйти из нескольких циклов, кроме как с помощью оператора перехода к метке <code>goto</code>.</p>

<p>Цикл <code>while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    while (i &lt; 10) {
        printf("%d", i);
        i++;
    }
    return 0;
}</code></pre>

<p>Читать это надо так. Если<code>i &lt; 10</code>, выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу, а затем прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    do {
        printf("%d", i);
        i++;
    } while (i &lt; 10);
    return 0;
}</code></pre>

<p>Читать это надо так. Выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу. Затем, если<code>i &lt; 10</code>, прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> отличается от цикла <code>while</code> тем, что он в любом случае сделает хотя бы одну итерацию.</p><h3 id="1.2.6">1.2.6</h2>
<p> Цикл <code>for</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i;
    for (i = 0; i &lt; 10; i++) {
        printf("%d", i);
    }
    i = 0;
    for (; i &lt; 10; printf("%d", i) &amp;&amp; i++);
    return 0;
}</code></pre>

<p>Читать первый цикл <code>for</code> надо так. Сначала выполнить <code>i = 0</code>. Затем выполнить тело цикла, в котором необходимо вывести значение <code>i</code>, а затем выполнить <code>i++</code>. Затем, если <code>i &lt; 10</code>, прыгнуть в начало цикл (не выполняя <code>i = 0</code>). В противном случае, прервать выполнение цикла.</p>

<p>Данный цикл на первый взгляд может выглядеть странным и запутанным, но на самом деле он удобен.</p>

<p>Часто вы будете видеть, что в первом "блоке" цикла <code>for </code>(там, где у нас написано <code>i = 0</code>) выполняют объявление переменной (например <code>int i = 0</code>). Однако, это работает не со всеми стандартами языка C. В некоторых стандартах это может считаться ошибкой.</p>

<p>Посмотрим на второй цикл <code>for</code>. Мы видим, что некоторые блоки могут быть пустыми. Все блоки должны являться expressions. Причина этого ясна для второго блока, ведь он проверяет условие, а значит его содержимое должно иметь значение. Но неужели <code>i = 0</code> и <code>i++</code> это тоже expressions, которые имеют какое-то значение? Да. <code>i = 0</code> возвращает значение своего правого аргумента, а <code>i++</code> возвращает значение <code>i</code> до увеличения. (Чуть позже мы изучим все эти операторы подробнее, но вы уже можете почитать про них.)</p>

<p>Оператор <code>&amp;&amp;</code> — это оператор И. Он выполняет левый аргумент, и, если он не <code>0</code>, выполняет правый аргумент и возвращает его, а иначе, возвращает <code>0</code>. Попробуйте теперь самостоятельно понять логику работы второго цикла.</p>

<p>Вывод этой программы: <code>01234567890123456789</code></p><h3 id="1.2.7">1.2.7</h2>
<p> Немного изменим второй цикл из программы на предыдущем шаге.</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    for (; i &lt; 10; i++ &amp;&amp; printf("%d", i));
    return 0;
}</code></pre>

<p>Какой будет вывод у этой программы и почему?</p><h3 id="1.2.8">1.2.8</h2>
<p>С помощью оператора <code>break</code> мы выходим из одного внутреннего цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) break;
        }
    }
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code>001012012301234</code></p>

<p>С помощью оператора <code>continue</code> мы переходим к следующей итерации внутреннего цикла, не выполняя оставшуюся часть тела цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            if (j == i) continue;
            printf("%d", j);
        }
    }
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code>12340234013401240123</code></p>

<p>С помощью оператора <code>goto</code> мы переходим к <em>метке</em>. Метка может быть объявлена в любом месте между statement-ов, и выглядит как идентификатор с двоеточием. С помощью оператора <code>goto</code> можно, например, выйти из двойного цикла:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) goto end;
        }
    }
    end:
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code><span style="color: #000000;">0</span></code></p>

<p>Бывает, что необходимо по выполнению условия выйти из блока кода. Увы, сделать это так не получится:</p>

<pre><code class="language-cpp">int main() {
    {
        int i;
        if (i) break;
    }
    return 0;
}</code></pre>

<p>Обычно, для этой цели используют цикл или оператор <em>goto</em>. (В языке программирования Zig это организовано получше.)</p>

<p>Старайтесь не использовать оператор <code>goto</code> там, где он может серьезно усложнить читаемость программы, с чем он отлично справляется. Обычно в языке C он используется для того, чтобы выйти из вложенного цикла, и для того, чтобы перейти к очистке в конце функции, если она что-то динамически создала, но в процессе её работы произошла ошибка, из-за которой она должна прерваться и вернуть ошибку. Выглядит это примерно так:</p>

<pre><code class="language-cpp">FOOSTATUS foo() {
    void *data = malloc(SIZE);
    int status = FOO_SUCCESS;
    if (!init_foo(data)) {
        status = FOO_ERROR_INIT;
        goto end
    }
    if (!process_foo(data)) {
        status = FOO_ERROR_PROCESS;
        goto end
    }
    end:
    free(data);
    return status;
}</code></pre><h3 id="1.2.9">1.2.9</h2>
<p>Для более удобной организации ветвлений используются <code>switch case</code> statement-ы.</p>

<pre><code class="language-cpp">int main() {
    int x = 2;
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 3: printf("3 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 ");
        case 3: printf("3 "); break;
        case 4: printf("4 ");
    }
    switch (x) {
        case 1: printf("1 "); break;
        default: printf("- ");
    }
    printf("\n");
}</code></pre>

<p>Здесь написаны четыре <code>switch case</code> statement-а. В своем теле они имеют ветви, каждая из которых состоит из ключевого слова <code>case</code>, выражения, при котором эта ветвь срабатывает, символа двоеточия и блока кода.</p>

<p>При выполнении <code>switch case</code> statement-а выполняется первая ветвь, выражение после слова <code>case</code> у которой равно выражению после слова <code>switch</code>. У первого <code>switch</code> это вторая ветвь, которая содержит блок <code>printf("%d "); break;</code>. (Ключевое слово <code>break</code> тоже часть блока.) У второго <code>switch</code> такой ветви нет, поэтому ничего не будет исполнено.</p>

<p>Как только срабатывает одна из ветвей, выполняются все следующие ветви вплоть до последней (что по моему мнению является довольно странной логикой), либо до встречи ключевого слова <code>break</code>. Так, у третьего <code>switch</code> будет выполнен блок второй ветви <code>printf("2 ");</code>, а затем продолжится выполнение блока третьей ветви, и, так как он завершается словом <code>break</code>, блок четвертой ветви не будет выполнен.</p>

<p>Четвертый <code>switch</code> statement имеет ветвь, которая начинается с ключевого слова <code>default</code>. Блок данной ветви будет выполнен в любом случае, если не было выполнено ни одного блока выше.</p>

<p>Вывод этой программы: <code>2 2 3 - </code></p><h3 id="1.2.10">1.2.10</h2>
<p>Успешный брокер Василий смотрит курс акций за последние <span class="math-tex">\(n\)</span> дней. Цена акции в день <span class="math-tex">\(i\)</span> равна <span class="math-tex">\(a_i\)</span>. Василий хочет найти два дня <span class="math-tex">\(p &lt; q\)</span>, такие, что <span class="math-tex">\(a_q - a_p\)</span> максимально возможное, ведь именно покупка акций в день <span class="math-tex">\(p\)</span>, а продажа в день <span class="math-tex">\(q\)</span> принесла бы ему максимальную прибыль, будь у него более развитые экстрасенсорные способности.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — наибольшая разность <span class="math-tex">\(a_q - a_p\)</span>.</p>
<h3 id="1.3">1.3. Функции</h3>

<h3 id="1.3.1">1.3.1</h2>
<p>Мы уже объявляли функции. <code>int main() {}</code> — это объявление функции, которая ничего не принимает. При использовании стандартного <em>linker-скрипта</em> (что это такое, мы узнаем позже) наличие этой функции обязательно.</p>

<p>Cигнатура функции — это список типов аргументов, которые функция принимает, и тип того, что функция возвращает. По умолчанию, функция <code>main</code> возвращает <code>int</code>, и значение <code>0</code> означает успешное выполнение. Это значение называется <em>кодом возврата</em> программы, и в <em>sh</em> можно его посмотреть у запущенной в последний раз программы с помощью переменной <code>$?</code>: <code>echo $?</code>.</p>

<p>Попробуем написать свои функции:</p>

<pre><code class="language-cpp">int foo(int a) {
    return a + 2;
}

int main() {
    int a = 5;
    int b = foo(a);
    foo(a);
    printf("%d %d\n", a, b);
    return 0;
}</code></pre>

<p>Функция <code>foo</code> принимает один аргумент типа <code>int</code> и возвращает его значение, увеличенное на <code>2</code>. В результате выполнения этой программы будет выведено <code>5 7</code></p>

<p>Обратите внимание, что вызов функции может быть как expression-ом, как в первом случае, так и statement-ом, как во втором случае.</p>

<p>Функции используются для организации кода и улучшения читаемости.</p>

<p>Функции можно определять в отдельных файлах, но в C (и Assembly) это делается не так просто, как в остальных языках. Мы поговорим об этом отдельно.</p>

<p>В функции <code>foo</code> можно вызвать функцию <code>foo</code>. Это называется <em>рекурсией</em>. Например, функция вычисления наибольшего общего делителя (greatest common divisor) может быть написана так:</p>

<pre><code class="language-cpp">int gcd(int a, int b) {
    if (a == 0)
        return 0;
    else
        return gcd(b % a, a);
}</code></pre>

<p>Естественно, можно допустить ошибку, при которой вызов функции будет происходить бесконечно. В таком случае, так как на хранение данных о предыдущих (и все ещё идущих) вызовах функции тратится память на стеке, стек вскоре закончится, и возникнет ошибка исполнения.</p>

<p>Функции могут ничего не возвращать. Для этого вместо типа возврата указывается <code>void</code>. В таком случае, нельзя использовать функцию, как expression.</p><h3 id="1.3.2">1.3.2</h2>
<p>Принято, что функция <code>main</code> принимает два аргумента, и её полная сигнатура на самом деле выглядит так: <code>int main(int argc, char **argv)</code>. Второй аргумент — список строк, длина которого неизвестна, а первый аргумент — длина этого списка. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>Что за список строк имеется ввиду? Это список аргументов программы. Когда мы запускаем программу в терминале, мы передаем их так: <code>./program ababba babba</code>. При таком запуске вывод программы будет такой:</p>

<pre><code>program
ababba
babba</code></pre>

<p>Первый аргумент всегда должен быть названием исполняемого файла. Мы можем нарушить это правило, если сделаем системный вызов <code>exec</code> самостоятельно, и некоторые программы в таком случае могут отказаться работать. (Что такое системные вызовы мы изучим позже.)</p>

<p>Благодаря особенностям <em>ABI</em> (что это такое, мы узнаем позже) мы можем написать в сигнатуру не все аргументы. Однако мы не можем написать большее количество аргументов, иначе они попадут на данные функции, которая нас вызвала, и мы начнем оперировать ими. (<code>main</code> — не первая функция при стандартном linker-скрипте.) Обратите внимание: компилятор никак не помешает нам этого сделать.</p>

<pre><code class="language-cpp">int main(int a, int b, int c, int d) {
    printf("%d %d %d %d\n", a, b, c, d);
    d = 5;
    return 0;
}
</code></pre>

<p>Если использовать 64-битный компилятор, то размер адресов (любых) будет 8 байт (то есть два <code>int</code>-а). Тогда переменные <code>b</code> и <code>c</code> лягут на аргумент <code>argv</code>, а переменная <code>d</code> на вызвавшую функцию. (Если бы функция <code>main</code> была первой, а мы могли бы сделать это, написав свой linker-скрипт, то мы могли бы ткнуться за пределы стека и получить ошибку исполнения.)</p><h3 id="1.3.3">1.3.3</h2>
<p>Функции "видят" другие функции, объявленные выше. Но если мы хотим написать две вызывающие друг друга функции, то с помощью только определений функций сделать этого, возможно, не удастся. Такой код в C++ некорректен, но в C корректен (возможно, не во всех компиляторах):</p>

<pre><code class="language-cpp">void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Решить эту проблему можно с помощью объявления функции, или, <em>прототипа</em> функции. Выглядит он так:</p>

<pre><code class="language-cpp">void boo(int n);

void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Прототип функции объявляет лишь сигнатуру. Названия аргументов в нем не важны, и, если мы заменим первую строку на <code>void boo(int);</code>, то это будет по прежнему корректно.</p>

<p>Прототип функции должен соответствовать определению функции. Если прототип здесь будет <code>void boo(long long n);</code>, то это вызовет ошибку компиляции.</p>

<p>Очень важно, что если прототип функции, и её определение будут в разных модулях, то компилятор не сможет заметить несоответствия сигнатур функций. В таком случае во время выполнения программы при вызове функции стек "съедет", и произойдет stack corruption. (Более подробно этот механизм мы изучим позже.)</p><h3 id="1.3.4">1.3.4</h2>
<p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int, int)</code></li>
	<li><code>int max(int, int)</code></li>
	<li><code>int abs(int)</code> — абсолютное значение (модуль)</li>
	<li><code>int lcm(int, int)</code> — наименьшее общее кратное (least common multiplier)</li>
	<li><code>int powmod(int a, int n, int m)</code> — возведение числа <code>a</code> в степень <code>n</code> по модулю <code>m</code></li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(5, 8) == 5);
    assert(min(11, 4) == 4);
    assert(max(5, 8) == 8);
    assert(max(11, 4) == 4);
    assert(abs(43) == 43);
    assert(abs(-41) == 41);
    assert(lcm(14, 21) == 42);
    assert(lcm(1128960, 567000) == 254016000);
    assert(powmod(3, 4, 7) == 4);
    assert(powmod(43259, 64234, 784) == 505);
    return 0;
}</code></pre>

<p>Функция <code>assert</code> завершает выполнение программы с кодом возврата <code>3</code>, если её аргумент равен нулю (то есть, условие провалено). Возможно, для его использования потребуется добавить <code>#include &lt;assert.h&gt;</code>.</p><h3 id="1.3.5">1.3.5</h2>
<p>Функции <code>printf</code> и <code>scanf </code>— это функции с переменным количеством аргументов (variadic functions, vararg, ellipsis). Синтаксис C позволяет создавать такие функции, но по понятным (когда придет время) причинам, сам C такие функции поддерживать не может. Проблема в том, что при вызове функции на стек кладутся аргументы и адрес возврата, но ничего более. Поэтому по стеку нельзя понять, сколько аргументов было передано в функцию, и какие их типы или, хотя бы, размерности. Это может вызвать различные corruptions.</p>

<p>Пример функции, вычисляющей сумму аргументов:</p>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

int sum(int n, ...) {
    va_list lst;
    va_start(lst, n);
    
    int sum = 0;
    int i;
    for (i = 0; i &lt; n; i++) {
        sum += va_arg(lst, int);
    }
    
    va_end(lst);
    return sum;
}

int main() {
    printf("%d\n", sum(5, 2, 6, 4, 3, 7));
    return 0;
}</code></pre>

<p>Обратим внимание на следующее:</p>

<ul>
	<li>Нам необходим <code>#include &lt;stdarg.h&gt;</code> для того, чтобы иметь макросы <code>va_list</code>, <code>va_start</code>, <code>va_arg</code>, <code>va_end</code>. (Что такое макросы, мы узнаем позже. Пока считайте, что это функции.)</li>
	<li>Первый аргумент <code>n</code> — это длина массива. Напомню, что функция никак не может знать форму того, что ей передано. Количество аргументов надо указать. Обратите внимание, что если подать в функцию не <code>n</code> следующих аргументов, то она никак это не проверит — это приведет к corruption.</li>
	<li>Чтобы пробежать по аргументам, мы пользуемся переменной типа va_list. Это переменную мы передаем всем функциям, связанным с аргументами. По сути, это не более, чем итератор.</li>
	<li>(Второй аргумент макроса <code>va_start</code> оказался мне неизвестен. Документация утверждает, что это аргумент, после которого начнут перебираться "переменные" аргументы, однако простой тест показал, что это не так.)</li>
	<li>Второй аргумент макроса <code>va_arg</code> это тип (обратите внимание: если бы это была функция, он не могла бы принимать тип), следующего аргумента (а также, его размер).</li>
</ul>

<p>В результате выполнения этой программы будет выведено 22.</p>

<p>Функции с переменными аргументами следует использовать ограниченно и с большой осторожностью.</p><h3 id="1.3.6">1.3.6</h2>
<p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int n, ...)</code></li>
	<li><code>int gcd(int n, ...)</code></li>
	<li><code>int dot_product(int n, ...)</code> — скалярное произведение двух векторов. Например, произведение векторов <code>(1, 4)</code> и <code>(2, -3)</code> должно вычисляться с помощью такого вызова функции: <code>dot_product(2, 1, 4, 2, -3)</code>.</li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(2, 5, 8) == 5);
    assert(min(3, 11, 4, 8) == 4);
    assert(gcd(2, 12, 21) == 3);
    assert(gcd(3, 42, 91, 35) == 7);
    assert(dot_product(2, 1, 4, 2, -3) == -10);
    assert(dot_product(3, 1, 2, 3, 6, 5, 4) == 28);
    return 0;
}</code></pre><h3 id="1.3.7">1.3.7</h2>
<p>Рассмотрим такую функцию <code>set_args</code>, которая записывает значение второго аргумента по всем остальным аргументам-адресам.</p>

<p>Пока необязательно понимать манипуляции с адресами, но кое-что проясню:</p>

<ul>
	<li><code>int*</code> — это адрес типа <code>int</code>. То есть <code>va_arg(lst, int*)</code> достает следующий адрес.</li>
	<li><code>*a = b</code> выполняет запись значения <code>b</code> в адрес <code>a</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

void set_args(int n, int val, ...) {
    va_list lst;
    va_start(lst, val);
    
    int i;
    for (i = 0; i &lt; n; i++) {
        *va_arg(lst, int*) = val;
    }
    
    va_end(lst);
}

int main() {
    int a, b, c;
    set_args(3, 31, &amp;a, &amp;b, &amp;c);
    printf("%d %d %d\n", a, b, c);
    return 0;
}</code></pre>

<p>Представьте, что пользователь может вводить данные и передавать их в <code>set_args</code> без каких либо проверок. Какую атаку можно здесь произвести (потенциально нехорошее действие)?</p>
<h3 id="1.4">1.4. Указатели</h3>

<h3 id="1.4.1">1.4.1</h2>
<p>Переходим к самой интересной части языка C — указателям/адресам (pointers).</p>

<p>Указатель — это число, обозначающее ячейку в оперативной памяти. Любая локальная переменная имеет адрес, так как ей нужно где-то находиться. То же относится и к аргументам функций. (На самом деле иногда данные находятся в регистрах, но компилятор здесь будет подстраиваться под наши желания.)</p>

<p>Для взятия адреса используется унарный (с одним аргументом) оператор <code>&amp;</code>, который мы уже видели, когда использовали функцию <code>scanf</code>.</p>

<p>Тип указателя обозначается символом <code>*</code> (asterisk). Например, указатель на <code>int</code> выглядит так: <code>int*</code>. При этом синтаксис объявления указателей неочевидный и часто вызывает ошибки.</p>

<ul>
	<li>Так мы объявляем два указателя: <code>int *a, *b;</code></li>
	<li>Так мы объявляем два указателя: <code>int* a, *b;</code></li>
	<li>Так мы объявляем указатель и число: <code>int* a, b;</code></li>
</ul>

<p>Чтобы переместить данные по указателю (то есть положить их в ячейку оперативной памяти с тем же номером, что и значение указателя), используется такая запись: <code>*a = b</code>, где <code>a</code> это указатель, а <code>b</code> это данные.</p>

<p>Рассмотрим программу:</p>

<pre><code class="language-cpp">void set(int *a, int val) {
    *a = val;
}

int main() {
    int a;
    set(&amp;a, 5);
    printf("%d\n", a);
    return 0;
}</code></pre>

<p>Данная программа демонстрирует то, что я показывал выше. Функция <code>set</code> принимает аргумент типа <code>int*</code> (можно было также написать <code>int* a</code>). В функции <code>set</code> используется перемещение (этот термин не имеет отношения к тому, что с данными что-то происходит: они остаются в том же состоянии) по указателю <code>*a = val</code>. При вызове функции <code>set</code> в качестве аргумента передается адрес локальной переменной, который добывается оператором <code>&amp;</code>.</p>

<p>Вывод этой программы: <code>5</code></p><h3 id="1.4.2">1.4.2</h2>
<p>В языке C присутствуют массивы, но работают они довольно странно и неочевидно. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a[10];
    a[4] = 32;
    printf("%d %d\n", a[4], sizeof(a));
    return 0;
}</code></pre>

<p>Первая строка тела функции <code>main</code> объявляет массив размера <code>10</code>. Массив — это занумерованная последовательность объектов одинакового типа. Размер массива должен быть константой, то есть известным до компиляции (<code>4 + 6</code>, например, тоже является константой).</p>

<p>На второй строке мы присваиваем четвертому элементу массива значение <code>32</code>. Массивы нумеруются с нуля. Последний индекс массива в данном случае равен <code>9</code>.</p>

<p>На третьей строке мы выводим четвертый элемент и размер массива. Вывод этой программы: <code>32 40</code>. Обратите внимание: в качестве размера массива выводится не количество его элементов, а именно занимаемая им память в байтах (напомним, что размер типа <code>int</code> равен <code>4</code> байта).</p>

<p>Что произойдет, если мы выйдем за пределы массива, сделав, например <code>a[10] = 32</code>? В конкретно этом случае, на самом деле, ничего. Точнее, присвоение произойдет, но то, что оно происходит за пределами массива, никак не будет проверено. Массив, как и все локальные переменные, а также адреса возврата функций, лежит на стеке, а в этом месте стека ничего важного не будет. Однако, в некоторых случаях, можно все-таки, перезаписать что-либо важное. Эта особенность делает программирование на C коварным, так как можно создать "отложенные ошибки": пока некорректный код работает, так как ничего не затирает, а с другими исходными данными уже будет затирать.</p>

<p>Можно создавать многомерные массивы:</p>

<pre><code class="language-cpp">int main() {
    int a[4][5];
    a[2][3] = 5;
    a[0][5] = 3;
    printf("%d %d\n", a[2][3], a[1][0]);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>5 3 80</code></p>

<p>Здесь мы создали двумерный массив размера <code>4x5</code>. Оперативная память адресуется линейно, и данный двумерный массив расположен в ней следующим образом: <code>a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[2][5], ...</code>. Именно поэтому, так как C не обращает внимания на выходы за границы, присваивание некорректного индекса <code>a[0][5]</code> приводит к присваиванию индекса <code>a[1][0]</code>.</p>

<p>Обратите внимания на то, что размер массива равен <code>80</code>, или <code>20</code> <code>int</code>-ов. Этот факт нам пригодится позже.</p><h3 id="1.4.3">1.4.3</h2>
<p>Массивы практически являются указателями. Можно перевести массив в указатель. Рассмотрим программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int a[10];
    int *b = a;
    *(b + 4) = 32;
    printf("%d %d %d\n", b[4], sizeof(a), sizeof(b));
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>32 40 4</code> или <code>32 40 8</code>, в зависимости от разрядности вашего компилятора.</p>

<p>Если вы добавляете к указателю типа <code>T*</code> число <code>x</code>, то на самом деле к указателю добавиться число <code>x * sizeof(T)</code>.</p>

<p><code>*(b + 4)</code> сначала добавляет к  <code>b</code> значение <code>4 * sizeof(int)</code>, а затем <em>разыменовывает</em> (берет значение в этой ячейке памяти) его. Комичный факт, что <code>b[4] == *(b + 4) == *(4 + b) == 4[b]</code>.</p>

<p>Обратите внимание: вы можете делать операции с указателями так же, как и с массивами. Но есть одна разница: <code>sizeof</code> для указателя возвращает размер указателя, а не всего массива. Более того, имея только указатель, узнать размер массива невозможно. То есть, тип указатель, в отличии от типа массив, не знает размер.</p>

<p>Массивы нельзя передавать в функции. Поэтому, чтобы знать в функции размер массива, приходится передавать и размер:</p>

<pre><code class="language-cpp">int sum(int n, int *a) {
    int x = 0, i;
    for (i = 0; i &lt; n; i++) {
        x += a[i];
    }
    return x;
}

int main() {
    int a[5] = {2, 5, 1, 4, 3};
    int n = sizeof(a) / sizeof(a[0]);
    printf("%d\n", sum(n, a));
    return 0;
}</code></pre>

<p>Обратите внимание на синтаксис присваивания значений элементам массива <code>int a[5] = {2, 5, 1, 4, 3};</code>, и на то, как можно узнать количество элементов локального массива, разделив его размер на размер одного из его элементов (часто даже создают такой макрос).</p><h3 id="1.4.4">1.4.4</h2>
<p>Реализуйте функцию <code>void sort(int n, int *a)</code>, которая сортирует массив <code>a</code> размера <code>n</code>.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const int n = 10;
    int a[n] = {6, 1, 8, 2, 10, 7, 4, 5, 9, 3};
    int b[n] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    sort(n, a);
    assert(memcmp(a, b, n * sizeof(int)) == 0);
    return 0;
}</code></pre><h3 id="1.4.5">1.4.5</h2>
<p>Массивы можно создавать динамически. В C нет операторов для этого, но есть стандартные функции <code>malloc</code> и <code>free</code>.</p>

<p>Функция <code>void *malloc(size_t size)</code> создает массив размера <code>size</code> байт и возвращает указатель типа <code>void</code> на его начало. <code>size_t</code> здесь это <code>unsigned int</code>, то есть, беззнаковое (только положительное) целое число. Все численные типы имеют соответствующий <code>unsigned</code> тип.</p>

<p><code>void*</code> указатель обозначает указатель на "что-то", и мы должны будем определить, на что он указывает, самостоятельно. Кроме того, добавление числа <code>x</code> к <code>void*</code> указателю добавит к нему именно <code>x</code>, поэтому этот тип часто используется для создания структур данных.</p>

<p>В отличии от локальных массивов, динамические массивы выделяются не на стеке. Возможные их положения зависят от операционной системы. Как можно делать динамические выделения памяти, и как работает <code>malloc</code>, мы узнаем позже.</p>

<p>Функция <code>void free(void *ptr)</code> освобождает массив, на начало которого указывает <code>ptr</code>. Это значение должно быть ранее получено от <code>malloc</code>. В случае, если такое значение ранее не было получено от <code>malloc</code>, и, соответственно, такого массива не существует, будет ошибка исполнения.</p>

<pre><code class="language-cpp">int main() {
    int *a = (int*)malloc(10 * sizeof(int));
    a[5] = 23;
    printf("%d\n", a[5]);
    free(a);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>23</code></p>

<p>На первой строке мы выделили массив int-ов, состоящий из 10 элементов (не забывает домножать на размер элемента). Чтобы не было предупреждений от компилятора, необходимо перевести тип указателя из <code>void*</code> в <code>int*</code> с помощью <code>(int*)</code>. (При этом  при переводе типа с любого указателя на любой указатель значение не изменится. Для других базовых типов это не всегда так.) Далее мы можем оперировать массивом, как любым другим. На четвертой строке мы освобождаем массив.</p>

<p>Что будет, если выйти за границы динамического массива? Обычно место, в котором выделился ваш массив, это куча — большой отрезок, на операции с которым у вашей программы есть права, а у других программ нет, и в котором выделяются куски на каждый ваш вызов функции <code>malloc</code>. Если вы попытаетесь выполнить операцию за пределами массива, но попадёте в ваш отрезок кучи, то операция будет успешной. При этом эта точка может принадлежать другому массиву, который используется в вашей программе.</p>

<p>Это ещё одна коварность языка C: вы промазали по массиву, но операция выполнилась успешно, и вы повредили память, которая позже будет использоваться. В таком случае, если вы попробуете использовать <em>дебаггер</em> для определения проблемы, он покажет тот, скорее всего корректный, код, память которого была затерта, а не тот код, который затер память.</p>

<p>Если же вы попадете не в ваш отрезок кучи, то программа просто завершится из-за сигнала <em>SIGSEGV</em>.</p>

<p>Что произойдет, если вы не освободите память? На самом деле, ничего, и нет никакой проблемы не освобождать память в однопроходной программе. Вся выделенная память все равно освободится при завершении программы. Однако, если ваша программа работает длительное время, часто создавая и удаляя объекты, необходимо освобождать память, чтобы она не закончилась. Вызов функции <code>malloc</code> может вернуть <code>0</code>, что означает отказ в выделении памяти, скорее всего, по причине превышения лимита.</p><h3 id="1.4.6">1.4.6</h2>
<p>Найдите все возможные ошибки и утечки памяти в следующем коде:</p>

<pre><code class="language-cpp">int* foo(int x) {
    int *a = malloc(N * sizeof(int));
    if (x &lt; 0) return 0;
    int i;
    for (i = 0; i &lt; N; i++) {
        a[i] = x;
    }
    return a;
}

void boo() {
    int *a = malloc(N * sizeof(int));
    int *b = a;
    int *c = malloc(N * sizeof(int));
    a = c;
    c = b;
    b = a;
    c = b;
    free(a);
    free(b);
}

int flghm_count(int mode, int *result) {
    int status;
    int *buffer;
    status = flghm_init(buffer);
    if (!status) return -1;
    status = flghm_fill(buffer, result);
    if (!status) return -2;
    status = flghm_free(buffer);
    if (!status) return -3;
    return 0;
}
</code></pre><h3 id="1.4.7">1.4.7</h2>
<p>Изучим алгоритм сортировки слиянием (Merge Sort).</p>

<pre><code class="language-cpp">void merge_sort(int *a, int l, int r) {
    if (r - l == 1) return;
    int m = (l + r) / 2;
    merge_sort(a, l, m);
    merge_sort(a, m, r);
    ...
}</code></pre>

<p>Данный алгоритм является рекурсивным. Он принимает сам массив и границы подотрезка, который данному рекурсивному вызову следует отсортировать. Если длина подотрезка равна <code>1</code>, то он уже отсортирован. Если это не так, то разделим подотрезок на два меньших подотрезка и вызовем <code>merge_sort</code> от каждого из них. В результате мы получим два отсортированных подотрезка. Их необходимо <em>слить</em> в один, после чего сортировка будет завершена.</p>

<p>Здесь я использовал полуинтервалы, то есть индекс <code>r</code> не входит в подотрезок, который необходимо отсортировать. При такой реализации нет необходимости добавлять <code>+1</code> и <code>-1</code> к различным индексам границ.</p>

<p>Реализуйте алгоритм слияния. Он должен по двум отсортированным подотрезкам <code>[l, m)</code> и <code>[m, r)</code> получить один отсортированный подотрезок <code>[l, r)</code>. Здесь <code>[]</code> означают границы включительно, а <code>()</code> — не включительно.</p>

<p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Отсортируйте заданную последовательность.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(b_1, b_2, \ldots, b_n\)</span> (<span class="math-tex">\(b_1 \le b_2 \le \ldots \le b_n\)</span>) — отсортированную последовательность <span class="math-tex">\(a\)</span>.</p><h3 id="1.4.8">1.4.8</h2>
<p>Помимо многомерных массивов можно пользоваться также многомерными указателями. Однако, как и в одномерном случае, указатели не знают форму массива. Поэтому, например, двумерный массив размера <code>n*m</code> в помощью указателей представляется как массив размера <code>n</code>, состоящий из указателей на массивы размера <code>m</code> (на самом деле, размеры этих массивов могут различаться). Динамическое выделение двумерного массива выглядит так:</p>

<pre><code class="language-cpp">int main() {
    const int n, m;
    int **a = malloc(n * sizeof(int*));
    int i;
    for (i = 0; i &lt; n; i++) {
        a[i] = malloc(m * sizeof(int));
    }
    
    a[2][3] = 12;
    printf("%d\n", a[2][3]);
    
    for (i = 0; i &lt; n; i++) {
        free(a[i]);
    }
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Обратите внимание на следующее:</p>

<ul>
	<li>Я использовал на этот раз идентификаторы <code>n</code> и <code>m</code> в качестве размера массива. Так как размер массива должен быть известен на момент компиляции, я должен объявить их как константы. Значения констант нельзя менять.</li>
	<li>Выделение памяти для массива происходит в два этапа: сначала я создаю массив указателей (поэтому домножение идет на <code>sizeof(int)</code>) размера <code>n</code>, а затем для каждого указателя создаю массив <code>int</code>-ов размера <code>m</code>. Тоже самое касается освобождения памяти.</li>
	<li>Итоговый размер массива не <code>n * m * sizeof(int)</code>, а <code>n * sizeof(int*) + n * m * sizeof(int)</code>.</li>
</ul>

<p>В отличии от локального массива, здесь отдельные ряды не идут друг за другом, а расположены так, как это сделал <code>malloc</code>. Мы можем расположить ряды массива подряд самостоятельно, но тогда нам нужно будет использовать не оператор индексации <code>[]</code>, а свою функцию.</p>

<pre><code class="language-cpp">int offset(int i, int j, int m) {
    return i * m + j;
}

int main() {
    const int n, m;
    int *a = malloc(n * m * sizeof(int));
    
    a[offset(2, 3, m)] = 12;
    printf("%d\n", a[offset(2, 3, m)]);
    
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Попробуйте самостоятельно разобраться с тем, как здесь организован массив.</p><h3 id="1.4.9">1.4.9</h2>
<p>Задан граф, состоящий из <span class="math-tex">\(n\)</span> вершин и <span class="math-tex">\(m\)</span> ребер. <span class="math-tex">\(i\)</span>-е ребро задается парой вершин <span class="math-tex">\((v_i, u_i)\)</span> — вершины, которые это ребро соединяет. Найдите количество компонент связности данного графа.</p>

<p>Компоненты связности — это разбиение множества вершин графа на попарно непересекающиеся подмножества такие, что для любых двух вершин в одном множестве (в одной компоненте связности) существует путь между ними, а для любых двух вершин в разных множествах не существует пути между ними.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит два целых числа <span class="math-tex">\(n\)</span> и <span class="math-tex">\(m\)</span> (<span class="math-tex">\(1 \le n, m \le 10^3\)</span>)</p>

<p>Следующие <span class="math-tex">\(m\)</span> строк входных данных содержат по два целых числа <span class="math-tex">\(v_i\)</span> и <span class="math-tex">\(u_i\)</span> (<span class="math-tex">\(1 \le v_i, u_i \le n\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — количество компонент связности в заданном графе.</p><h3 id="1.4.10">1.4.10</h2>
<p>Интересно, и не очень красиво, обстоят дела с указателями-константами. Рассмотрим примеры: </p>

<pre><code class="language-cpp">int main() {
    const int *n;
    int m;
    n = &amp;m;
    
    return 0;
}</code></pre>

<p> <code>const int*</code> объявляет указатель, у которого нельзя менять содержимое. Мы изменить сам указатель (то есть, адрес, на который он указывает), но не можем изменить его содержимое <code>*n = 2</code>.</p>

<pre><code class="language-cpp">int main() {
    int *const n;
    *n = 2;
    
    return 0;
}</code></pre>

<p>Здесь обратная ситуация: <code>int *const</code> позволяет менять содержимое указателя, но не позволяет изменить сам указатель <code>n += 10</code>.</p>

<p>Рассмотрим немного комичный пример:</p>

<pre><code class="language-cpp">int main() {
    const int * *const *n;
    
    n += 2;
    // *n = 2;
    **n += 2;
    // ***n += 2;
    
    return 0;
}</code></pre>

<p>Закомментированные строки нарушают правила константности и вызывают ошибку компиляции.</p><h3 id="1.4.11">1.4.11</h2>
<p>Мы теперь можем понять смысл типа "строки" — <code>const char*</code>. Это указатель на символ (и, соответственно, следующие символы), содержимое которого (то есть, ни первый символ, ни другие) нельзя менять.</p>

<p>Посмотрим на сигнатуру функции <code>int execv(const char *path, char *const argv[]);</code> (подробнее по <a href="https://linux.die.net/man/3/execv" rel="noopener noreferrer nofollow">ссылке</a>). Что вы можете сказать про её второй аргумент, и как это влияет на использование функции? Попробуйте вызвать эту функцию (необязательно делать что-то осмысленное, главное добиться успешной компиляции).</p>
<h3 id="1.5">1.5. Строки</h3>

<h3 id="1.5.1">1.5.1</h2>
<p>Представим, что мы печатаем строку, с помощью <code>scanf("%s", str);</code>. <code>str</code> — это не более, чем указатель. Как функция <code>scanf</code> понимает, где кончается строка? Она понимает это с помощью численно равного нулю символа <code>\0</code>, которым строка заканчивается. Когда мы объявляем строку, как <code>const char *str = "aba";</code>, то её длина будет составлять <code>4</code>, и последним символом в ней будет <code>\0</code>.</p>

<p>Что же будет, если мы целенаправленно избавимся от нулевого символа в конце строки? Сделать это мы можем так:</p>

<pre><code class="language-cpp">int main() {
    char a[3];
    a[0] = 'a';
    a[1] = 'b';
    a[2] = 'c';
    printf("%s\n", a);
    return 0;
}</code></pre>

<p>Вывод этой программы будет начинаться с символов <code>abc</code>. То, что пойдет далее, зависит от компилятора и его режима. Здесь происходит довольно простая и очевидная вещь: функция <code>scanf</code> печатает символ за символом, пока не наткнется на нулевой символ где-то дальше за строкой в памяти. В зависимости от того, где расположена строка, это также может вызвать ошибку исполнения, если нулевого символа не найдется вплоть до конца доступной программе памяти.</p>

<p>Из-за такой особенности работа со строками в языке C довольно неприятна. Необходимо всегда помнить о лишнем символе.</p>

<p>Рассмотрим первую стандартную функцию для работы со строками: <code>size_t strlen( const char* str );</code>. С помощью этой функции мы определяем длину строки (не включая нулевой символ). Написать эту функцию очень просто, вот её реализация:</p>

<pre><code class="language-cpp">size_t strlen( const char* str ) {
    const char *x = str;
    while (*x != '\0') {
        x++;
    }
    return x - str;
}</code></pre>

<p>Чтобы проверить эту реализацию, функцию необходимо будет переименовать, либо убрать <code>glibc</code>.</p>

<p>Для использования стандартных функций для работы со строками часто необходимо добавить <code>#include &lt;string.h&gt;</code>.</p><h3 id="1.5.2">1.5.2</h2>
<p>При выполнении данной программы происходит ошибка исполнения, хотя строка не является константой, и компиляция проходит успешно. (Возможно, наблюдается не на всех компиляторах.) Почему? </p>

<pre><code class="language-cpp">int main() {
    char *a = "abacaba";
    a[3] = 'b';
    
    return 0;
}</code></pre><h3 id="1.5.3">1.5.3</h2>
<p>Функция <code>int sprintf( char* buffer, const char* format, ... );<span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span></code> работает, как функция <code>printf</code>, но она принимает своим первых аргументом строку <code>buffer</code>, в которую и происходит печать. При этом содержимое строки <code>buffer</code>  никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    char str[100];
    sprintf(str, "%d %d", 32, 85);
    printf("%s\n", str);
}</code></pre>

<p>Вывод этой программы: <code>32 85</code></p>

<p>Функция <code>char *strcpy( char *dest, const char *src );</code> выполняет копирование строки из второго аргумента в первый (поэтому тип первого аргумента лишен <code>const</code>). Копирование выполняется до обнаружения нулевого символа в <code>src</code>. При этом содержимое строки <code>dest</code> никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>abacaba</code></p>

<p>Обратите внимание, что функция <code>strcpy</code> закладывает нулевой символ в конец строки <code>dest</code>. Не забывайте оставлять под него место.</p>

<p>Часто необходимо ограничить длины копируемой строки. Вместо добавления <code>if</code>-а можно использовать стандартную функцию <code>char *strncpy( char *dest, const char *src, size_t count );</code>, которая копирует не более <code>count</code> символов, <strong>включая нулевой символ</strong> (то есть, может оставить строку без нуля на конце).</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[4];
    strncpy(b, a, 3);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>aba</code></p>

<p>Вообще, "n" версии есть у почти каждой строковой функции. Посмотрите функцию <code>strnlen</code>.</p><h3 id="1.5.4">1.5.4</h2>
<p>Функция <code>int strcmp( const char* lhs, const char* rhs );</code> сравнивает две строки <em>лексикографически</em>.</p>

<blockquote>
<h3>Return value</h3>

<p>Negative value if lhs appears before rhs in lexicographical order.</p>

<p>Zero if lhs and rhs compare equal.</p>

<p>Positive value if lhs appears after rhs in lexicographical order.</p>
</blockquote>

<p>Обратите внимание, что упоминается лишь знак возвращаемого значения. Само же значение не задокументировано.</p>

<p>Так мы проверяем две строки на равенство:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "aba";
    const char *b = "baba";
    const char *c = "aba";
    printf("%d\n", strcmp(a, b));
    printf("%d\n", strcmp(b, a));
    printf("%d\n", strcmp(a, c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>-1 1 0 </code></p>

<p>Перевести строку в число можно с помощью функции <code>int atoi( const char* str );</code>.(В случае некорректной строки она возвращает <code>0</code>.)</p>

<pre><code class="language-cpp">int main() {
    printf("%d\n", atoi("5328"));    
    return 0;
}</code></pre>

<p>Часто необходимо проводить копирование в динамическую строку (вообще, часто приходится работать и с динамическими строками). Вместо такого:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    int n = strlen(a);
    char *b = (char*)malloc((n + 1) * sizeof(char));
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>, можно использовать функцию <code>char * strdup( const char *str1 );</code>, которая делает то же самое: <code>char *b = strdup(a);</code>.</p><h3 id="1.5.5">1.5.5</h2>
<p>Реализуется функции <code>strcpy</code>, <code>strncpy</code>, <code>strcmp</code> и <code>strncmp</code> так, как ранее была реализована функция <code>strlen</code>. Добавьте в начало из названия символ <code>_</code>, чтобы не было конфликтов имен.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    _strcpy(b, a);
    assert(strcmp(b, "abacaba") == 0);
    b[3] = '\0';
    _strncpy(b, a, 3);
    assert(strcmp(b, "aba") == 0);
    assert(_strcmp("aba", "aba") == 0);
    assert(_strcmp("aba", "abc") &lt; 0);
    assert(_strcmp("abc", "aba") &gt; 0);
    assert(_strncmp("aba", "abc", 2) == 0);
    assert(_strncmp("aba", "abc", 3) &lt; 0);
    return 0;
}</code></pre><h3 id="1.5.6">1.5.6</h2>
<p>Следующая функция  <code>char* strtok( char* str, const char* delim );</code> более сложная в использовании. Эта функция используется для разбиения строки <code>str</code> на токены. Аргумент <code>delim</code> хранит символы-разделители токенов. Рассмотрим программу:</p>

<pre><code class="language-cpp">#define NULL 0

int main() {
    char str[] = "ab;cde,fghi";
    
    char *a = strtok(str, ",;");
    printf("%d ", strlen(str));
    printf("%d ", strlen(a));
    
    char *b = strtok(NULL, ",;");
    printf("%d ", strlen(b));
    
    char *c = strtok(NULL, ",;");
    printf("%d ", strlen(c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>2 2 3 4</code></p>

<p>Пусть разделителями будут символы <code>,</code> и <code>;</code>. Сначала выполним такой вызов функции: <code>strtok(str, ",;");</code>. В результате этого вызова вместо первого разделителя в изначальной строке <code>;</code> будет поставлен нулевой символ, будет возвращен указатель на первый символ, не являющийся разделителем (а наша строка не начинается с разделителей, поэтому будет возвращен <code>str</code>) , а внутри функции <code>strtok</code> будет неким образом создана запись о том, какой последний символ был обработан.</p>

<p>Затем выполним вызов <code>strtok(NULL, ",;");</code>. В результате этого вызова повторятся те же действия, но не с аргумента (который теперь просто <code>0</code>), а с последнего обработанного символа (видимо, с того, который стал нулевым, но это уже нам неизвестно). Сначала пропустятся следующие два разделителя <code>;</code> до первого, не разделительного символа <code>c</code>. Затем будет найден следующий разделительный символ <code>,</code> и заменен на нулевой символ. И наконец, будет возвращён указатель на символ <code>c</code>.</p>

<p>Строка <code>#define NULL 0</code> заменяет все вхождения идентификаторов <code>NULL</code> в нижестоящем коде на <code>0</code> до компиляции программы. Но об этом мы поговорим позже.</p><h3 id="1.5.7">1.5.7</h2>
<p>Напишите функцию <code>int strsum(const char *str);</code>, которая принимает строку, состоящую из последовательности целых чисел и пробелов, и возвращает сумму чисел в этой строке.</p>

<p>Подставьте следующую функцию&nbsp;<code>main</code>:</p>

<pre>
<code class="language-cpp">int main() {
    assert(strsum("123") == 123);
    assert(strsum("-6") == -6);
    assert(strsum("  2  2    3 ") == 7);
    assert(strsum("  -6  24    -7 ") == 11);
    return 0;
}</code></pre><h3 id="1.5.8">1.5.8</h2>
<p>Для выполнения таких же операций с массивами любого типа используются&nbsp;<code>mem***</code>&nbsp;функции. Естественно, функции&nbsp;<code>memlen</code>&nbsp;нет, так как только строки завершаются нулём. Не забывайте о том, что размер массива принимается в байтах, поэтому нужно домножать количество элементов на размер одного элемента.</p>

<p>Функция&nbsp;<code>void *memset(void *buf, int ch, size_t count)</code>&nbsp;устанавливает <code>len</code>&nbsp;байт массива&nbsp;<code>buf</code>&nbsp;равными младшему байту числа&nbsp;<code>ch</code>&nbsp;(старшие байты при этом игнорируются).</p>

<pre>
<code class="language-cpp">int main() {
    int a[4];
    memset(a, 0x1234, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", a[i]);
    }
    printf("%d", 0x34343434);
    
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>875836468 875836468 875836468 875836468 875836468</code></p>

<p>Функция&nbsp;<code>void *memcpy(void *dest, const void *source, size_t count)</code>&nbsp;копирует&nbsp;<code>count</code>&nbsp;байт массива&nbsp;<code>source</code>&nbsp;в массив&nbsp;<code>dest</code>.</p>

<pre>
<code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4];
    memcpy(b, a, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", b[i]);
    }
    
    return 0;
}</code></pre>

<p>Вывод этой программы будет состоять из четырёх чисел, первый три из которых:&nbsp;<code>1 2 3</code></p>

<p>Функция&nbsp;<code>int memcmp(const void *buf1, const void *buf2, size_t count)</code>&nbsp;сравнивает первые&nbsp;<code>count</code>&nbsp;элементов массивов&nbsp;<code>buf1</code>&nbsp;и&nbsp;<code>buf2</code>&nbsp;лексикографически так же, как и функция&nbsp;<code>strcmp</code>.</p>

<pre>
<code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4] = {1, 2, 3, 5};
    printf("%d ", memcmp(a, b, 3 * sizeof(int)));
    printf("%d ", memcmp(a, b, 4 * sizeof(int)));
    
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>0 -1</code></p>

<p>Следует отдавать предпочтение&nbsp;<code>mem***</code>&nbsp;функциям, так как они используют специальные ассемблерные инструкции (которые мы ещё увидим), и потому более быстрые. (Хотя <code>str***</code>&nbsp;функции в то же время тоже имеют некоторые хитрые оптимизации, связанные с итерированием не по одному символу, а по машинному слову. Но это не так сильно влияет.)</p>
<h3 id="1.6">1.6. Структуры</h3>

<h3 id="1.6.1">1.6.1</h2>
<p>Один байт состоит из восьми бит. Бит принимает одно из двух значений:&nbsp;<code>0</code>&nbsp;или&nbsp;<code>1</code>. Поэтому один байт может принимать&nbsp;<span class="math-tex">\(2^8 = 256\)</span>&nbsp;различных значений.</p>

<p>Рассмотрим, как переводить числа из двоичной в десятичную систему счисления. Мы будем указывать менее значимые цифры справа. (Хотя это и не важно, и часто для удобства менее значимые цифры размещают слева.)</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>0</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>1</code></td>
			<td><code>1</code></td>
		</tr>
		<tr>
			<td><code>10</code></td>
			<td><code>2</code></td>
		</tr>
		<tr>
			<td><code>11</code></td>
			<td><code>3</code></td>
		</tr>
		<tr>
			<td><code>100</code></td>
			<td><code>4</code></td>
		</tr>
		<tr>
			<td><code>101</code></td>
			<td><code>5</code></td>
		</tr>
		<tr>
			<td><code>110</code></td>
			<td><code>6</code></td>
		</tr>
		<tr>
			<td><code>111</code></td>
			<td><code>7</code></td>
		</tr>
		<tr>
			<td><code>1000</code></td>
			<td><code>8</code></td>
		</tr>
	</tbody>
</table>

<p>В общем случае, если&nbsp;<span class="math-tex">\(i\)</span>-й бит числа в двоичной записи равен&nbsp;<span class="math-tex">\(a_i\)</span>, в десятичной записи оно будет равно&nbsp;<span class="math-tex">\(a_0 \cdot 1 + a_1 \cdot 2 + a_2 \cdot 4 + a_3 \cdot 8 + \ldots = \sum{a_i \cdot 2^i}\)</span></p>

<p>Целочисленные типы данных бывают знаковыми (signed) и беззнаковыми (unsigned). Беззнаковые типы принимают значение от&nbsp;<span class="math-tex">\(0\)</span>&nbsp;(когда все биты нулевые) до&nbsp;<span class="math-tex">\(2^{size} - 1\)</span>&nbsp;(когда все биты единицы), где&nbsp;<span class="math-tex">\(size\)</span>&nbsp;&mdash; это размер типа данных в битах. Так, максимальное значение типа&nbsp;<code>unsigned int</code>&nbsp;равно&nbsp;<span class="math-tex">\(2^{32} - 1 = 4294967295\)</span>.</p>

<p>Знаковые типы принимают значение от&nbsp;<span class="math-tex">\(-2^{size - 1}\)</span>&nbsp;до&nbsp;<span class="math-tex">\(2^{size - 1} - 1\)</span>. Как кодируются отрицательные числа покажем на примере типа&nbsp;<code>char</code>.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width:500px">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>00000000</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>11111111</code></td>
			<td><code>-1</code></td>
		</tr>
		<tr>
			<td><code>11111110</code></td>
			<td><code>-2</code></td>
		</tr>
		<tr>
			<td><code>11111101</code></td>
			<td><code>-3</code></td>
		</tr>
		<tr>
			<td><code>11111100</code></td>
			<td><code>-4</code></td>
		</tr>
	</tbody>
</table>

<p>Переводить число из&nbsp;<code>n</code>-й системы счисления в десятичную можно с помощью формулы&nbsp;<span class="math-tex">\(\sum{a_i \cdot n^i}\)</span>. Чтобы писать в коде числа в двоичном, восмеричном и шестнадцатиричном формате, следует перед ними написать&nbsp;<code>0b</code>,&nbsp;<code>0</code>&nbsp;и&nbsp;<code>0x</code>&nbsp;соответственно. Формат&nbsp;<code>%d</code>выполнит печать в десятичном формате, но&nbsp;<code>printf</code>&nbsp;также имеет форматы и для других систем счисления.</p>

<pre>
<code class="language-cpp">int main() {
    printf("%d %d %d\n", 0b1010, 013, 0xC);
    return 0;
}</code></pre>

<p>Вывод этой программы:&nbsp;<code>10 11 12</code></p><h3 id="1.6.2">1.6.2</h2>
<p>Для манипуляций с битами чисел используются битовые операторы. Они взаимодействуют на каждую позицию чисел-аргументов независимо и действуют аналогично одноименным логическим операторам.</p>

<ul>
	<li><code>&amp;</code> — оператор И. Например, <code>0b10110 &amp; 0b11010 = 0b10010</code>.</li>
	<li><code>|</code> — оператор ИЛИ. Например, <code>0b10101 | 0xb11001 = 0x11101</code>.</li>
	<li><code>^</code> — оператор исключающее ИЛИ. Например, <code>0x1001 ^ 0x1100 = 0x0101</code>.</li>
	<li><code>~</code> — унарный оператор НЕ. Например, для типа <code>char</code>, <code>~0b1010 = 0b11110101</code>. (Обратите внимание на зависимость от размера типа данных.)</li>
	<li><code>&lt;&lt;</code> — оператор сдвига числа налево (в сторону увеличения числа). Например, <code>0b1001 &lt;&lt; 2 = 0b100100</code>. Сдвиг не циклический. Если никакие единичные биты не пропадают, то <code>a &lt;&lt; b</code><span class="math-tex">\(= a \cdot 2 ^ b\)</span>.</li>
	<li><code>&gt;&gt;</code> — оператор сдвига числа направо (в сторону уменьшения числа). Например, <code>0b1001 &gt;&gt; 2 = 0b10</code>. Сдвиг не циклический. <code>a &gt;&gt; b</code><span class="math-tex">\(= \lfloor \frac{a}{2^b} \rfloor\)</span>.</li>
</ul>

<p>Проверить наличие <code>i</code>-го бита в числе можно так: <code>if (a &amp; (1 &lt;&lt; i))</code>.</p>

<p>Битовые операторы имеют неочевидные приоритеты. Например, если вы хотите проверить, что <code>i</code>-й бит отсутствует, то такая проверка <code>if (a &amp; (1 &lt;&lt; i) == 0)</code> некорректна, так как оператор сравнения выполнится до оператора битового И.</p>

<p>Если вы проверяете наличие <code>i</code>-го бита в числе типа <code>long long</code>, то следует делать сдвиг так: <code>1ll &lt;&lt; i</code>. Суффикс <code>ll</code> делает число <code>1</code> типа <code>long long</code>. Если же не приписать этот суффикс и проверить, например, <code>40</code>-й бит то сначала выполниться сдвиг числа <code>1</code> типа <code>int</code> на <code>40</code> позиций, результат чего будет равен нулю, и уже затем он будет переведен в тип <code>long long</code>.</p>

<p>Подобные суффиксы есть и у других типов. Дробные числа, записанные так — <code>4.3</code> — имеют тип <code>double</code>, а не <code>float</code>, что не позволит написать, например, так: <code>const float a = 4.3;</code>(возможно, не во всех компиляторах). Числа типа <code>float</code> следует завершать символом <code>f</code>.</p><h3 id="1.6.3">1.6.3</h2>
<p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Найдите минимальный размер такого множества чисел <span class="math-tex">\(b_1, b_2, \ldots, b_m\)</span>, что <span class="math-tex">\(a_{b_1} | a_{b_2} | \ldots | a_{b_m} = a_1 | a_2 | \ldots | a_n\)</span></p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 20\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 2^{30} - 1\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное целое число <span class="math-tex">\(m\)</span> — минимальный размер подходящего множества.</p><h3 id="1.6.4">1.6.4</h2>
<p>Рассмотрим перевод дробного числа из двоичной записи в десятичную. Здесь используется та же формула, но теперь она распространяется и на отрицательные индексы.<span class="math-tex">\(0b10.1011 = 1 \cdot 2^1 + 0 \cdot 2^0 + 1 \cdot 2^{-1} + 0 \cdot 2^{-2} + 1 \cdot 2^{-3} + 1 \cdot 2^{-4} = 2 + 0 + 0.5 + 0 + 0.125 + 0.0625 = 2.6875\)</span></p>

<p>Рассмотрим структуру стандартного типа данных с плавающей точкой: <code>float</code>. Он состоит из <code>32</code>-х бит:</p>

<ul>
	<li>1 бит — знак, как у целых чисел</li>
	<li>2-9 биты — порядок (exponent)</li>
	<li>10-32 биты — мантисса (fraction)</li>
</ul>

<p>Порядок кодируется таким же образом, как и целое беззнаковое число. Обозначим его как <span class="math-tex">\(A\)</span>. Мантисса кодирует дробное число, меньшее единицы: первый бит кодирует <span class="math-tex">\(\frac{1}{2}\)</span>, второй бит кодирует <span class="math-tex">\(\frac{1}{4}\)</span> и так далее. Обозначим его как <span class="math-tex">\(B\)</span>. Тогда значение числа равно <span class="math-tex">\(2^{A - 127} \cdot (1 + B)\)</span></p>

<p>Посмотрим на такое значение типа <code>float</code>: <code>0 01111100 01000000000000000000000</code></p>

<ul>
	<li>Первый бит равен <code>0</code>, поэтому число неотрицательное.</li>
	<li>В порядке стоит число <span class="math-tex">\(A = 0 \cdot 2^7 + 1 \cdot 2^6 + 1 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0 = 124\)</span></li>
	<li>В мантиссе стоит число <span class="math-tex">\(B = 0 \cdot \frac{1}{2^1} + 1 \cdot \frac{1}{2^2} + 0 \cdot \frac{1}{2^3} + 0 \cdot \frac{1}{2^4} + \ldots = 0.25\)</span></li>
	<li>Итого данное число равно <span class="math-tex">\(2^{124 - 127} \cdot (1 + 0.25) = 0.15625\)</span></li>
</ul>

<p>Есть отдельные два случая:</p>

<ul>
	<li>Если <span class="math-tex">\(A = 0\)</span>, то формула выглядит так: <span class="math-tex">\(2^{A - 127} \cdot B\)</span></li>
	<li>Если <span class="math-tex">\(A = 255\)</span>, то это особое число, соответствующее, например, бесконечности или <code>nan</code> (not a number), которые возникают при некоторых некорректных математических операциях. Чтобы проверить число на <code>nan</code> следует сравнить его с собой: <code>if (x != x) { "x is nan" }</code>.</li>
</ul>

<p>Чтобы использовать тип <code>float</code> в функциях <code>printf</code> и <code>scanf</code>, следует использовать формат <code>%f</code>.</p>

<p>Существуют и другие типы чисел с плавающей точкой:</p>

<ul>
	<li><code>double</code> — 8 байт</li>
	<li><code>long double</code> — не определено (обычно 10 байт)</li>
</ul><h3 id="1.6.5">1.6.5</h2>
<p>Ранее я рассказывал об отдельном способе кодирования числа типа <code>float</code>, когда его показатель равен нулю. Зачем это необходимо?</p><h3 id="1.6.6">1.6.6</h2>
<p>Перечисления (enumerations) — это способ задать числам идентификатор, привязав их при этом к контексту. Рассмотрим программу:</p>

<pre><code class="language-cpp">enum E {
    A,
    B,
    C = 10,
    D,
    E
};

int main() {
    enum E e = A;
    printf("%d %d %d %d %d %d\n", A, B, C, D, E, e);
    return 0;
}</code></pre>

<p>Мы объявляем перечисление с помощью ключевого слова <code>enum</code>, затем мы даем ему название <code>E</code> и в фигурных скобках перечисляем значение. Сами значения в перечислении используются так же, как и переменные типа число-константа <code>const int</code>. Эти значения мы можем вывести без ограничений, как и если бы это были константы. Посмотрите на логику присваивания значений им. Мы можем также объявлять объекты или инстансы (instances) перечисления, указывая их тип как <code>enum E</code>. Этот тип это всего лишь число.</p>

<p>Вывод этой программы: <code>0 1 10 11 12 0</code></p>

<p>Здесь может возникнуть вопрос: а где же привязка к контексту (названию перечисления), ведь их содержимое ведет себя как глобальные переменные? Этой привязки нет, что является недостатком перечислений в языке C. Тем не менее, в C++ были введены классы перечислений (enum classes), которые решают этот недостаток.</p>

<p>Перейдем к структурам (structures). Они необходимы для объединения группы переменных для того, чтобы манипулировать ими одновременно. В отличии от массивов, типы переменных в структурах разные, и их количество сильно ограничено.</p>

<pre><code class="language-cpp">struct S {
    int a;
    long long b;
};

int main() {
    struct S s1;
    s1.a = 4;
    s1.b = 7;
    printf("%d %d ", s1.a, s1.b);
    
    struct S *s2 = (struct S*)malloc(sizeof(struct S));
    (*s2).a = 12;
    s2-&gt;b = 17;
    printf("%d %d\n", s2-&gt;a, s2-&gt;b);
    free(s2);
    
    return 0;
}</code></pre>

<p>Мы объявляем структуру с помощью ключевого слова <code>struct</code>, следом за которым указываем название структуры и её содержимое в фигурных скобках. Объект или инстанс структуры объявляются с указыванием типа <code>struct S</code> и названия структуры: <code>struct S s1;</code>. Как только мы объявили этот объект, у нас появились сразу две связанные переменные, к которым мы обращаемся через идентификатор <code>struct</code>.  Хоть структуры и является сложным типом, их можно передавать в функции и возвращать из них. К полям (field) структуры мы обращаемся через символ <code>.</code>.</p>

<p>Можно объявлять объекты структуры динамически. Тогда, чтобы получить доступ к полям структуры, необходимо выполнить разыменование. Так как это распространенное действие (вы даже чаще будете взаимодействовать именно с указателями на структуры), для него есть свой синтаксис <code>-&gt;</code>.</p><h3 id="1.6.7">1.6.7</h2>
<p>Есть последовательность чисел, которая изначально состоит из единственного числа <span class="math-tex">\(0\)</span>, указатель, который изначально указывает на первую позицию последовательности, и счетчик <span class="math-tex">\(x\)</span>, изначально равный <span class="math-tex">\(1\)</span>.</p>

<p>Необходимо обработать <span class="math-tex">\(q\)</span> запросов четырех типов:</p>

<ol>
	<li>Сдвинуть указатель налево. Перед этим действием указатель находится не на первой позиции.</li>
	<li>Сдвинуть указатель направо. Перед этим действием указатель находится не на последней позиции.</li>
	<li>Вставить элемент <span class="math-tex">\(x\)</span> после указателя, а затем увеличить значение <span class="math-tex">\(x\)</span> на единицу.</li>
	<li>Удалить элемент, на который указывает указатель, сдвинув его на предыдущий элемент. Перед этим действием указатель находится не на первой позиции.</li>
</ol>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(q\)</span> (<span class="math-tex">\(1 \le q \le 1000\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(q\)</span> целых чисел <span class="math-tex">\(k_1, k_2, \ldots, k_q\)</span> (<span class="math-tex">\(1 \le k_i \le 4\)</span>) — запросы, которые необходимо обработать. Гарантируется, что запросы удовлетворяют ограничениям, указанным в условии.</p>

<h4>Формат вывода</h4>

<p>Выведите последовательность чисел после выполнения всех запросов.</p><h3 id="1.6.8">1.6.8</h2>
<p>Один из способов изменить битовую запись числа типа <code>float</code> напрямую следующий:</p>

<pre><code class="language-cpp">int main() {
    float a;
    int *b = (int*)(&amp;a);
    *b = 0x3FFFFFFF;
    printf("%f\n", a);
    return 0;
}</code></pre>

<p>(Попробуйте самостоятельно выяснить, какое число будет выведено.)</p>

<p>В C++ подобные манипуляции можно делать с помощью оператора <code>reinterpret_cast</code>. В C также можно сделать это с помощью объединений <code>union</code>.</p>

<p>Объединение реализует сумму типов (sum types), то есть её содержимое является одним из нескольких типов. Однако, в силу простоты языка C и того, как в нем объединения реализованы:</p>

<ul>
	<li>Узнать, какой тип храниться в конкретном объекте объединения, без дополнительной информации невозможно.</li>
	<li>Само обращение к объединению является лишь приведением одного и того же адреса в тип, который мы запрашиваем.</li>
</ul>

<p>Таким образом, объединения отличаются от просто приведения типа тем, что выбор типов ограничен, и у них есть псевдонимы.</p>

<pre><code class="language-cpp">union U {
    float a;
    int b;
};

int main() {
    union U u;
    u.b = 0x3FFFFFFF;
    printf("%f\n", u.a);
    return 0;
}</code></pre>

<p>Можно типам данных давать псевдонимы. Например, если мы напишем <code>typedef int i32;</code>, то мы сможем, написав <code>i32</code> создать переменную типа <code>int</code>: <code>i32 a = 3;</code>.</p>

<p>К перечислениям, структурам и объединения можно применять такой синтаксис:</p>

<pre><code class="language-cpp">typedef int i32;

typedef struct {
    i32 a;
} S;

int main() {
    S s;
    s.a = 7;
    return 0;
}</code></pre>

<p>При таком объявлении структуры мы не должны писать ключевое слово <code>struct</code> в типе.</p>
      </main>
    </div>
  </div>
</body>

</html>
