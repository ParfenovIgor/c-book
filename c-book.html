<!DOCTYPE html>

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">    
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <title>C - Язык Программирования</title>
  <style>      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }
      table ul {
        list-style-type: none;
        padding: 0em;
      }
      table li {
        padding-bottom: 1em;
        line-height:1.2em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.5em;
      }
      th[scope=row] {
          text-align: left;
          font-weight: normal;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      a:hover,a:focus {
        background: #fff2a8;
      }
      dt {
        font-weight: bold;
      }
      .sgr-1m {
        font-weight: bold;
      }
      .sgr-2m {
        color: #575757;
      }
      .sgr-31_1m {
        color: #b40000;
      }
      .sgr-32_1m {
        color: green;
      }
      .sgr-36_1m {
        color: #005C7A;
      }
      .file {
        font-weight: bold;
        border: unset;
      }
      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      samp {
        background: #fafafa;
      }
      pre > samp {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      kbd {
        font-weight: normal;
      }
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      figure {
        margin: auto 0;
      }
      figure pre {
        margin-top: 0;
      }

      figcaption {
        padding-left: 0.5em;
        font-size: small;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }
      figcaption.zig-cap {
        background: #fcdba5;
      }
      figcaption.c-cap {
        background: #a8b9cc;
        color: #000;
      }
      figcaption.peg-cap {
        background: #fcdba5;
      }
      figcaption.javascript-cap {
        background: #365d95;
        color: #fff;
      }
      figcaption.shell-cap {
        background: #ccc;
        color: #000;
      }

      aside {
        border-left: 0.25em solid #f7a41d;
        padding: 0 1em 0 1em;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      th pre code {
          background: none;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#121212;
            color: #ccc;
        }
        a {
            color: #88f;
        }
        a:hover,a:focus {
            color: #000;
        }
        table, th, td {
            border-color: grey;
        }
        .sgr-2m {
            color: grey;
        }
        .sgr-31_1m {
            color: red;
        }
        .sgr-32_1m {
            color: #00B800;
        }
        .sgr-36_1m {
            color: #0086b3;
        }
        code {
          background: #222;
          border-color: #444;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        samp {
          background: #000;
          color: #ccc;
        }
        pre > samp {
          border: unset;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        figcaption.zig-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.peg-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.shell-cap {
          background: #2a2a2a;
          color: #fff;
        }
      }
</style>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>


<body>
  <header><h1>C - Язык Программирования</h1></header>

  <div id="main-wrapper">
    <div id="navigation">        
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Содержание</h2>
        <ul>

<li><a href="#1">1. Введение</a><ul><li><a href="#1.1">1.1. Об этом курсе</a><ul><li><a href="#1.1.1">1.1.1. Об этом курсе</a></li></ul></li><li><a href="#1.2">1.2. О чём нужно знать</a><ul><li><a href="#1.2.1">1.2.1. Компилятор для C</a></li><li><a href="#1.2.2">1.2.2. Система</a></li></ul></li></ul></li><li><a href="#2">2. Вид сверху на C</a><ul><li><a href="#2.1">2.1. Введение</a><ul><li><a href="#2.1.1">2.1.1. Функция main</a></li><li><a href="#2.1.2">2.1.2. Функция puts</a></li><li><a href="#2.1.3">2.1.3. Локальные переменные и функция printf</a></li><li><a href="#2.1.4">2.1.4. Целочисленные типы данных</a></li><li><a href="#2.1.5">2.1.5. Арифметические и логические операторы</a></li><li><a href="#2.1.6">2.1.6. Задача: Вывести текст</a></li><li><a href="#2.1.7">2.1.7. Задача: Почему bool?</a></li><li><a href="#2.1.8">2.1.8. Задача: Какой размер у int?</a></li></ul></li><li><a href="#2.2">2.2. Контроль потока</a><ul><li><a href="#2.2.1">2.2.1. Statements и Expressions</a></li><li><a href="#2.2.2">2.2.2. Control Flow, if</a></li><li><a href="#2.2.3">2.2.3. Функция scanf</a></li><li><a href="#2.2.4">2.2.4. Задача: На if</a></li><li><a href="#2.2.5">2.2.5. Циклы while и do while</a></li><li><a href="#2.2.6">2.2.6. Цикл for</a></li><li><a href="#2.2.7">2.2.7. Задача: Запутанный for</a></li><li><a href="#2.2.8">2.2.8. break, continue и goto</a></li><li><a href="#2.2.9">2.2.9. switch case default</a></li><li><a href="#2.2.10">2.2.10. Задача: На цикл</a></li></ul></li><li><a href="#2.3">2.3. Функции</a><ul><li><a href="#2.3.1">2.3.1. Функции</a></li><li><a href="#2.3.2">2.3.2. Аргументы программы argv</a></li><li><a href="#2.3.3">2.3.3. Прототипы</a></li><li><a href="#2.3.4">2.3.4. Задача: Набор простых функций</a></li><li><a href="#2.3.5">2.3.5. Функции с переменным количеством аргументов</a></li><li><a href="#2.3.6">2.3.6. Задача: Набор простых функций с переменным количеством аргументов</a></li><li><a href="#2.3.7">2.3.7. Задача: Найти уязвимость</a></li></ul></li><li><a href="#2.4">2.4. Указатели</a><ul><li><a href="#2.4.1">2.4.1. Объявления указателей, разыменование</a></li><li><a href="#2.4.2">2.4.2. Массивы</a></li><li><a href="#2.4.3">2.4.3. Указатели и массивы</a></li><li><a href="#2.4.4">2.4.4. Задача: Написать любую сортировку</a></li><li><a href="#2.4.5">2.4.5. Динамическое выделение памяти</a></li><li><a href="#2.4.6">2.4.6. Задача: Найти ошибки при работе с указателями</a></li><li><a href="#2.4.7">2.4.7. Задача: Написать сортировку слиянием</a></li><li><a href="#2.4.8">2.4.8. Многомерные динамические массивы</a></li><li><a href="#2.4.9">2.4.9. Задача: На обход граф</a></li><li><a href="#2.4.10">2.4.10. Константы</a></li><li><a href="#2.4.11">2.4.11. Задача: Сигнатура у функции execv</a></li></ul></li><li><a href="#2.5">2.5. Строки</a><ul><li><a href="#2.5.1">2.5.1. Представление строки, функция strlen</a></li><li><a href="#2.5.2">2.5.2. Задача: Почему ошибка исполнения?</a></li><li><a href="#2.5.3">2.5.3. Функции sprintf, strcpy, strncpy</a></li><li><a href="#2.5.4">2.5.4. Функции strcmp, atoi, strdup</a></li><li><a href="#2.5.5">2.5.5. Задача: Написать строковые функции</a></li><li><a href="#2.5.6">2.5.6. Функция strtok</a></li><li><a href="#2.5.7">2.5.7. Задача: Написать токенизирующую функцию</a></li><li><a href="#2.5.8">2.5.8. Функции mem***</a></li></ul></li><li><a href="#2.6">2.6. Структуры</a><ul><li><a href="#2.6.1">2.6.1. Кодирование целых чисел</a></li><li><a href="#2.6.2">2.6.2. Битовые операторы</a></li><li><a href="#2.6.3">2.6.3. Задача: На перебор масок</a></li><li><a href="#2.6.4">2.6.4. Кодирование вещественных чисел</a></li><li><a href="#2.6.5">2.6.5. Задача: О кодировании вещественных чисел</a></li><li><a href="#2.6.6">2.6.6. Перечисления enum и структуры struct</a></li><li><a href="#2.6.7">2.6.7. Задача: На связный список</a></li><li><a href="#2.6.8">2.6.8. Объединения union, typedef</a></li></ul></li><li><a href="#2.7">2.7. Функции высшего порядка, макросы, шаблоны</a><ul><li><a href="#2.7.1">2.7.1. Функции высшего порядка</a></li><li><a href="#2.7.2">2.7.2. Задача: О вложенных функциях</a></li><li><a href="#2.7.3">2.7.3. Макросы</a></li><li><a href="#2.7.4">2.7.4. Макросы для обобщённого программирования</a></li><li><a href="#2.7.5">2.7.5. Задача: Написать обобщённыю функцию</a></li><li><a href="#2.7.6">2.7.6. Имитация наследования</a></li><li><a href="#2.7.7">2.7.7. Задача: Что ещё можно сымитировать?</a></li></ul></li></ul></li><li><a href="#3">3. Компиляция, gcc</a><ul><li><a href="#3.1">3.1. Фазы компиляции</a><ul><li><a href="#3.1.1">3.1.1. Фазы компиляции</a></li><li><a href="#3.1.2">3.1.2. Препроцессирование</a></li><li><a href="#3.1.3">3.1.3. Компиляция</a></li><li><a href="#3.1.4">3.1.4. Ассемблирование</a></li><li><a href="#3.1.5">3.1.5. Компоновка</a></li><li><a href="#3.1.6">3.1.6. Задача: О памяти</a></li></ul></li><li><a href="#3.2">3.2. Многомодульные программы</a><ul><li><a href="#3.2.1">3.2.1. Прототипы и реализации функций</a></li><li><a href="#3.2.2">3.2.2. Заголовочные файлы</a></li><li><a href="#3.2.3">3.2.3. Header Guards</a></li><li><a href="#3.2.4">3.2.4. Библиотеки .a</a></li><li><a href="#3.2.5">3.2.5. Shared Objects .so</a></li><li><a href="#3.2.6">3.2.6. Задача: Нужны ли заголовочные файлы?</a></li></ul></li><li><a href="#3.3">3.3. GNU make</a><ul><li><a href="#3.3.1">3.3.1. Мотивация системы сборки</a></li><li><a href="#3.3.2">3.3.2. Простые рецепты</a></li><li><a href="#3.3.3">3.3.3. Зависимости в рецептах</a></li><li><a href="#3.3.4">3.3.4. Распараллеливание</a></li><li><a href="#3.3.5">3.3.5. Автоматический поиск файлов</a></li><li><a href="#3.3.6">3.3.6. Вложенные Makefiles</a></li><li><a href="#3.3.7">3.3.7. Задача: Улучшение структуры Makefiles</a></li><li><a href="#3.3.8">3.3.8. Задача: Как быть с заголовочными файлами?</a></li><li><a href="#3.3.9">3.3.9. Проект: Программа со структурой</a></li></ul></li></ul></li><li><a href="#4">4. Unix</a><ul><li><a href="#4.1">4.1. Shell</a><ul><li><a href="#4.1.1">4.1.1. Терминал и простые cli программы</a></li><li><a href="#4.1.2">4.1.2. Фоновые процессы</a></li><li><a href="#4.1.3">4.1.3. Потоки Streams</a></li><li><a href="#4.1.4">4.1.4. Аргументы программы и переменные среды</a></li><li><a href="#4.1.5">4.1.5. Код возврата процесса</a></li><li><a href="#4.1.6">4.1.6. Задача: Мини grep</a></li><li><a href="#4.1.7">4.1.7. Скрипты, Shebang</a></li><li><a href="#4.1.8">4.1.8. Статистика процессов</a></li><li><a href="#4.1.9">4.1.9. Задача: A + B на shell</a></li><li><a href="#4.1.10">4.1.10. Проект: Judge System</a></li></ul></li><li><a href="#4.2">4.2. Системные вызовы</a><ul><li><a href="#4.2.1">4.2.1. Системный вызов fork</a></li><li><a href="#4.2.2">4.2.2. Задача: fork-последовательность</a></li><li><a href="#4.2.3">4.2.3. Системный вызов exec</a></li><li><a href="#4.2.4">4.2.4. Системные вызовы open, read, write</a></li><li><a href="#4.2.5">4.2.5. Задача: Действия с файлами</a></li><li><a href="#4.2.6">4.2.6. Системный вызов pipe</a></li><li><a href="#4.2.7">4.2.7. Потоки Threads</a></li><li><a href="#4.2.8">4.2.8. Задача: Делегация обязанностей</a></li><li><a href="#4.2.9">4.2.9. Семафоры</a></li><li><a href="#4.2.10">4.2.10. Сигналы и обработчики сигналов</a></li><li><a href="#4.2.11">4.2.11. Проект: Shell</a></li></ul></li><li><a href="#4.3">4.3. Файловая система</a><ul><li><a href="#4.3.1">4.3.1. Монтирование</a></li><li><a href="#4.3.2">4.3.2. Loop Device</a></li><li><a href="#4.3.3">4.3.3. Разделы дисков Disk Partitions</a></li><li><a href="#4.3.4">4.3.4. Задача: формат GPT</a></li><li><a href="#4.3.5">4.3.5. Loop Devices и разделы</a></li><li><a href="#4.3.6">4.3.6. Задача: Манипуляции с диском при установке ОС</a></li><li><a href="#4.3.7">4.3.7. Системный вызов chroot</a></li><li><a href="#4.3.8">4.3.8. Проект: Containerization</a></li></ul></li></ul></li><li><a href="#5">5. Assembly</a><ul><li><a href="#5.1">5.1. Регистры, базовые инструкции</a><ul><li><a href="#5.1.1">5.1.1. Мотивация языка ассемблера</a></li><li><a href="#5.1.2">5.1.2. Структура кода на языке ассемблера</a></li><li><a href="#5.1.3">5.1.3. Дебаггер gdb</a></li><li><a href="#5.1.4">5.1.4. Инструкции mov и lea</a></li><li><a href="#5.1.5">5.1.5. Задача: Об инструкции lea</a></li><li><a href="#5.1.6">5.1.6. Разрядность</a></li><li><a href="#5.1.7">5.1.7. Как читать машинный код</a></li><li><a href="#5.1.8">5.1.8. Задача: Прочитать код инструкции</a></li><li><a href="#5.1.9">5.1.9. Синтаксис языка ассемблера</a></li><li><a href="#5.1.10">5.1.10. Арифмитические инструкции и флаги, как читать ISA</a></li><li><a href="#5.1.11">5.1.11. Control Flow</a></li><li><a href="#5.1.12">5.1.12. Задача: Написать циклы</a></li><li><a href="#5.1.13">5.1.13. Инструкции для строк и массивов</a></li><li><a href="#5.1.14">5.1.14. Задача: strcpy</a></li></ul></li><li><a href="#5.2">5.2. Application Binary Interface</a><ul><li><a href="#5.2.1">5.2.1. Функции и стек</a></li><li><a href="#5.2.2">5.2.2. Вызов функций в 32-bit</a></li><li><a href="#5.2.3">5.2.3. Задача: На цикл, но на языке ассемблера с libc</a></li><li><a href="#5.2.4">5.2.4. System V ABI</a></li><li><a href="#5.2.5">5.2.5. Вызов функций в 64-bit, системный вызов</a></li><li><a href="#5.2.6">5.2.6. Задача: Системный вызов exit</a></li><li><a href="#5.2.7">5.2.7. Системные вызовы fork, read, write</a></li><li><a href="#5.2.8">5.2.8. Задача: На цикл, но на языке ассемблера без libc</a></li><li><a href="#5.2.9">5.2.9. Анализ вывода компилятора gcc в 64-bit</a></li><li><a href="#5.2.10">5.2.10. Анализ вывода компилятора gcc в 32-bit</a></li><li><a href="#5.2.11">5.2.11. Проект: Компилятор</a></li></ul></li><li><a href="#5.3">5.3. Компоновка</a><ul><li><a href="#5.3.1">5.3.1. Немного reverse engineering-а</a></li><li><a href="#5.3.2">5.3.2. Задача: Своя реализация функций для системных вызовов</a></li><li><a href="#5.3.3">5.3.3. Перегрузка и экранирование символов в C++</a></li><li><a href="#5.3.4">5.3.4. Анализ секций</a></li><li><a href="#5.3.5">5.3.5. Анализ сегментов</a></li><li><a href="#5.3.6">5.3.6. Задача: О Position Independent Code</a></li><li><a href="#5.3.7">5.3.7. Эксперименты с секциями</a></li><li><a href="#5.3.8">5.3.8. Linker Scripts и секции</a></li><li><a href="#5.3.9">5.3.9. Linker Scripts и сегменты</a></li><li><a href="#5.3.10">5.3.10. Задача: Написать Linker Script</a></li><li><a href="#5.3.11">5.3.11. Задача: Языки ассемблеров других архитектур</a></li></ul></li><li><a href="#5.4">5.4. Введение в Embedded Programming</a><ul><li><a href="#5.4.1">5.4.1. О написании операционных систем</a></li><li><a href="#5.4.2">5.4.2. Простейшее ядро, запускающееся grub-ом, и демонстрирующее VESA</a></li><li><a href="#5.4.3">5.4.3. Задача: Конфигурация grub-а с несколькими ядрами</a></li><li><a href="#5.4.4">5.4.4. Отладка с gdb. Немного о Real Mode и Protected Mode</a></li><li><a href="#5.4.5">5.4.5. Использование языка C</a></li><li><a href="#5.4.6">5.4.6. Задача: Функции вывода текста</a></li><li><a href="#5.4.7">5.4.7. Настройка прерываний Interrupts 1</a></li><li><a href="#5.4.8">5.4.8. Настройка прерываний Interrupts 2, исключения Exceptions</a></li><li><a href="#5.4.9">5.4.9. Задача: Обработчики прерываний</a></li><li><a href="#5.4.10">5.4.10. Задача: Простейшие ядра на других архитектурах</a></li></ul></li></ul></li>
        </ul>
      </nav>
    </div>

    <div id="contents-wrapper">
      <main id="contents">

<h2 id="1">1. Введение</h2><h3 id="1.1">1.1. Об этом курсе</h3><h3 id="1.1.1">1.1.1. Об этом курсе</h3><p>Здравствуй, уважаемый читатель. Добро пожаловать на курс по языку программирования C. Однако, скорее всего, если ты ещё не погружен в эту тему, этот курс окажется намного глубже, чем ты сейчас ожидаешь. Здесь мы не ограничимся только такими вещами, как типы данных, ветвления, функции и указатели, а лишь начнём с этого.</p>

<p>Попробуем подумать над такой идеей — а зачем нужен язык C? При поверхностном взгляде на него кажется, что у него нет таких сторон, с которых его бы не обходил какой-либо другой язык. Когда мы должны его использовать? Ответ — когда мы не можем развернуть среду для других языков. Язык C очень независимый. Полностью регулировать зависимости програм, написанных на нём, очень просто. То же самое касается и структуры результирующих программ. А это означает, что изучать язык C без понимания о том, как управлять процессом компиляции, не имеет смысла.</p>

<p>Немного о том, как следует работать с этим курсом. Если вы уже можете компилировать и запускать программы на C на какой-либо системе — можете сразу переходить к модулю <em>Вид сверху на C</em>, минуя пункт 1.2. Даже если вы уже знаете заявленный там контент, всё равно есть смысл пролистать текст, так как в нём есть полезные идеи. После завершения изучения этого модуля читайте пункт 1.2, который расскажет о том, как получить необходимую для нашей работы среду, и переходите к остальным модулям.</p>

<p>Мне было лень писать большое количество текста, поэтому информация в тексте очень концентрированная. Убедитесь, что вы понимаете каждую идею, которую я даю в тексте. То же самое касается и заданий — обычно это не просто вопросы к тексту параграфа, а задачи, требующие изучения и обдумывания какой-либо идеи. Иногда в качестве заданий будут даваться проекты, которые дают большую свободу действий.</p><h3 id="1.2">1.2. О чём нужно знать</h3><h3 id="1.2.1">1.2.1. Компилятор для C</h3><p>На протяжении первого модуля допустимо использовать любые компиляторы и любые IDE, а также online компиляторы, например, <a href="https://godbolt.org/" rel="noopener noreferrer nofollow">godbolt</a> (обратите внимание на количество доступных компиляторов там).</p>

<p>Для удобства мы будем работать с операционной системой <code>Linux</code>, так как она имеет более простой и сильный <code>shell</code>, более простое и понятное внутреннее устройство, которое мы также будем изучать, и более удобные необходимые нам инструменты.</p>

<p>Важно определить и понять, какие компиляторы мы будем использовать. Хоть и с верхней стороны язык C в них идентичен, с нижней стороны они могут сильно отличаться. Я выбрал компилятор <code>gcc</code>. Это стандартный компилятор в системах <code>Linux</code>, и в большинстве дистрибутивов он установлен изначально.</p>

<p>На <code>Windows</code> имеется компилятор <code>mingw</code>, который заявлен, как порт gcc на Windows. Его можно установить, например, вместе с <code>IDE</code> <code>Codeblocks</code>, а затем добавить исполняемый файл в переменную PATH.</p>

<p>Идея курса в "сквозном" изучении компилятора gcc, поэтому разрешается пользоваться IDE только в течении первого модуля. Далее мы будем запускать gcc только с помощью терминала. До начала второго модуля убедитесь, что gcc доступен в терминале.</p>

<p>Существуют альтернативные компиляторы, которые имеет смысл изучить, но которые не будут покрыты данным курсом.</p>

<ul>
	<li><code>MSVC</code>. О данном компиляторе мне известно мало. Он предназначен только для Windows, и с его установкой могут быть проблемы.</li>
	<li><code>Clang</code>. Данный компилятор имеет другой "путь" компиляции, в процессе которого используется язык <code>llvm</code>. Предназначен для обеих ОС.</li>
	<li><code>Zig</code>. Помимо того, что zig является отдельным языком, его компилятор является хорошей альтернативой другим компиляторам языка C.</li>
</ul><h3 id="1.2.2">1.2.2. Система</h3><p>В случае, если ваша основная операционная система — Windows, прочитайте этот раздел.</p>

<p>Все дистрибутивы Linux без проблем позволяют поставить на один диск (HDD/SSD) несколько ОС Linux. В таком случае при запуске компьютера будет загружаться сначала <code>загрузчик</code> (обычно, <code>grub</code>), который будет спрашивать у вас, какую ОС на этот раз загрузить. Однако установка к Linux-у на диск ОС Windows, насколько мне известно, является нестабильным способом, так как Windows иногда затирает загрузчик Linux-а.</p>

<p>Возможные способы:</p>

<ul>
	<li>Если у вас имеется дополнительный диск (HDD/SSD), можете поставить на него вторую ОС. При такой установке Windows не будет трогать другой диск (а в некоторых вариантах установки даже и не сможет его видеть). Так как вы ставите Linux к уже рабочей Windows, либо выберите дистрибутив с хорошим GUI (например, <code>Ubuntu</code>), либо попросите помощи, чтобы случайно не затереть не тот диск.</li>
	<li>Если на вашем компьютере есть хотя бы 8 Gb <code>RAM</code> (оперативной памяти), вы можете поставить виртуальную машину. Я рекомендую программу <code>VirtualBox</code>. В ней выделите виртуальной машине примерно половину своей оперативной памяти, не менее двух процессорных ядер и не менее 30 Gb дисковой памяти (если вы знаете свой дистрибутив, этот размер может быть намного меньше). Лучше поставьте легковесный <code>DE</code> (desktop environment), например, XFCE.</li>
	<li><code>WSL</code>, однако я им никогда не пользовался и ничего о нём не знаю.</li>
</ul>

<p>Что не рекомендуется:</p>

<ul>
	<li>Ставить Linux на один диск с Windows (но может, кто-то сможет убедить меня в обратном)</li>
	<li>Использовать Cygwin. У этого способа виртуализации большие проблемы с пакетами.</li>
	<li>Использовать не аппаратную виртуализацию (например, <code>QEMU</code> имеет аппаратную виртуализацию только на Linux).</li>
</ul>

<p>Возможные проблемы с <code>VirtualBox</code>:</p>

<ul>
	<li>Зависания машины намертво. Это происходит из-за того, как VirtualBox эмулирует диск. Вы можете заметить, что на гостевой ОС заканчивается Swap, а на хостовой ОС потребление диска возрастает до 100%. К сожалению, это не лечится.</li>
	<li>Ошибки запуска виртуальной ОС после неудачного завершения работы (например, вхождения в гибернацию). Оставьте файл диска (его расширение — <code>.vdi</code>), а остальное удалите. Создайте новую машину и добавьте в неё этот файл диска.</li>
	<li>Медленная работа. Это означает, что VirtualBox перешел в программную виртуализацию (в этом случае внизу-справа показывается иконка черепахи, вместо иконки чипа). Это может произойти из-за того, что вы поставили <code>Hyper-V</code> и он занял гипервизор процессора. Удалите Hyper-V.</li>
</ul><h2 id="2">2. Вид сверху на C</h2><h3 id="2.1">2.1. Введение</h3><h3 id="2.1.1">2.1.1. Функция main</h3><p>Рассмотрим простейшую однофайловую программу на C:</p>

<pre><code class="language-cpp">int main() {
    return 0;
}</code></pre>

<p>Здесь определена функция под названием <code>main</code>. <code>int main()</code> — это сигнатура функции. По ней мы видим, что функция не принимает аргументов, так как круглые скобки ничего не содержат, и возвращает тип <code>int</code> — целое число. В фигурных скобках содержится тело функции, которое содержит лишь один <em>statement </em> <code>return 0</code>, который завершает выполнение функции, возвращая значение <code>0</code>. Пока можно сильно не задумываться обо всем вышенаписанном, мы вернемся к функциям с большими подробностями позже.</p><h3 id="2.1.2">2.1.2. Функция puts</h3><p>Сложно анализировать выполнение программы не имея возможности ввода и вывода. Научимся выводить. Первой функцией для вывода будет <code>int puts(const char *str)</code>. Давайте изучим её сигнатуру.</p>

<p>Во-первых, функция принимает один аргумент типа <code>const char *str</code>. Пока не будем расшифровывать этот сложный тип, и поверим, что это строка, известная на этапе компиляции (то есть, мы не сможем её сформировать интерактивно). Очевидно эта строка будет напечатана. Позже мы узнаем, что такое потоки <em>streams</em>, пока будем считать, что вывод идет в консоль.</p>

<p>Во-вторых, функция возвращает тип <code>int</code>, и, если мы посмотрим в документацию <em>cppreference</em>, мы увидим, что то, что она возвращает, описано с большой свободой.</p>

<blockquote>
<p>On success, returns a non-negative value.</p>

<p>On failure, returns <a href="https://en.cppreference.com/w/c/io" rel="noopener noreferrer nofollow" title="c/io">EOF</a> and sets the <em>error</em> indicator (see <a href="https://en.cppreference.com/w/c/io/ferror" rel="noopener noreferrer nofollow" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p>
</blockquote>

<p>В свою очередь: </p>

<blockquote>
<table>
	<tbody>
		<tr>
			<td>
			<p>EOF</p>
			</td>
			<td>integer constant expression of type int and negative value</td>
		</tr>
	</tbody>
</table>
</blockquote>

<p>Такую картину мы будем видеть во многих функциях. Можно посмотреть и <code>ferror()</code>, но нам это пока неинтересно.</p>

<p>Давайте, наконец, напечатаем что-либо.</p>

<pre><code class="language-cpp">int main() {
    puts("Hello");
    puts("Test");
    return 0;
}</code></pre>

<p>Обратите внимание: в этой программе я не написал <code>#include &lt;stdio.h&gt;</code>, чтобы добавить файл <code>stdio.h</code>, несмотря на то, что так обычно делают. Дело в том, что мы пока не понимаем, что такое <code>#include</code>, но он и не нужен. Вы получите предупреждение о том, что <code>puts</code>не был объявлен, но исполняемый файл вы все равно получите.</p>

<p>При запуске этой программы будет выполнена функция <code>main</code>, в которой будет вызвана функция <code>puts("Hello")</code>, в результате чего будет выполнена печать строки <em>Hello</em> и перевод строки, а затем будет вызвана функция <code>puts("Test")</code>, в результате чего будет выполнена печать строки <em>Test</em> и перевод строки.</p><h3 id="2.1.3">2.1.3. Локальные переменные и функция printf</h3><p>Научимся работать с локальными переменными, а заодно и выводить числа. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a;
    int b = 2 + 3;
    b = a + 8;
    printf("%d %s %d\n", a, "Hello", b + 7);
    return 0;
}</code></pre>

<p>В первой строке тела функции <code>main</code> мы объявляем <em>declare</em> переменную типа <code>int</code> с именем <code>a</code>. Мы не присваиваем <em>define</em> её. Её значение на этом моменте будет не определено. Какое значение получит переменная <code>a</code> мы узнаем позже.</p>

<p>Во второй строке мы объявляем <em>declare</em> и сразу определяем <em>define</em> переменную типа <code>int</code> с именем <code>b</code>. Мы присваиваем ей значение <code>5</code>.</p>

<p>В третьей строке мы переопределяем значение переменной <code>b</code>. Так как при вычислении её значения используется неопределённая переменная <code>a</code>, теперь значение переменной <code>b</code> тоже не определено.</p>

<p>В четвертой строке вы используем новую, намного более сложную функцию — <code>printf</code>. Это функция с неопределённым количеством аргументов (variadic functions, vararg, ellipsis). Первый её аргумент — это строка, задающая формат. Он имеет достаточно богатые возможности, и мы будем ими пользоваться по мере необходимости. Пока остановимся на том, что подстроки <code>%d</code> будут заменены на число в следующем по счету аргументе, подстроки <code>%s</code> будут заменены на строку в следующем по счету аргументе (первый <code>%d</code> заменится на аргумент <code>a</code>, <code>%s</code> заменится на аргумент <code>"Hello"</code>, второй <code>%d</code> заменится на аргумент <code>b + 7</code>), а <code>\n</code> обозначает символ перехода строки line feed (другие подобные символы мы увидим позже).</p>

<p>Определить вывод этой программы наперед не получится, так как значения переменных зависят от компилятора. В будущем мы часто будем с этим сталкиваться.</p><h3 id="2.1.4">2.1.4. Целочисленные типы данных</h3><p>Рассмотрим базовые типы данных, которые нам в ближайшее время могут пригодиться.</p>

<ul>
	<li><code>int</code> — целые числа, на хранение которых выделяется <code>4</code> байта</li>
	<li><code>short</code> — целые числа, на хранение которых выделяется <code>2</code> байта</li>
	<li><code>char</code> — целые числа, на хранение которых выделяется <code>1</code> байт</li>
	<li><code>long long</code> — целые числа, на хранение которых выделяется <code>8</code> байт</li>
	<li><code>long</code> — целые числа, на хранение которых выделяется ?? байт</li>
</ul>

<p>Помимо этих типов, нам понадобится <code>const char*</code>.</p>

<p>Интересная ситуация с логическим типом <code>_Bool</code> — он был введён не сразу, и в многих программах вводили тип с названием <code>bool</code> самостоятельно с помощью препроцессора, поэтому и было выбрано такое странное название. Логический тип имеет лишь два значения: <code>true</code> и <code>false</code>. (На самом деле, размер этого типа <code>1</code> байт, и <code>false</code> соответствует числу <code>0</code>, в то время как <code>true</code> всем остальным.)</p>

<p>Размер типа <code>long</code> в свою очередь зависит от системы. На <em>Windows</em> он равен 4, а на <em>Linux</em> он равен 8. В целом, встроенные типы не описывают нормально свою размерность, как в языках <em>Rust</em> и <em>Zig</em>, и это бывает проблемой.</p>

<p>Про указатели мы поговорим позже.</p>

<p>С помощью оператора <code>sizeof(x)</code> можно узнать размер типа в байтах, причём в качестве аргумента можно использовать как тип, так и переменную или значение.</p>

<pre><code class="language-cpp">int main() {
    printf("int: %d\n", sizeof(int));
    printf("short: %d\n", sizeof(short));
    printf("char: %d\n", sizeof(char));
    printf("long long: %d\n", sizeof(long long));
    printf("long: %d\n", sizeof(long));
    printf("const char*: %d\n", sizeof(const char*));
    
    const char *str = "Hello";
    printf("const char*: %d\n", sizeof(str));
    return 0;
}</code></pre><h3 id="2.1.5">2.1.5. Арифметические и логические операторы</h3><p>Изучим несколько базовых операторов.</p>

<ol>
	<li><code>+</code> — оператор сложения, складывает два числа. <code>2 + 3</code> равно <code>5</code>.</li>
	<li><code><span style="color: #000000;">-</span></code> — оператор вычитания, вычитает второе число из первого. <code>5 - 3</code> равно <code><span style="color: #000000;">2</span></code>.</li>
	<li><code><span style="color: #000000;">*</span></code> — оператор умножения, умножает два числа. <code>2 * 3</code> равно <code><span style="color: #000000;">6</span></code>.</li>
	<li><code><span style="color: #000000;">/</span></code> — оператор деления, делит первое число на второе с округлением вниз. <code><span style="color: #000000;">5 / 2</span></code> равно <code><span style="color: #000000;">2</span></code>. <code><span style="color: #000000;">6 / 2</span></code> равно <code><span style="color: #000000;">3</span></code>.</li>
	<li><code>%</code> — оператор остатка от деления, делит первое число на второе и даёт остаток от деления. <code><span style="color: #000000;">5 % 2</span></code> равно <code>1</code>. <code><span style="color: #000000;">6 % 2</span></code> равно <code>0</code>.</li>
</ol>

<p>Если второй аргумент у операторов <code>/</code> и <code>%</code> будет равен <code>0</code>, то программа завершится с ошибкой. Какие при этом механизмы происходят, мы узнаем позже.</p>

<p>Также у этих операторов есть странная особенность: на самом деле они округляют не вниз, а к нулю, что может быть неприятным сюрпризом, если в ваших промежуточных вычислениях будут получаться отрицательные числа. Например <code>-5 / 2</code> равно <code>-1</code> и <code>-5 % 3</code> равно <code>-2</code>.</p>

<p>Имейте ввиду, что значения чисел в C ограничены, и при их переполнении вы не получите никаких предупреждений или ошибок. (Когда такое происходит, процессор ставит флаг переполнения, но компилятор C для скорости даже не смотрит на него.) Например, <code>2000000000 + 2000000000</code> равно <code>-294967296</code>.</p>

<p>Помимо арифметических операторов существуют логические операторы для создания сложных условий.</p>

<ol>
	<li><code>&amp;&amp;</code> или <code>and</code> — оператор И, который возвращает <code>1</code>, если оба аргумента не равны нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>||</code> или <code>or</code> — оператор ИЛИ, который возвращает <code>1</code>, если хотя бы один аргумент не равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>!</code> — унарный оператор НЕ, который возвращает <code>1</code>, если аргумент равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>==</code> — оператор равенства, который возвращает <code>1</code>, если аргументы равны, и возвращает <code>0</code> в противном случае.</li>
</ol>

<pre><code class="language-cpp">int main() {
    printf("%d ", 3 + 4);
    printf("%d ", 17 % 7);
    printf("%d ", 3 &amp;&amp; 0);
    printf("%d ", 3 || 0);
    printf("%d ", !4);
    printf("%d ", 5 == 5);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>7 3 0 1 0 1 </code></p><h3 id="2.1.6">2.1.6. Задача: Вывести текст</h3><p>Напишите программу, которая выведет следующий текст:</p>

<pre><code>123
abracadabra
2 + 5 = 7
ababba</code></pre><h3 id="2.1.7">2.1.7. Задача: Почему bool?</h3><p>Напомним, что в C не сразу был введён логический тип данных <code>_Bool</code>. Однако при этом также есть возможность получить "тип" <code>bool</code>, добавив файл <code>#include &lt;stdbool.h&gt;</code>. (На самом деле, это не совсем тип.)</p>

<p>Как думаете, зачем этот файл был добавлен?</p><h3 id="2.1.8">2.1.8. Задача: Какой размер у int?</h3><p>Пока эту задачу можно пропустить, и вернуться к ней намного позднее.</p>

<p>Я немного наврал, когда сказал, что размер типа <code>int</code> — 4 байта. Это не так при компиляции в разрядности ниже, чем 32 bit. Однако современные компиляторы не имеют возможности компилировать в такие разрядности, поэтому это не является проблемой. Можно попробовать найти древний компилятор (например, Open Watcom), который может компилировать в разрядность 16 bit, и проверить <code>sizeof(int)</code> в таком режиме.</p><h3 id="2.2">2.2. Контроль потока</h3><h3 id="2.2.1">2.2.1. Statements и Expressions</h3><p>Начнём с введения нескольких терминов. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a = 5 + 8;
    puts("123");
    int b = puts("456");
    return 0;
}</code></pre>

<p>Тело функции <code>main</code> состоит из четырёх действий: объявление переменной <code>a</code>, вызов функции <code>puts("123")</code>, объявление переменной <code>b</code>, возвращение значения <code>0</code>. Каждое из этих действий называется <em>statement</em>.</p>

<p>Посмотрим на первый statement: <code>int a = 5 + 8</code>. Часть <code>5 + 8</code> называется <em>expression</em>. Часть этого expression-а <code>5</code> тоже является expression-ом. В третьем statement-е вызов функции <code>puts("456")</code> также является expression-ом (в то время, как другой вызов этой же функции был statement-ом).</p>

<p>Есть проблема в терминологии: оба этих слова не имеют перевода на русский язык, и обычно их называют одним словом <em>выражение</em>. Позже, когда мы будем более подробно изучать синтаксис, мы увидим смысл такого разделения.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>statement</td>
			<td>expression</td>
		</tr>
		<tr>
			<td>Исполняются сверху вниз</td>
			<td>Порядок исполнения не определён</td>
		</tr>
		<tr>
			<td>Не имеют конечного значения</td>
			<td>Имеют конечное значение (а потому и тип)</td>
		</tr>
		<tr>
			<td>Имеют side effect</td>
			<td>По хорошему, не должны иметь side effect</td>
		</tr>
	</tbody>
</table>

<p><em>Side effect</em> означает, что исполнение фрагмента кода приведет к изменению чего либо за его пределами (изменятся внешние переменные; что-то запишется в память, доступную из внешних переменных; выполнится системный вызов и т.д.).</p><h3 id="2.2.2">2.2.2. Control Flow, if</h3><p>Control Flow (контроль потока) — это набор statement-ов в языке, которые определяют последовательность выполнения statement-ов.</p>

<p>Пока мы видели следующие типы statement-ов:</p>

<ul>
	<li>Declaration (объявление): <code>int a</code>. Объявление также может быть с присваиванием/определением (по сути, это то же самое, но термин определение в других языках может налагать ограничения):<span style="color: #000000;"> <code>int a = 5</code></span>.</li>
	<li>Assignment/Definition (присваивание/определение): <code>a = 5 + 2</code>.</li>
	<li>Function Call (вызов функции): <code>puts("123")</code>.</li>
	<li>Function Return (возврат из функции): <code>return 2 + puts("456")</code>.</li>
</ul>

<p>Конечно, хочется иметь вариативность в порядке исполнения statement-ов. Делать это можно с помощью ветвлений и циклов, которые являются control flow statements.</p>

<p>Посмотрим на <code>if</code>:</p>

<pre><code class="language-cpp">int main() {
    int a = 4;
    if (a - 4) {
        puts("1");
    }
    else if (a) puts("2");
    else {
        puts("3");
    }
    return 0;
}</code></pre>

<p>Данный <code>if</code> statement состоит из трех ветвей. Эти ветви надо читать так:</p>

<ol>
	<li>Если <code>a - 4</code> не <code>0</code>, то выполнить <code>puts("1")</code> и завершить выполнение <code>if</code></li>
	<li>Если <code>a</code> не <code>0</code>, то выполнить <code>puts("2")</code> и завершить выполнение <code>if</code></li>
	<li>Выполнить <code>puts("3")</code></li>
</ol>

<p>Обратите внимание на следующие вещи:</p>

<ul>
	<li>Можно как обрамлять блок в <code>if</code> в фигурные скобки, так и не делать этого.</li>
	<li>В качестве условия в <code>if</code> должен быть expression, а его тип неважен. Проверка идет лишь на то, что он не <code>0</code>. А в языке C по сути любой тип данных — число.</li>
	<li>Веток <code>else if</code> и <code>else</code> может не быть. Количество веток <code>else if</code> не ограничено.</li>
</ul>

<p>В результате выполнения этой программы будет напечатано единственное число <code>2</code>.</p><h3 id="2.2.3">2.2.3. Функция scanf</h3><p>Вскоре нам потребуется начать решать input/output задачи для проверки знаний. Для этого нужно разобраться, как считывать данные. Для этого используется функция <code>scanf</code>. Посмотрим решение задачи A + B.</p>

<p>Напишите программу, которая считывает два целых числа <span class="math-tex">\(a\)</span> и <span class="math-tex">\(b\)</span> (<span class="math-tex">\(-100 \le a, b \le 100\)</span>), и выводит их сумму.</p>

<pre><code class="language-cpp">int main() {
    int a, b;
    scanf("%d%d", &amp;a, &amp;b);
    printf("%d\n", a + b);
    return 0;
}</code></pre>

<p>Функция <code>scanf</code> имеет первым аргументом формат, по которому сопоставляются данные во входном потоке, а следующими аргументами <em>адреса</em>, по которым необходимо эти данные положить. <code>scanf</code> сам считает произвольное количество пробельных символов (пробел, табуляция, следующая строка, возврат каретки и т.д.) между идущими в формате подряд <code>%d</code>. (Принцип, по которому он это делает, мне не очень понятен, но это и не нужно.)</p>

<p>Пока мы не знаем, что такое адреса, но позже мы подробно их изучим. C не имеет возможности передать в функцию локальную переменную так, чтобы функция изменила её. Вместо этого мы передаем адрес локальной переменной, который мы берем оператором <code>&amp;</code> (амперсанд). Интересно, что функция, получая информацию о местоположении локальной переменной, может работать не только с этой переменной, но и с тем что находится рядом с ней. (Она не получает этим <em>права</em> — права у неё от передачи аргументов не меняются. Она получает информацию, где искать данные.) Но об этом мы поговорим подробно потом.</p>

<p>Нетрудно догадаться, как считывать строки, но там есть неочевидные моменты. Мы поговорим о строках отдельно. Пример некорректной программы, которая может как выполниться успешно, так и завершиться с ошибкой. Ничего страшного, если вы пока не знаете, что такое массивы, и, соответственно, не понимаете программу.</p>

<pre><code class="language-cpp">int main() {
    char str[10];
    scanf("%s", str);
    return 0;
}</code></pre>

<p>А эта программа гарантированно завершится с ошибкой, так как попытается считать данные в константу. Как функционирует такое ограничение, мы также позже узнаем.</p>

<pre><code class="language-cpp">int main() {
    const char *str = "Hello";
    scanf("%s", str);
    return 0;
}</code></pre><h3 id="2.2.4">2.2.4. Задача: На if</h3><p>Улитка ползет по столбу высотой <span class="math-tex">\(h\)</span> единиц и хочет забраться на самый его верх. Днем улитка поднимается вверх на <span class="math-tex">\(a\)</span> единиц, а ночью соскальзывает вниз на <span class="math-tex">\(b\)</span> единиц. На какой день улитка заберется на столб?</p>

<h4>Формат ввода</h4>

<p>Единственная строка входных данных содержит три целых числа: <span class="math-tex">\(a\)</span>, <span class="math-tex">\(b\)</span> и <span class="math-tex">\(h\)</span> (<span class="math-tex">\(1 \le b &lt; a \le h \le 10^9\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — номер дня, на который улитка достигнет верха столба.</p><h3 id="2.2.5">2.2.5. Циклы while и do while</h3><p>В C присутствуют циклы <code>while</code>, <code>do while</code> и <code>for</code>. Выходить их циклов можно с помощью операторов <code>break</code> и <code>continue</code>. К сожалению, нет возможности выйти из нескольких циклов, кроме как с помощью оператора перехода к метке <code>goto</code>.</p>

<p>Цикл <code>while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    while (i &lt; 10) {
        printf("%d", i);
        i++;
    }
    return 0;
}</code></pre>

<p>Читать это надо так. Если<code>i &lt; 10</code>, выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу, а затем прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    do {
        printf("%d", i);
        i++;
    } while (i &lt; 10);
    return 0;
}</code></pre>

<p>Читать это надо так. Выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу. Затем, если<code>i &lt; 10</code>, прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> отличается от цикла <code>while</code> тем, что он в любом случае сделает хотя бы одну итерацию.</p><h3 id="2.2.6">2.2.6. Цикл for</h3><p> Цикл <code>for</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i;
    for (i = 0; i &lt; 10; i++) {
        printf("%d", i);
    }
    i = 0;
    for (; i &lt; 10; printf("%d", i) &amp;&amp; i++);
    return 0;
}</code></pre>

<p>Читать первый цикл <code>for</code> надо так. Сначала выполнить <code>i = 0</code>. Затем выполнить тело цикла, в котором необходимо вывести значение <code>i</code>, а затем выполнить <code>i++</code>. Затем, если <code>i &lt; 10</code>, прыгнуть в начало цикла (не выполняя <code>i = 0</code>). В противном случае, прервать выполнение цикла.</p>

<p>Данный цикл на первый взгляд может выглядеть странным и запутанным, но на самом деле он удобен.</p>

<p>Часто вы будете видеть, что в первом "блоке" цикла <code>for</code> (там, где у нас написано <code>i = 0</code>) выполняют объявление переменной (например <code>int i = 0</code>). Однако, это работает не со всеми стандартами языка C. В некоторых стандартах это может считаться ошибкой.</p>

<p>Посмотрим на второй цикл <code>for</code>. Мы видим, что некоторые блоки могут быть пустыми. Все блоки должны являться expression-ами. Причина этого ясна для второго блока, ведь он проверяет условие, а значит его содержимое должно иметь значение. Но неужели <code>i = 0</code> и <code>i++</code> это тоже expression-ы, которые имеют какое-то значение? Да. <code>i = 0</code> возвращает значение своего правого аргумента, а <code>i++</code> возвращает значение <code>i</code> до увеличения. (Чуть позже мы изучим все эти операторы подробнее, но вы уже можете почитать про них.)</p>

<p>Оператор <code>&amp;&amp;</code> — это оператор И. Он выполняет левый аргумент, и, если он не <code>0</code>, выполняет правый аргумент и возвращает его, а иначе, возвращает <code>0</code>. Попробуйте теперь самостоятельно понять логику работы второго цикла.</p>

<p>Вывод этой программы: <code>01234567890123456789</code></p><h3 id="2.2.7">2.2.7. Задача: Запутанный for</h3><p> Немного изменим второй цикл из программы на предыдущем шаге.</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    for (; i &lt; 10; i++ &amp;&amp; printf("%d", i));
    return 0;
}</code></pre>

<p>Какой будет вывод у этой программы и почему?</p><h3 id="2.2.8">2.2.8. break, continue и goto</h3><p>С помощью оператора <code>break</code> мы выходим из одного внутреннего цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) break;
        }
    }
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>001012012301234</code></p>

<p>С помощью оператора <code>continue</code> мы переходим к следующей итерации внутреннего цикла, не выполняя оставшуюся часть тела цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            if (j == i) continue;
            printf("%d", j);
        }
    }
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12340234013401240123</code></p>

<p>С помощью оператора <code>goto</code> мы переходим к <em>метке</em>. Метка может быть объявлена в любом месте между statement-ов, и выглядит как идентификатор с двоеточием. С помощью оператора <code>goto</code> можно, например, выйти из двойного цикла:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) goto end;
        }
    }
    end:
    return 0;
}</code></pre>

<p>Вывод этой программы: <code><span style="color: #000000;">0</span></code></p>

<p>Бывает, что необходимо по выполнению условия выйти из блока кода. Увы, сделать это так не получится:</p>

<pre><code class="language-cpp">int main() {
    {
        int i;
        if (i) break;
    }
    return 0;
}</code></pre>

<p>Обычно, для этой цели используют цикл или оператор <code>goto</code>. (В языке программирования Zig это организовано получше.)</p>

<p>Старайтесь не использовать оператор <code>goto</code> там, где он может серьезно усложнить читаемость программы, с чем он отлично справляется. Обычно в языке C он используется для того, чтобы выйти из вложенного цикла, и для того, чтобы перейти к очистке в конце функции, если она что-то динамически создала, но в процессе её работы произошла ошибка, из-за которой она должна прерваться и вернуть ошибку. Выглядит это примерно так:</p>

<pre><code class="language-cpp">FOOSTATUS foo() {
    void *data = malloc(SIZE);
    int status = FOO_SUCCESS;
    if (!init_foo(data)) {
        status = FOO_ERROR_INIT;
        goto end
    }
    if (!process_foo(data)) {
        status = FOO_ERROR_PROCESS;
        goto end
    }
    end:
    free(data);
    return status;
}</code></pre><h3 id="2.2.9">2.2.9. switch case default</h3><p>Для более удобной организации ветвлений используются <code>switch case</code> statement-ы.</p>

<pre><code class="language-cpp">int main() {
    int x = 2;
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 3: printf("3 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 ");
        case 3: printf("3 "); break;
        case 4: printf("4 ");
    }
    switch (x) {
        case 1: printf("1 "); break;
        default: printf("- ");
    }
    printf("\n");
}</code></pre>

<p>Здесь написаны четыре <code>switch case</code> statement-а. В своем теле они имеют ветви, каждая из которых состоит из ключевого слова <code>case</code>, выражения, при котором эта ветвь срабатывает, символа двоеточия и блока кода.</p>

<p>При выполнении <code>switch case</code> statement-а выполняется первая ветвь, выражение после слова <code>case</code> у которой равно выражению после слова <code>switch</code>. У первого <code>switch</code> это вторая ветвь, которая содержит блок <code>printf("%d "); break;</code>. (Ключевое слово <code>break</code> тоже часть блока.) У второго <code>switch</code> такой ветви нет, поэтому ничего не будет исполнено.</p>

<p>Как только срабатывает одна из ветвей, выполняются все следующие ветви вплоть до последней (что по моему мнению является довольно странной логикой), либо до встречи ключевого слова <code>break</code>. Так, у третьего <code>switch</code> будет выполнен блок второй ветви <code>printf("2 ");</code>, а затем продолжится выполнение блока третьей ветви, и, так как он завершается словом <code>break</code>, блок четвертой ветви не будет выполнен.</p>

<p>Четвертый <code>switch</code> statement имеет ветвь, которая начинается с ключевого слова <code>default</code>. Блок данной ветви будет выполнен в любом случае, если не было выполнено ни одного блока выше.</p>

<p>Вывод этой программы: <code>2 2 3 - </code></p><h3 id="2.2.10">2.2.10. Задача: На цикл</h3><p>Успешный брокер Василий смотрит курс акций за последние <span class="math-tex">\(n\)</span> дней. Цена акции в день <span class="math-tex">\(i\)</span> равна <span class="math-tex">\(a_i\)</span>. Василий хочет найти два дня <span class="math-tex">\(p &lt; q\)</span>, такие, что <span class="math-tex">\(a_q - a_p\)</span> максимально возможное, ведь именно покупка акций в день <span class="math-tex">\(p\)</span>, а продажа в день <span class="math-tex">\(q\)</span> принесла бы ему максимальную прибыль, будь у него более развитые экстрасенсорные способности.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — наибольшую разность <span class="math-tex">\(a_q - a_p\)</span>.</p><h3 id="2.3">2.3. Функции</h3><h3 id="2.3.1">2.3.1. Функции</h3><p>Мы уже объявляли функции. <code>int main() {}</code> — это объявление функции, которая ничего не принимает. При использовании стандартного <em>linker-скрипта</em> (что это такое, мы узнаем позже) наличие этой функции обязательно.</p>

<p>Cигнатура функции — это список типов аргументов, которые функция принимает, и тип того, что функция возвращает. По умолчанию, функция <code>main</code> возвращает <code>int</code>, и значение <code>0</code> означает успешное выполнение. Это значение называется <em>кодом возврата</em> программы, и в <em>sh</em> можно его посмотреть у запущенной в последний раз программы с помощью переменной <code>$?</code>: <code>echo $?</code>.</p>

<p>Попробуем написать свои функции:</p>

<pre><code class="language-cpp">int foo(int a) {
    return a + 2;
}

int main() {
    int a = 5;
    int b = foo(a);
    foo(a);
    printf("%d %d\n", a, b);
    return 0;
}</code></pre>

<p>Функция <code>foo</code> принимает один аргумент типа <code>int</code> и возвращает его значение, увеличенное на <code>2</code>. В результате выполнения этой программы будет выведено <code>5 7</code></p>

<p>Обратите внимание, что вызов функции может быть как expression-ом, как в первом случае, так и statement-ом, как во втором случае.</p>

<p>Функции используются для организации кода и улучшения читаемости.</p>

<p>Функции можно определять в отдельных файлах, но в C (и Assembly) это делается не так просто, как в остальных языках. Мы поговорим об этом отдельно.</p>

<p>В функции <code>foo</code> можно вызвать функцию <code>foo</code>. Это называется <em>рекурсией</em>. Например, функция вычисления наибольшего общего делителя (greatest common divisor) может быть написана так:</p>

<pre><code class="language-cpp">int gcd(int a, int b) {
    if (a == 0)
        return 0;
    else
        return gcd(b % a, a);
}</code></pre>

<p>Естественно, можно допустить ошибку, при которой вызов функции будет происходить бесконечно. В таком случае, так как на хранение данных о предыдущих (и все ещё идущих) вызовах функции тратится память на стеке, стек вскоре закончится, и возникнет ошибка исполнения.</p>

<p>Функции могут ничего не возвращать. Для этого вместо типа возврата указывается <code>void</code>. В таком случае, нельзя использовать функцию, как expression.</p><h3 id="2.3.2">2.3.2. Аргументы программы argv</h3><p>Принято, что функция <code>main</code> принимает два аргумента, и её полная сигнатура на самом деле выглядит так: <code>int main(int argc, char **argv)</code>. Второй аргумент — список строк, длина которого неизвестна, а первый аргумент — длина этого списка. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>Что за список строк имеется ввиду? Это список аргументов программы. Когда мы запускаем программу в терминале, мы передаем их так: <code>./program ababba babba</code>. При таком запуске вывод программы будет такой:</p>

<pre><code>program
ababba
babba</code></pre>

<p>Первый аргумент всегда должен быть названием исполняемого файла. Мы можем нарушить это правило, если сделаем системный вызов <code>exec</code> самостоятельно, и некоторые программы в таком случае могут отказаться работать. (Что такое системные вызовы мы изучим позже.)</p>

<p>Благодаря особенностям <em>ABI</em> (что это такое, мы узнаем позже) мы можем написать в сигнатуру не все аргументы. Однако мы не можем написать большее количество аргументов, иначе они попадут на данные функции, которая нас вызвала, и мы начнем оперировать ими. (<code>main</code> — не первая функция при стандартном linker-скрипте.) Обратите внимание: компилятор никак не помешает нам этого сделать.</p><h3 id="2.3.3">2.3.3. Прототипы</h3><p>Функции "видят" другие функции, объявленные выше. Но если мы хотим написать две вызывающие друг друга функции, то с помощью только определений функций сделать этого, возможно, не удастся. Такой код в C++ некорректен, но в C корректен (возможно, не во всех компиляторах):</p>

<pre><code class="language-cpp">void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Решить эту проблему можно с помощью объявления функции, или, <em>прототипа</em> функции. Выглядит он так:</p>

<pre><code class="language-cpp">void boo(int n);

void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Прототип функции объявляет лишь сигнатуру. Названия аргументов в нем не важны, и, если мы заменим первую строку на <code>void boo(int);</code>, то это будет по прежнему корректно.</p>

<p>Прототип функции должен соответствовать определению функции. Если прототип здесь будет <code>void boo(long long n);</code>, то это вызовет ошибку компиляции.</p>

<p>Очень важно, что если прототип функции, и её определение будут в разных модулях, то компилятор не сможет заметить несоответствия сигнатур функций. В таком случае во время выполнения программы при вызове функции стек "съедет", и произойдет stack corruption. (Более подробно этот механизм мы изучим позже.)</p><h3 id="2.3.4">2.3.4. Задача: Набор простых функций</h3><p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int, int)</code></li>
	<li><code>int max(int, int)</code></li>
	<li><code>int abs(int)</code> — абсолютное значение (модуль)</li>
	<li><code>int lcm(int, int)</code> — наименьшее общее кратное (least common multiplier)</li>
	<li><code>int powmod(int a, int n, int m)</code> — возведение числа <code>a</code> в степень <code>n</code> по модулю <code>m</code></li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(5, 8) == 5);
    assert(min(11, 4) == 4);
    assert(max(5, 8) == 8);
    assert(max(11, 4) == 4);
    assert(abs(43) == 43);
    assert(abs(-41) == 41);
    assert(lcm(14, 21) == 42);
    assert(lcm(1128960, 567000) == 254016000);
    assert(powmod(3, 4, 7) == 4);
    assert(powmod(43259, 64234, 784) == 505);
    return 0;
}</code></pre>

<p>Функция <code>assert</code> завершает выполнение программы с кодом возврата <code>3</code>, если её аргумент равен нулю (то есть, условие провалено). Возможно, для его использования потребуется добавить <code>#include &lt;assert.h&gt;</code>.</p><h3 id="2.3.5">2.3.5. Функции с переменным количеством аргументов</h3><p>Функции <code>printf</code> и <code>scanf</code> — это функции с переменным количеством аргументов (variadic functions, vararg, ellipsis). Синтаксис C позволяет создавать такие функции, но по понятным (когда придет время) причинам, сам C такие функции поддерживать не может. Проблема в том, что при вызове функции на стек кладутся аргументы и адрес возврата, но ничего более. Поэтому по стеку нельзя понять, сколько аргументов было передано в функцию, и какие их типы или, хотя бы, размерности. Это может вызвать различные corruptions.</p>

<p>Пример функции, вычисляющей сумму аргументов:</p>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

int sum(int n, ...) {
    va_list lst;
    va_start(lst, n);
    
    int sum = 0;
    int i;
    for (i = 0; i &lt; n; i++) {
        sum += va_arg(lst, int);
    }
    
    va_end(lst);
    return sum;
}

int main() {
    printf("%d\n", sum(5, 2, 6, 4, 3, 7));
    return 0;
}</code></pre>

<p>Обратим внимание на следующее:</p>

<ul>
	<li>Нам необходим <code>#include &lt;stdarg.h&gt;</code> для того, чтобы иметь макросы <code>va_list</code>, <code>va_start</code>, <code>va_arg</code>, <code>va_end</code>. (Что такое макросы, мы узнаем позже. Пока считайте, что это функции.)</li>
	<li>Первый аргумент <code>n</code> — это длина массива. Напомню, что функция никак не может знать форму того, что ей передано. Количество аргументов надо указать. Обратите внимание, что если подать в функцию не <code>n</code> следующих аргументов, то она никак это не проверит — это приведет к corruption.</li>
	<li>Чтобы пробежать по аргументам, мы пользуемся переменной типа va_list. Эту переменную мы передаем всем функциям, связанным с аргументами. По сути, это не более, чем итератор.</li>
	<li>(Второй аргумент макроса <code>va_start</code> оказался мне неизвестен. Документация утверждает, что это аргумент, после которого начнут перебираться "переменные" аргументы, однако простой тест показал, что это не так.)</li>
	<li>Второй аргумент макроса <code>va_arg</code> это тип (обратите внимание: если бы это была функция, он не могла бы принимать тип), следующего аргумента (а также, его размер).</li>
</ul>

<p>Вывод этой программы: <code>22</code></p>

<p>Функции с переменными аргументами следует использовать ограниченно и с большой осторожностью.</p><h3 id="2.3.6">2.3.6. Задача: Набор простых функций с переменным количеством аргументов</h3><p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int n, ...)</code></li>
	<li><code>int gcd(int n, ...)</code></li>
	<li><code>int dot_product(int n, ...)</code> — скалярное произведение двух векторов. Например, произведение векторов <code>(1, 4)</code> и <code>(2, -3)</code> должно вычисляться с помощью такого вызова функции: <code>dot_product(2, 1, 4, 2, -3)</code>.</li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(2, 5, 8) == 5);
    assert(min(3, 11, 4, 8) == 4);
    assert(gcd(2, 12, 21) == 3);
    assert(gcd(3, 42, 91, 35) == 7);
    assert(dot_product(2, 1, 4, 2, -3) == -10);
    assert(dot_product(3, 1, 2, 3, 6, 5, 4) == 28);
    return 0;
}</code></pre><h3 id="2.3.7">2.3.7. Задача: Найти уязвимость</h3><p>Рассмотрим такую функцию <code>set_args</code>, которая записывает значение второго аргумента по всем остальным аргументам-адресам.</p>

<p>Пока необязательно понимать манипуляции с адресами, но кое-что проясню:</p>

<ul>
	<li><code>int*</code> — это адрес типа <code>int</code>. То есть <code>va_arg(lst, int*)</code> достает следующий адрес.</li>
	<li><code>*a = b</code> выполняет запись значения <code>b</code> в адрес <code>a</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

void set_args(int n, int val, ...) {
    va_list lst;
    va_start(lst, val);
    
    int i;
    for (i = 0; i &lt; n; i++) {
        *va_arg(lst, int*) = val;
    }
    
    va_end(lst);
}

int main() {
    int a, b, c;
    set_args(3, 31, &amp;a, &amp;b, &amp;c);
    printf("%d %d %d\n", a, b, c);
    return 0;
}</code></pre>

<p>Представьте, что пользователь может вводить данные и передавать их в <code>set_args</code> без каких либо проверок. Какую атаку можно здесь произвести (потенциально нехорошее действие)?</p><h3 id="2.4">2.4. Указатели</h3><h3 id="2.4.1">2.4.1. Объявления указателей, разыменование</h3><p>Переходим к самой интересной части языка C — указателям/адресам (pointers).</p>

<p>Указатель — это число, обозначающее ячейку в оперативной памяти. Любая локальная переменная имеет адрес, так как ей нужно где-то находиться. То же относится и к аргументам функций. (На самом деле иногда данные находятся в регистрах, но компилятор здесь будет подстраиваться под наши желания.)</p>

<p>Для взятия адреса используется унарный (с одним аргументом) оператор <code>&amp;</code>, который мы уже видели, когда использовали функцию <code>scanf</code>.</p>

<p>Тип указателя обозначается символом <code>*</code> (asterisk). Например, указатель на <code>int</code> выглядит так: <code>int*</code>. При этом синтаксис объявления указателей неочевидный и часто вызывает ошибки.</p>

<ul>
	<li>Так мы объявляем два указателя: <code>int *a, *b;</code></li>
	<li>Так мы объявляем два указателя: <code>int* a, *b;</code></li>
	<li>Так мы объявляем указатель и число: <code>int* a, b;</code></li>
</ul>

<p>Чтобы переместить данные по указателю (то есть положить их в ячейку оперативной памяти с тем же номером, что и значение указателя), используется такая запись: <code>*a = b</code>, где <code>a</code> это указатель, а <code>b</code> это данные.</p>

<p>Рассмотрим программу:</p>

<pre><code class="language-cpp">void set(int *a, int val) {
    *a = val;
}

int main() {
    int a;
    set(&amp;a, 5);
    printf("%d\n", a);
    return 0;
}</code></pre>

<p>Данная программа демонстрирует то, что я показывал выше. Функция <code>set</code> принимает аргумент типа <code>int*</code> (можно было также написать <code>int* a</code>). В функции <code>set</code> используется перемещение (этот термин не имеет отношения к тому, что с данными что-то происходит: они остаются в том же состоянии) по указателю <code>*a = val</code>. При вызове функции <code>set</code> в качестве аргумента передается адрес локальной переменной, который добывается оператором <code>&amp;</code>.</p>

<p>Вывод этой программы: <code>5</code></p><h3 id="2.4.2">2.4.2. Массивы</h3><p>В языке C присутствуют массивы, но работают они довольно странно и неочевидно. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a[10];
    a[4] = 32;
    printf("%d %d\n", a[4], sizeof(a));
    return 0;
}</code></pre>

<p>Первая строка тела функции <code>main</code> объявляет массив размера <code>10</code>. Массив — это занумерованная последовательность объектов одинакового типа. Размер массива должен быть константой, то есть известным до компиляции (<code>4 + 6</code>, например, тоже является константой).</p>

<p>На второй строке мы присваиваем четвертому элементу массива значение <code>32</code>. Массивы нумеруются с нуля. Последний индекс массива в данном случае равен <code>9</code>.</p>

<p>На третьей строке мы выводим четвертый элемент и размер массива. Вывод этой программы: <code>32 40</code>. Обратите внимание: в качестве размера массива выводится не количество его элементов, а именно занимаемая им память в байтах (напомним, что размер типа <code>int</code> равен <code>4</code> байта).</p>

<p>Что произойдет, если мы выйдем за пределы массива, сделав, например <code>a[10] = 32</code>? В конкретно этом случае, на самом деле, ничего. Точнее, присвоение произойдет, но то, что оно происходит за пределами массива, никак не будет проверено. Массив, как и все локальные переменные, а также адреса возврата функций, лежит на стеке, а в этом месте стека ничего важного не будет. Однако, в некоторых случаях, можно все-таки, перезаписать что-либо важное. Эта особенность делает программирование на C коварным, так как можно создать "отложенные ошибки": пока некорректный код работает, так как ничего не затирает, а с другими исходными данными уже будет затирать.</p>

<p>Можно создавать многомерные массивы:</p>

<pre><code class="language-cpp">int main() {
    const int n = 4, m = 5;
    int a[n][m];
    a[2][3] = 5;
    a[0][5] = 3;
    printf("%d %d\n", a[2][3], a[1][0]);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>5 3 80</code></p>

<p>Здесь мы создали двумерный массив размера <code>4x5</code>. Оперативная память адресуется линейно, и данный двумерный массив расположен в ней следующим образом: <code>a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[2][5], ...</code>. Именно поэтому, так как C не обращает внимания на выходы за границы, присваивание некорректного индекса <code>a[0][5]</code> приводит к присваиванию индекса <code>a[1][0]</code>.</p>

<p>Так как размер массива должен быть известен на момент компиляции, я должен объявить числа <code>m</code> и <code>n</code>, как константы. Значения констант нельзя менять.</p>

<p>Обратите внимания на то, что размер массива равен <code>80</code>, или <code>20</code> <code>int</code>-ов. Этот факт нам пригодится позже.</p><h3 id="2.4.3">2.4.3. Указатели и массивы</h3><p>Массивы практически являются указателями. Можно перевести массив в указатель. Рассмотрим программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int a[10];
    int *b = a;
    *(b + 4) = 32;
    printf("%d %d %d\n", b[4], sizeof(a), sizeof(b));
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>32 40 4</code> или <code>32 40 8</code>, в зависимости от разрядности вашего компилятора.</p>

<p>Если вы добавляете к указателю типа <code>T*</code> число <code>x</code>, то на самом деле к указателю добавится число <code>x * sizeof(T)</code>.</p>

<p><code>*(b + 4)</code> сначала добавляет к <code>b</code> значение <code>4 * sizeof(int)</code>, а затем <em>разыменовывает</em> (берет значение в этой ячейке памяти) его. Комичный факт, что <code>b[4] == *(b + 4) == *(4 + b) == 4[b]</code>.</p>

<p>Обратите внимание: вы можете делать операции с указателями так же, как и с массивами. Но есть одна разница: <code>sizeof</code> для указателя возвращает размер указателя, а не всего массива. Более того, имея только указатель, узнать размер массива невозможно. То есть, тип указатель, в отличии от типа массив, не знает размер.</p>

<p>Массивы нельзя передавать в функции. Поэтому, чтобы знать в функции размер массива, приходится передавать и размер:</p>

<pre><code class="language-cpp">int sum(int n, int *a) {
    int x = 0, i;
    for (i = 0; i &lt; n; i++) {
        x += a[i];
    }
    return x;
}

int main() {
    int a[5] = {2, 5, 1, 4, 3};
    int n = sizeof(a) / sizeof(a[0]);
    printf("%d\n", sum(n, a));
    return 0;
}</code></pre>

<p>Обратите внимание на синтаксис присваивания значений элементам массива <code>int a[5] = {2, 5, 1, 4, 3};</code>, и на то, как можно узнать количество элементов локального массива, разделив его размер на размер одного из его элементов (часто даже создают такой макрос).</p><h3 id="2.4.4">2.4.4. Задача: Написать любую сортировку</h3><p>Реализуйте функцию <code>void sort(int n, int *a)</code>, которая сортирует массив <code>a</code> размера <code>n</code>.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const int n = 10;
    int a[n] = {6, 1, 8, 2, 10, 7, 4, 5, 9, 3};
    int b[n] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    sort(n, a);
    assert(memcmp(a, b, n * sizeof(int)) == 0);
    return 0;
}</code></pre><h3 id="2.4.5">2.4.5. Динамическое выделение памяти</h3><p>Массивы можно создавать динамически. В C нет операторов для этого, но есть стандартные функции <code>malloc</code> и <code>free</code>.</p>

<p>Функция <code>void *malloc(size_t size)</code> создает массив размера <code>size</code> байт и возвращает указатель типа <code>void</code> на его начало. <code>size_t</code> здесь — это <code>unsigned int</code>, то есть, беззнаковое (неотрицательное) целое число. Все численные типы имеют соответствующий <code>unsigned</code> тип.</p>

<p><code>void*</code> указатель обозначает указатель на "что-то", и мы должны будем определить, на что он указывает, самостоятельно. Кроме того, добавление числа <code>x</code> к <code>void*</code> указателю добавит к нему именно <code>x</code>, поэтому этот тип часто используется для создания структур данных.</p>

<p>В отличии от локальных массивов, динамические массивы выделяются не на стеке. Возможные их положения зависят от операционной системы. Как можно делать динамические выделения памяти, и как работает <code>malloc</code>, мы узнаем позже.</p>

<p>Функция <code>void free(void *ptr)</code> освобождает массив, на начало которого указывает <code>ptr</code>. Это значение должно быть ранее получено от <code>malloc</code>. В случае, если такое значение ранее не было получено от <code>malloc</code>, и, соответственно, такого массива не существует, будет ошибка исполнения.</p>

<pre><code class="language-cpp">int main() {
    int *a = (int*)malloc(10 * sizeof(int));
    a[5] = 23;
    printf("%d\n", a[5]);
    free(a);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>23</code></p>

<p>На первой строке мы выделили массив int-ов, состоящий из 10 элементов (не забывает домножать на размер элемента). Чтобы не было предупреждений от компилятора, необходимо перевести тип указателя из <code>void*</code> в <code>int*</code> с помощью <code>(int*)</code>. (При этом при переводе типа с любого указателя на любой указатель значение не изменится. Для других базовых типов это не всегда так.) Далее мы можем оперировать массивом, как любым другим. На четвертой строке мы освобождаем массив.</p>

<p>Что будет, если выйти за границы динамического массива? Обычно место, в котором выделился ваш массив, это куча — большой отрезок, на операции с которым у вашей программы есть права, а у других программ нет, и в котором выделяются куски на каждый ваш вызов функции <code>malloc</code>. Если вы попытаетесь выполнить операцию за пределами массива, но попадёте в ваш отрезок кучи, то операция будет успешной. При этом эта точка может принадлежать другому массиву, который используется в вашей программе.</p>

<p>Это ещё одна коварность языка C: вы промазали по массиву, но операция выполнилась успешно, и вы повредили память, которая позже будет использоваться. В таком случае, если вы попробуете использовать <em>дебаггер</em> для определения проблемы, он покажет тот, скорее всего корректный, код, память которого была затёрта, а не тот код, который затёр память.</p>

<p>Если же вы попадёте не в ваш отрезок кучи, то программа просто завершится из-за сигнала <em>SIGSEGV</em>.</p>

<p>Что произойдет, если вы не освободите память? На самом деле, ничего, и нет никакой проблемы не освобождать память в однопроходной программе. Вся выделенная память все равно освободится при завершении программы. Однако, если ваша программа работает длительное время, часто создавая и удаляя объекты, необходимо освобождать память, чтобы она не закончилась. Вызов функции <code>malloc</code> может вернуть <code>0</code>, что означает отказ в выделении памяти, скорее всего, по причине превышения лимита.</p><h3 id="2.4.6">2.4.6. Задача: Найти ошибки при работе с указателями</h3><p>Найдите все возможные ошибки и утечки памяти в следующем коде:</p>

<pre><code class="language-cpp">int* foo(int x) {
    int *a = malloc(N * sizeof(int));
    if (x &lt; 0) return 0;
    int i;
    for (i = 0; i &lt; N; i++) {
        a[i] = x;
    }
    return a;
}

void boo() {
    int *a = malloc(N * sizeof(int));
    int *b = a;
    int *c = malloc(N * sizeof(int));
    a = c;
    c = b;
    b = a;
    c = b;
    free(a);
    free(b);
}

int flghm_count(int mode, int *result) {
    int status;
    int *buffer;
    status = flghm_init(buffer);
    if (!status) return -1;
    status = flghm_fill(buffer, result);
    if (!status) return -2;
    status = flghm_free(buffer);
    if (!status) return -3;
    return 0;
}
</code></pre><h3 id="2.4.7">2.4.7. Задача: Написать сортировку слиянием</h3><p>Изучим алгоритм сортировки слиянием (Merge Sort).</p>

<pre><code class="language-cpp">void merge_sort(int *a, int l, int r) {
    if (r - l == 1) return;
    int m = (l + r) / 2;
    merge_sort(a, l, m);
    merge_sort(a, m, r);
    ...
}</code></pre>

<p>Данный алгоритм является рекурсивным. Он принимает сам массив и границы подотрезка, который данному рекурсивному вызову следует отсортировать. Если длина подотрезка равна <code>1</code>, то он уже отсортирован. Если это не так, то разделим подотрезок на два меньших подотрезка и вызовем <code>merge_sort</code> от каждого из них. В результате мы получим два отсортированных подотрезка. Их необходимо <em>слить</em> в один, после чего сортировка будет завершена.</p>

<p>Здесь я использовал полуинтервалы, то есть индекс <code>r</code> не входит в подотрезок, который необходимо отсортировать. При такой реализации нет необходимости добавлять <code>+1</code> и <code>-1</code> к различным индексам границ.</p>

<p>Реализуйте алгоритм слияния. Он должен по двум отсортированным подотрезкам <code>[l, m)</code> и <code>[m, r)</code> получить один отсортированный подотрезок <code>[l, r)</code>. Здесь <code>[]</code> означают границы включительно, а <code>()</code> — не включительно.</p>

<p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Отсортируйте заданную последовательность.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(b_1, b_2, \ldots, b_n\)</span> (<span class="math-tex">\(b_1 \le b_2 \le \ldots \le b_n\)</span>) — отсортированную последовательность <span class="math-tex">\(a\)</span>.</p><h3 id="2.4.8">2.4.8. Многомерные динамические массивы</h3><p>Помимо многомерных массивов можно пользоваться также многомерными указателями. Однако, как и в одномерном случае, указатели не знают форму массива. Поэтому, например, двумерный массив размера <code>n*m</code> в помощью указателей представляется как массив размера <code>n</code>, состоящий из указателей на массивы размера <code>m</code> (на самом деле, размеры этих массивов могут различаться). Динамическое выделение двумерного массива выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int n = 4, m = 5;
    int **a = malloc(n * sizeof(int*));
    int i;
    for (i = 0; i &lt; n; i++) {
        a[i] = malloc(m * sizeof(int));
    }
    
    a[2][3] = 12;
    printf("%d\n", a[2][3]);
    
    for (i = 0; i &lt; n; i++) {
        free(a[i]);
    }
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Обратите внимание на следующее:</p>

<ul>
	<li>Так как массив динамический, его размерности не должны быть константами.</li>
	<li>Выделение памяти для массива происходит в два этапа: сначала я создаю массив указателей (поэтому домножение идет на <code>sizeof(int)</code>) размера <code>n</code>, а затем для каждого указателя создаю массив <code>int</code>-ов размера <code>m</code>. То же самое касается освобождения памяти.</li>
	<li>Итоговый размер массива не <code>n * m * sizeof(int)</code>, а <code>n * sizeof(int*) + n * m * sizeof(int)</code>.</li>
</ul>

<p>В отличии от локального массива, здесь отдельные ряды не идут друг за другом, а расположены так, как это сделал <code>malloc</code>. Мы можем расположить ряды массива подряд самостоятельно, но тогда нам нужно будет использовать не оператор индексации <code>[]</code>, а свою функцию.</p>

<pre><code class="language-cpp">int offset(int i, int j, int m) {
    return i * m + j;
}

int main() {
    int n = 4, m = 5;
    int *a = malloc(n * m * sizeof(int));
    
    a[offset(2, 3, m)] = 12;
    printf("%d\n", a[offset(2, 3, m)]);
    
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Попробуйте самостоятельно разобраться с тем, как здесь организован массив.</p><h3 id="2.4.9">2.4.9. Задача: На обход граф</h3><p>Задан граф, состоящий из <span class="math-tex">\(n\)</span> вершин и <span class="math-tex">\(m\)</span> ребер. <span class="math-tex">\(i\)</span>-е ребро задается парой вершин <span class="math-tex">\((v_i, u_i)\)</span>. Найдите количество компонент связности данного графа.</p>

<p>Компоненты связности — это разбиение множества вершин графа на попарно непересекающиеся подмножества такие, что для любых двух вершин в одном множестве (в одной компоненте связности) существует путь между ними, а для любых двух вершин в разных множествах не существует пути между ними.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит два целых числа <span class="math-tex">\(n\)</span> и <span class="math-tex">\(m\)</span> (<span class="math-tex">\(1 \le n, m \le 10^3\)</span>)</p>

<p>Следующие <span class="math-tex">\(m\)</span> строк входных данных содержат по два целых числа <span class="math-tex">\(v_i\)</span> и <span class="math-tex">\(u_i\)</span> (<span class="math-tex">\(1 \le v_i, u_i \le n\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — количество компонент связности в заданном графе.</p><h3 id="2.4.10">2.4.10. Константы</h3><p>Интересно, и не очень красиво, обстоят дела с указателями-константами. Рассмотрим примеры: </p>

<pre><code class="language-cpp">int main() {
    const int *n;
    int m;
    n = &amp;m;
    
    return 0;
}</code></pre>

<p><code>const int*</code> объявляет указатель, у которого нельзя менять содержимое. Мы можем изменить сам указатель (то есть, адрес, на который он указывает), но не можем изменить его содержимое <code>*n = 2</code>.</p>

<pre><code class="language-cpp">int main() {
    int *const n;
    *n = 2;
    
    return 0;
}</code></pre>

<p>Здесь обратная ситуация: <code>int *const</code> позволяет менять содержимое указателя, но не позволяет изменить сам указатель <code>n += 10</code>. </p>

<p>Рассмотрим немного комичный пример:</p>

<pre><code class="language-cpp">int main() {
    const int * *const *n;
    
    n += 2;
    // *n = 2;
    **n += 2;
    // ***n += 2;
    
    return 0;
}</code></pre>

<p>Закомментированные строки нарушают правила константности (const correctness) и вызывают ошибку компиляции.</p><h3 id="2.4.11">2.4.11. Задача: Сигнатура у функции execv</h3><p>Мы теперь можем понять смысл типа "строки" — <code>const char*</code>. Это указатель на символ (и, соответственно, следующие символы), содержимое которого (то есть, ни первый символ, ни другие) нельзя менять.</p>

<p>Посмотрим на сигнатуру функции <code>int execv(const char *path, char *const argv[]);</code> (подробнее по <a href="https://linux.die.net/man/3/execv" rel="noopener noreferrer nofollow">ссылке</a>). Что вы можете сказать про её второй аргумент, и как это влияет на использование функции? Попробуйте вызвать эту функцию (необязательно делать что-то осмысленное, главное добиться успешной компиляции).</p><h3 id="2.5">2.5. Строки</h3><h3 id="2.5.1">2.5.1. Представление строки, функция strlen</h3><p>Представим, что мы печатаем строку с помощью <code>scanf("%s", str);</code>. <code>str</code> — это не более, чем указатель. Как функция <code>scanf</code> понимает, где кончается строка? Она понимает это с помощью численно равного нулю символа <code>\0</code>, которым строка заканчивается. Когда мы объявляем строку, как <code>const char *str = "aba";</code>, то её длина будет составлять <code>4</code>, и последним символом в ней будет <code>\0</code>.</p>

<p>Что же будет, если мы целенаправленно избавимся от нулевого символа в конце строки? Сделать это мы можем так:</p>

<pre><code class="language-cpp">int main() {
    char a[3];
    a[0] = 'a';
    a[1] = 'b';
    a[2] = 'c';
    printf("%s\n", a);
    return 0;
}</code></pre>

<p>Вывод этой программы будет начинаться с символов <code>abc</code>. То, что пойдёт далее, зависит от компилятора и его режима. Здесь происходит довольно простая и очевидная вещь: функция <code>scanf</code> печатает символ за символом, пока не наткнется на нулевой символ где-то дальше за строкой в памяти. В зависимости от того, где расположена строка, это также может вызвать ошибку исполнения, если нулевого символа не найдется вплоть до конца доступной программе памяти.</p>

<p>Из-за такой особенности работа со строками в языке C довольно неприятна. Необходимо всегда помнить о лишнем символе.</p>

<p>Рассмотрим первую стандартную функцию для работы со строками: <code>size_t strlen( const char* str );</code>. С помощью этой функции мы определяем длину строки (не включая нулевой символ). Написать эту функцию очень просто, вот её реализация:</p>

<pre><code class="language-cpp">size_t strlen( const char* str ) {
    const char *x = str;
    while (*x != '\0') {
        x++;
    }
    return x - str;
}</code></pre>

<p>Чтобы проверить эту реализацию, функцию необходимо будет переименовать, либо убрать <code>glibc</code>.</p>

<p>Для использования стандартных функций для работы со строками часто необходимо добавить <code>#include &lt;string.h&gt;</code>.</p><h3 id="2.5.2">2.5.2. Задача: Почему ошибка исполнения?</h3><p>При выполнении данной программы происходит ошибка исполнения, хотя строка не является константой, и компиляция проходит успешно. (Возможно, наблюдается не на всех компиляторах.) Почему? </p>

<pre><code class="language-cpp">int main() {
    char *a = "abacaba";
    a[3] = 'b';
    
    return 0;
}</code></pre><h3 id="2.5.3">2.5.3. Функции sprintf, strcpy, strncpy</h3><p>Функция <code>int sprintf( char* buffer, const char* format, ... );</code> работает, как функция <code>printf</code>, но она принимает своим первых аргументом строку <code>buffer</code>, в которую и происходит печать. При этом содержимое строки <code>buffer</code>  никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    char str[100];
    sprintf(str, "%d %d", 32, 85);
    printf("%s\n", str);
}</code></pre>

<p>Вывод этой программы: <code>32 85</code></p>

<p>Функция <code>char *strcpy( char *dest, const char *src );</code> выполняет копирование строки из второго аргумента в первый (поэтому тип первого аргумента лишён <code>const</code>). Копирование выполняется до обнаружения нулевого символа в <code>src</code>. При этом содержимое строки <code>dest</code> никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>abacaba</code></p>

<p>Обратите внимание, что функция <code>strcpy</code> закладывает нулевой символ в конец строки <code>dest</code>. Не забывайте оставлять под него место.</p>

<p>Часто необходимо ограничить длину копируемой строки. Вместо добавления <code>if</code>-а можно использовать стандартную функцию <code>char *strncpy( char *dest, const char *src, size_t count );</code>, которая копирует не более <code>count</code> символов, <strong>включая нулевой символ</strong> (то есть, может оставить строку без нуля на конце).</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[4];
    strncpy(b, a, 3);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>aba</code></p>

<p>Вообще, "n" версии есть у почти каждой строковой функции. Посмотрите функцию <code>strnlen</code>.</p><h3 id="2.5.4">2.5.4. Функции strcmp, atoi, strdup</h3><p>Функция <code>int strcmp( const char* lhs, const char* rhs );</code> сравнивает две строки <em>лексикографически</em>.</p>

<blockquote>
<h3>Return value</h3>

<p>Negative value if lhs appears before rhs in lexicographical order.</p>

<p>Zero if lhs and rhs compare equal.</p>

<p>Positive value if lhs appears after rhs in lexicographical order.</p>
</blockquote>

<p>Обратите внимание, что упоминается лишь знак возвращаемого значения. Само же значение не задокументировано.</p>

<p>Так мы проверяем две строки на равенство:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "aba";
    const char *b = "baba";
    const char *c = "aba";
    printf("%d\n", strcmp(a, b));
    printf("%d\n", strcmp(b, a));
    printf("%d\n", strcmp(a, c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>-1 1 0 </code></p>

<p>Перевести строку в число можно с помощью функции <code>int atoi( const char* str );</code>.(В случае некорректной строки она возвращает <code>0</code>.)</p>

<pre><code class="language-cpp">int main() {
    printf("%d\n", atoi("5328"));    
    return 0;
}</code></pre>

<p>Часто необходимо проводить копирование в динамическую строку (вообще, часто приходится работать и с динамическими строками). Вместо такого:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    int n = strlen(a);
    char *b = (char*)malloc((n + 1) * sizeof(char));
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>, можно использовать функцию <code>char * strdup( const char *str1 );</code>, которая делает то же самое.</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char *b = strdup(a);
    printf("%s\n", b);
    return 0;
}</code></pre><h3 id="2.5.5">2.5.5. Задача: Написать строковые функции</h3><p>Реализуйте функции <code>strcpy</code>, <code>strncpy</code>, <code>strcmp</code> и <code>strncmp</code> так, как ранее была реализована функция <code>strlen</code>. Добавьте в начало их названия символ <code>_</code>, чтобы не было конфликтов имен.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    _strcpy(b, a);
    assert(strcmp(b, "abacaba") == 0);
    b[3] = '\0';
    _strncpy(b, a, 3);
    assert(strcmp(b, "aba") == 0);
    assert(_strcmp("aba", "aba") == 0);
    assert(_strcmp("aba", "abc") &lt; 0);
    assert(_strcmp("abc", "aba") &gt; 0);
    assert(_strncmp("aba", "abc", 2) == 0);
    assert(_strncmp("aba", "abc", 3) &lt; 0);
    return 0;
}</code></pre><h3 id="2.5.6">2.5.6. Функция strtok</h3><p>Следующая функция  <code>char* strtok( char* str, const char* delim );</code> более сложная в использовании. Эта функция используется для разбиения строки <code>str</code> на токены. Аргумент <code>delim</code> хранит символы-разделители токенов. Рассмотрим программу:</p>

<pre><code class="language-cpp">#include &lt;string.h&gt;

int main() {
    char str[] = "ab;cde,fghi";
    int n = strlen(str);
    
    char *a = strtok(str, ",;");
    printf("%d ", strlen(str));
    printf("%d ", strlen(a));
    
    char *b = strtok(NULL, ",;");
    printf("%d ", strlen(b));
    
    char *c = strtok(NULL, ",;");
    printf("%d ", strlen(c));

    char *d = strtok(NULL, ",;");
    printf("%d\n", d);

    int i;
    for (i = 0; i &lt;= n; i++) {
        if (str[i] == 0) {
            printf(".");
        }
        else {
            printf("%c", str[i]);
        }
    }
    printf("\n");
    
    return 0;
}</code></pre>

<p>Вывод этой программы:</p>

<pre><code class="language-no-highlight">2 2 3 4 0
ab.cde.fghi.</code></pre>

<p>Пусть разделителями будут символы <code>,</code> и <code>;</code>. Сначала выполним такой вызов функции: <code>strtok(str, ",;");</code>. В результате этого вызова вместо первого разделителя в изначальной строке <code>;</code> будет поставлен нулевой символ, будет возвращен указатель на первый символ, не являющийся разделителем (а наша строка не начинается с разделителей, поэтому будет возвращен <code>str</code>) , а внутри функции <code>strtok</code> будет неким образом создана запись о том, какой последний символ был обработан.</p>

<p>Затем выполним вызов <code>strtok(NULL, ",;");</code>. В результате этого вызова повторятся те же действия, но не с аргумента (который теперь просто <code>0</code>), а с последнего обработанного символа. Будет найден следующий разделительный символ <code>,</code> и заменен на нулевой символ. Затем будет возвращён указатель на символ <code>c</code>.</p>

<p>При выполнении третьего вызова разделительный символ не будет найден, но <code>strtok</code> всё равно вернёт указатель на начало последнего токена — символ <code>f</code>. Так как последний токен программы был считан, четвёртый вызов функции <code>strtok</code> вернёт ноль.</p>

<p>Для лучшего понимания посмотрите на конечное состояние массива <code>str</code>, в котором вместо каждого нулевого символа написан символ <code>.</code>. Все ненулевые значения, возвращённые функцией <code>strtok</code> указывают на этот массив.</p>

<p>Значение "переменной" (что это такое, узнаем чуть позже) <code>NULL</code> равно нулю. (Вы можете вместо <code>NULL</code> везде написать <code>0</code>.) Также здесь нам необходимо добавить <code>string.h</code>.</p><h3 id="2.5.7">2.5.7. Задача: Написать токенизирующую функцию</h3><p>Напишите функцию <code>int strsum(const char *str);</code>, которая принимает строку, состоящую из последовательности целых чисел и пробелов, и возвращает сумму чисел в этой строке.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(strsum("123") == 123);
    assert(strsum("-6") == -6);
    assert(strsum("  2  2    3 ") == 7);
    assert(strsum("  -6  24    -7 ") == 11);
    return 0;
}</code></pre><h3 id="2.5.8">2.5.8. Функции mem***</h3><p>Для выполнения таких же операций с массивами любого типа используются <code>mem***</code> функции. Естественно, функции <code>memlen</code> нет, так как только строки завершаются нулём. Не забывайте о том, что размер массива принимается в байтах, поэтому нужно домножать количество элементов на размер одного элемента.</p>

<p>Функция <code>void *memset(void *buf, int ch, size_t count)</code> устанавливает <code>len</code> байт массива <code>buf</code> равными младшему байту числа <code>ch</code> (старшие байты при этом игнорируются).</p>

<pre><code class="language-cpp">int main() {
    int a[4];
    memset(a, 0x1234, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", a[i]);
    }
    printf("%d", 0x34343434);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>875836468 875836468 875836468 875836468 875836468</code></p>

<p>Функция <code>void *memcpy(void *dest, const void *source, size_t count)</code> копирует <code>count</code> байт массива <code>source</code> в массив <code>dest</code>.</p>

<pre><code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4];
    memcpy(b, a, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", b[i]);
    }
    
    return 0;
}</code></pre>

<p>Вывод этой программы будет состоять из четырёх чисел, первые три из которых: <code>1 2 3</code></p>

<p>Функция <code>int memcmp(const void *buf1, const void *buf2, size_t count)</code> сравнивает первые <code>count</code> элементов массивов <code>buf1</code> и <code>buf2</code> лексикографически так же, как и функция <code>strcmp</code>.</p>

<pre><code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4] = {1, 2, 3, 5};
    printf("%d ", memcmp(a, b, 3 * sizeof(int)));
    printf("%d ", memcmp(a, b, 4 * sizeof(int)));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>0 -1</code></p>

<p>Следует отдавать предпочтение <code>mem***</code> функциям, так как они используют специальные ассемблерные инструкции (которые мы ещё увидим), и потому более быстрые. (Хотя <code>str***</code> функции в то же время тоже имеют некоторые хитрые оптимизации, связанные с итерированием не по одному символу, а по машинному слову. Но это не так сильно влияет.)</p><h3 id="2.6">2.6. Структуры</h3><h3 id="2.6.1">2.6.1. Кодирование целых чисел</h3><p>Один байт состоит из восьми бит. Бит принимает одно из двух значений: <code>0</code> или <code>1</code>. Поэтому один байт может принимать <span class="math-tex">\(2^8 = 256\)</span> различных значений.</p>

<p>Рассмотрим, как переводить числа из двоичной в десятичную систему счисления. Мы будем указывать менее значимые цифры справа. (Хотя это и не важно, и часто для удобства менее значимые цифры размещают слева.)</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>0</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>1</code></td>
			<td><code>1</code></td>
		</tr>
		<tr>
			<td><code>10</code></td>
			<td><code>2</code></td>
		</tr>
		<tr>
			<td><code>11</code></td>
			<td><code>3</code></td>
		</tr>
		<tr>
			<td><code>100</code></td>
			<td><code>4</code></td>
		</tr>
		<tr>
			<td><code>101</code></td>
			<td><code>5</code></td>
		</tr>
		<tr>
			<td><code>110</code></td>
			<td><code>6</code></td>
		</tr>
		<tr>
			<td><code>111</code></td>
			<td><code>7</code></td>
		</tr>
		<tr>
			<td><code>1000</code></td>
			<td><code>8</code></td>
		</tr>
	</tbody>
</table>

<p>В общем случае, если <span class="math-tex">\(i\)</span>-й бит числа в двоичной записи равен <span class="math-tex">\(a_i\)</span>, в десятичной записи оно будет равно <span class="math-tex">\(a_0 \cdot 1 + a_1 \cdot 2 + a_2 \cdot 4 + a_3 \cdot 8 + \ldots = \sum{a_i \cdot 2^i}\)</span></p>

<p>Целочисленные типы данных бывают знаковыми (signed) и беззнаковыми (unsigned). Беззнаковые типы принимают значение от <span class="math-tex">\(0\)</span> (когда все биты нулевые) до <span class="math-tex">\(2^{size} - 1\)</span> (когда все биты единицы), где <span class="math-tex">\(size\)</span> — это размер типа данных в битах. Так, максимальное значение типа <code>unsigned int</code> равно <span class="math-tex">\(2^{32} - 1 = 4294967295\)</span>.</p>

<p>Знаковые типы принимают значение от <span class="math-tex">\(-2^{size - 1}\)</span> до <span class="math-tex">\(2^{size - 1} - 1\)</span>. Как кодируются отрицательные числа покажем на примере типа <code>char</code>.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>00000000</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>11111111</code></td>
			<td><code>-1</code></td>
		</tr>
		<tr>
			<td><code>11111110</code></td>
			<td><code>-2</code></td>
		</tr>
		<tr>
			<td><code>11111101</code></td>
			<td><code>-3</code></td>
		</tr>
		<tr>
			<td><code>11111100</code></td>
			<td><code>-4</code></td>
		</tr>
	</tbody>
</table>

<p>Переводить число из <code>n</code>-й системы счисления в десятичную можно с помощью формулы <span class="math-tex">\(\sum{a_i \cdot n^i}\)</span>. Чтобы писать в коде числа в двоичном, восмеричном и шестнадцатиричном формате, следует перед ними написать <code>0b</code>, <code>0</code> и <code>0x</code> соответственно. Формат <code>%d</code> выполнит печать в десятичном формате, но <code>printf</code> также имеет форматы и для других систем счисления.</p>

<pre><code class="language-cpp">int main() {
    printf("%d %d %d\n", 0b1010, 013, 0xC);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>10 11 12</code></p><h3 id="2.6.2">2.6.2. Битовые операторы</h3><p>Для манипуляций с битами чисел используются битовые операторы. Они взаимодействуют на каждую позицию чисел-аргументов независимо и действуют аналогично одноименным логическим операторам.</p>

<ul>
	<li><code>&amp;</code> — оператор И. Например, <code>0b10110 &amp; 0b11010 = 0b10010</code>.</li>
	<li><code>|</code> — оператор ИЛИ. Например, <code>0b10101 | 0xb11001 = 0x11101</code>.</li>
	<li><code>^</code> — оператор исключающее ИЛИ. Например, <code>0x1001 ^ 0x1100 = 0x0101</code>.</li>
	<li><code>~</code> — унарный оператор НЕ. Например, для типа <code>char</code>, <code>~0b1010 = 0b11110101</code>. (Обратите внимание на зависимость от размера типа данных.)</li>
	<li><code>&lt;&lt;</code> — оператор сдвига числа налево (в сторону увеличения числа). Например, <code>0b1001 &lt;&lt; 2 = 0b100100</code>. Сдвиг не циклический. Если никакие единичные биты не пропадают, то <code>a &lt;&lt; b</code><span class="math-tex">\(= a \cdot 2 ^ b\)</span>.</li>
	<li><code>&gt;&gt;</code> — оператор сдвига числа направо (в сторону уменьшения числа). Например, <code>0b1001 &gt;&gt; 2 = 0b10</code>. Сдвиг не циклический. <code>a &gt;&gt; b</code><span class="math-tex">\(= \lfloor \frac{a}{2^b} \rfloor\)</span>.</li>
</ul>

<p>Проверить наличие <code>i</code>-го бита в числе можно так: <code>if (a &amp; (1 &lt;&lt; i))</code>.</p>

<p>Битовые операторы имеют неочевидные приоритеты. Например, если вы хотите проверить, что <code>i</code>-й бит отсутствует, то такая проверка <code>if (a &amp; (1 &lt;&lt; i) == 0)</code> некорректна, так как оператор сравнения выполнится до оператора битового И.</p>

<p>Если вы проверяете наличие <code>i</code>-го бита в числе типа <code>long long</code>, то следует делать сдвиг так: <code>1ll &lt;&lt; i</code>. Суффикс <code>ll</code> делает число <code>1</code> типа <code>long long</code>. Если же не приписать этот суффикс и проверить, например, <code>40</code>-й бит, то сначала выполнится сдвиг числа <code>1</code> типа <code>int</code> на <code>40</code> позиций, в результате чего получится ноль, который затем будет переведен в тип <code>long long</code>.</p>

<p>Подобные суффиксы есть и у других типов. Дробные числа, записанные так — <code>4.3</code> — имеют тип <code>double</code>, а не <code>float</code>, что не позволит написать, например, так: <code>const float a = 4.3;</code>(возможно, не во всех компиляторах). Числа типа <code>float</code> следует завершать символом <code>f</code>.</p><h3 id="2.6.3">2.6.3. Задача: На перебор масок</h3><p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Найдите минимальный размер такого множества чисел <span class="math-tex">\(b_1, b_2, \ldots, b_m\)</span>, что <span class="math-tex">\(a_{b_1} | a_{b_2} | \ldots | a_{b_m} = a_1 | a_2 | \ldots | a_n\)</span></p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 20\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 2^{30} - 1\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное целое число <span class="math-tex">\(m\)</span> — минимальный размер подходящего множества.</p><h3 id="2.6.4">2.6.4. Кодирование вещественных чисел</h3><p>Рассмотрим перевод дробного числа из двоичной записи в десятичную. Здесь используется та же формула, но теперь она распространяется и на отрицательные индексы.<span class="math-tex">\(0b10.1011 = 1 \cdot 2^1 + 0 \cdot 2^0 + 1 \cdot 2^{-1} + 0 \cdot 2^{-2} + 1 \cdot 2^{-3} + 1 \cdot 2^{-4} = 2 + 0 + 0.5 + 0 + 0.125 + 0.0625 = 2.6875\)</span></p>

<p>Рассмотрим структуру стандартного типа данных с плавающей точкой: <code>float</code>. Он состоит из <code>32</code>-х бит:</p>

<ul>
	<li>1 бит — знак, как у целых чисел</li>
	<li>2-9 биты — порядок (exponent)</li>
	<li>10-32 биты — мантисса (fraction)</li>
</ul>

<p>Порядок кодируется таким же образом, как и целое беззнаковое число. Обозначим его как <span class="math-tex">\(A\)</span>. Мантисса кодирует дробное число, меньшее единицы: первый бит кодирует <span class="math-tex">\(\frac{1}{2}\)</span>, второй бит кодирует <span class="math-tex">\(\frac{1}{4}\)</span> и так далее. Обозначим его как <span class="math-tex">\(B\)</span>. Тогда значение числа равно <span class="math-tex">\(2^{A - 127} \cdot (1 + B)\)</span></p>

<p>Посмотрим на такое значение типа <code>float</code>: <code>0 01111100 01000000000000000000000</code></p>

<ul>
	<li>Первый бит равен <code>0</code>, поэтому число неотрицательное.</li>
	<li>В порядке стоит число <span class="math-tex">\(A = 0 \cdot 2^7 + 1 \cdot 2^6 + 1 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0 = 124\)</span></li>
	<li>В мантиссе стоит число <span class="math-tex">\(B = 0 \cdot \frac{1}{2^1} + 1 \cdot \frac{1}{2^2} + 0 \cdot \frac{1}{2^3} + 0 \cdot \frac{1}{2^4} + \ldots = 0.25\)</span></li>
	<li>Итого данное число равно <span class="math-tex">\(2^{124 - 127} \cdot (1 + 0.25) = 0.15625\)</span></li>
</ul>

<p>Есть отдельные два случая:</p>

<ul>
	<li>Если <span class="math-tex">\(A = 0\)</span>, то формула выглядит так: <span class="math-tex">\(2^{A - 127} \cdot B\)</span></li>
	<li>Если <span class="math-tex">\(A = 255\)</span>, то это особое число, соответствующее, например, бесконечности или <code>nan</code> (not a number), которые возникают при некоторых некорректных математических операциях. Чтобы проверить число на <code>nan</code> следует сравнить его с собой: <code>if (x != x) { "x is nan" }</code>.</li>
</ul>

<p>Чтобы использовать тип <code>float</code> в функциях <code>printf</code> и <code>scanf</code>, следует использовать формат <code>%f</code>.</p>

<p>Существуют и другие типы чисел с плавающей точкой:</p>

<ul>
	<li><code>double</code> — 8 байт</li>
	<li><code>long double</code> — не определено (обычно 10 байт)</li>
</ul><h3 id="2.6.5">2.6.5. Задача: О кодировании вещественных чисел</h3><p>Ранее я рассказывал об отдельном способе кодирования числа типа <code>float</code>, когда его показатель равен нулю. Зачем это необходимо?</p><h3 id="2.6.6">2.6.6. Перечисления enum и структуры struct</h3><p>Перечисления (enumerations) — это способ задать числам идентификатор, привязав их при этом к контексту. Рассмотрим программу:</p>

<pre><code class="language-cpp">enum E {
    A,
    B,
    C = 10,
    D,
    E
};

int main() {
    enum E e = A;
    printf("%d %d %d %d %d %d\n", A, B, C, D, E, e);
    return 0;
}</code></pre>

<p>Мы объявляем перечисление с помощью ключевого слова <code>enum</code>, затем мы даем ему название <code>E</code> и в фигурных скобках перечисляем значения. Сами значения в перечислении используются так же, как и переменные типа число-константа <code>const int</code>. Эти значения мы можем вывести без ограничений, как и если бы это были константы. Посмотрите на логику присваивания значений им. Мы можем также объявлять объекты или инстансы (instances) перечисления, указывая их тип как <code>enum E</code>. Этот тип — это всего лишь число.</p>

<p>Вывод этой программы: <code>0 1 10 11 12 0</code></p>

<p>Здесь может возникнуть вопрос: а где же привязка к контексту (названию перечисления), ведь их содержимое ведет себя как глобальные переменные? Этой привязки нет, что является недостатком перечислений в языке C. Тем не менее, в C++ были введены классы перечислений (enum classes), которые решают этот недостаток.</p>

<p>Перейдем к структурам (structures). Они необходимы для объединения группы переменных для того, чтобы манипулировать ими одновременно. В отличии от массивов, типы переменных в структурах разные, и их количество сильно ограничено.</p>

<pre><code class="language-cpp">struct S {
    int a;
    long long b;
};

int main() {
    struct S s1;
    s1.a = 4;
    s1.b = 7;
    printf("%d %d ", s1.a, s1.b);
    
    struct S *s2 = (struct S*)malloc(sizeof(struct S));
    (*s2).a = 12;
    s2-&gt;b = 17;
    printf("%d %d\n", s2-&gt;a, s2-&gt;b);
    free(s2);
    
    return 0;
}</code></pre>

<p>Мы объявляем структуру с помощью ключевого слова <code>struct</code>, следом за которым указываем название структуры и её содержимое в фигурных скобках. Объект или инстанс структуры объявляются с указыванием типа <code>struct S</code> и названия структуры: <code>struct S s1;</code>. Как только мы объявили этот объект, у нас появились сразу две связанные переменные, к которым мы обращаемся через идентификатор <code>struct</code>.  Хоть структуры и является сложным типом, их можно передавать в функции и возвращать из них. К полям (field) структуры мы обращаемся через символ <code>.</code>.</p>

<p>Можно объявлять объекты структуры динамически. Тогда, чтобы получить доступ к полям структуры, необходимо выполнить разыменование. Так как это распространённое действие (вы даже чаще будете взаимодействовать именно с указателями на структуры), для него есть свой синтаксис <code>-&gt;</code>.</p><h3 id="2.6.7">2.6.7. Задача: На связный список</h3><p>Есть последовательность чисел, которая изначально состоит из единственного числа <span class="math-tex">\(0\)</span>, указатель, который изначально указывает на первую позицию последовательности, и счетчик <span class="math-tex">\(x\)</span>, изначально равный <span class="math-tex">\(1\)</span>.</p>

<p>Необходимо обработать <span class="math-tex">\(q\)</span> запросов четырех типов:</p>

<ol>
	<li>Сдвинуть указатель налево. Перед этим действием указатель находится не на первой позиции.</li>
	<li>Сдвинуть указатель направо. Перед этим действием указатель находится не на последней позиции.</li>
	<li>Вставить элемент <span class="math-tex">\(x\)</span> после указателя, а затем увеличить значение <span class="math-tex">\(x\)</span> на единицу.</li>
	<li>Удалить элемент, на который указывает указатель, сдвинув его на предыдущий элемент. Перед этим действием указатель находится не на первой позиции.</li>
</ol>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(q\)</span> (<span class="math-tex">\(1 \le q \le 1000\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(q\)</span> целых чисел <span class="math-tex">\(k_1, k_2, \ldots, k_q\)</span> (<span class="math-tex">\(1 \le k_i \le 4\)</span>) — запросы, которые необходимо обработать. Гарантируется, что запросы удовлетворяют ограничениям, указанным в условии.</p>

<h4>Формат вывода</h4>

<p>Выведите последовательность чисел после выполнения всех запросов.</p><h3 id="2.6.8">2.6.8. Объединения union, typedef</h3><p>Один из способов изменить битовую запись числа типа <code>float</code> напрямую следующий:</p>

<pre><code class="language-cpp">int main() {
    float a;
    int *b = (int*)(&amp;a);
    *b = 0x3FFFFFFF;
    printf("%f\n", a);
    return 0;
}</code></pre>

<p>(Попробуйте самостоятельно выяснить, какое число будет выведено.)</p>

<p>В C++ подобные манипуляции можно делать с помощью оператора <code>reinterpret_cast</code>. В C также можно сделать это с помощью объединений <code>union</code>.</p>

<p>Объединение реализует сумму типов (sum types), то есть её содержимое является одним из нескольких типов. Однако, в силу простоты языка C и того, как в нем объединения реализованы:</p>

<ul>
	<li>Узнать, какой тип храниться в конкретном объекте объединения без дополнительной информации, невозможно.</li>
	<li>Само обращение к объединению является лишь приведением одного и того же адреса в тип, который мы запрашиваем.</li>
</ul>

<p>Таким образом, объединения отличаются от просто приведения типа тем, что выбор типов ограничен, и у них есть псевдонимы.</p>

<pre><code class="language-cpp">union U {
    float a;
    int b;
};

int main() {
    union U u;
    u.b = 0x3FFFFFFF;
    printf("%f\n", u.a);
    return 0;
}</code></pre>

<p>Можно типам данных давать псевдонимы. Например, если мы напишем <code>typedef int i32;</code>, то мы сможем, написав <code>i32</code> создать переменную типа <code>int</code>: <code>i32 a = 3;</code>.</p>

<p>К перечислениям, структурам и объединениям можно применять такой синтаксис:</p>

<pre><code class="language-cpp">typedef int i32;

typedef struct {
    i32 a;
} S;

int main() {
    S s;
    s.a = 7;
    return 0;
}</code></pre>

<p>При таком объявлении структуры мы не должны писать ключевое слово <code>struct</code> в типе.</p><h3 id="2.7">2.7. Функции высшего порядка, макросы, шаблоны</h3><h3 id="2.7.1">2.7.1. Функции высшего порядка</h3><p>В C можно передавать в функции указатели на другие функции, чтобы строить функции высших порядков.</p>

<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

int apply(int x, int(*f)(int)) {
    return f(x);
}

int main() {
    printf("%d\n", apply(5, square));
    return 0;
}</code></pre>

<p>Функция <code>square</code> возвращает квадрат аргумента и интереса не представляет. Посмотрим на второй аргумент функции <code>apply</code>. Тип этого аргумента — <code>int(*)(int)</code> — указатель на функцию, которая принимает один аргумент типа <code>int</code>, и возвращает тип <code>int</code>. <code>f</code> — это название аргумента. Функция <code>apply</code> применяет свой второй аргумент к первому аргументу.</p>

<p>Указатели на функции можно объявлять и как обычные локальные переменные.</p>

<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

int main() {
    int(*foo)(int) = square;
    printf("%d\n", foo(5));
    return 0;
}</code></pre>

<p>Выводы обеих программ — <code>25</code></p>

<p>Указатели на функции обычно используются для двух целей:</p>

<ul>
	<li>Создание функций высшего порядка</li>
	<li>Создание наследования</li>
</ul><h3 id="2.7.2">2.7.2. Задача: О вложенных функциях</h3><p>В языке C нет синтаксиса для создания вложенных функций (объявления функции в теле другой функции). Как можно добиться похожего функционала?</p><h3 id="2.7.3">2.7.3. Макросы</h3><p>До компиляции программы выполняется её препроцессирование, которое заключается в выполнении всех строк, которые начинаются с символа <code>#</code>. Помимо включения файлов с помощью <code>#include</code>, препроцессор даёт возможность писать макросы. Макросы могут напоминать функции, но у них есть и различия.</p>

<pre><code class="language-cpp">#define FOO 5
#define DOUBLE1(x) (x * 2)
#define DOUBLE2(x) ((x) * 2)

int main() {
    printf("%d ", FOO);
    printf("%d ", DOUBLE1(4 + 1));
    printf("%d\n", DOUBLE2(4 + 1));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>5 6 10</code></p>

<p><code>#define</code> выполняет подстановку своего третьего аргумента заместо второго в каждом его вхождении в программу. Например, все вхождения <code>FOO</code> заменятся на <code>5</code>. Макросы могут иметь аргументы, которые будут также подставлены без каких либо изменений.</p>

<p>Здесь сразу обратите внимание на второе число в выводе и попробуйте самостоятельно понять, почему в результате получилось оно.</p>

<p>Чтобы это понять, раскроем макрос вручную: <code>DOUBLE1(4 + 1) -&gt; {x = "4 + 1"} -&gt; (4 + 1 * 2) = 6</code>. Это одна из главных проблем использования макросов — необходимость продумывать, как будет выполнено раскрытие. Конкретно эта проблема решается заключением аргумента макроса в скобки, чтобы сначала выполнить вычисление аргумента. Однако, не всегда решение подобных проблем простое и вообще возможное.</p>

<p>Чем макрос может быть хорош по сравнению с функцией? Он может позволить создавать подобие функции для обобщенного типа (то есть, без уточнения типа). Например, обычно с помощью макроса реализовывают функции <code>min</code> и <code>max</code>.</p>

<pre><code class="language-cpp">#define MIN(X, Y) \
    (X &lt; Y) ? X : Y

int main() {
    printf("%d %d\n", MIN(3, 5), MIN('b', 'a'));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>3 97</code></p>

<p>Символ <code>\</code> продолжает действие конструкции препроцессора на следующую строку. Здесь мы с помощью тернарного оператора написали подобие функции, которое на самом деле будет просто подставлять в код выражение с тернарным оператором: <code>MIN(3, 5) -&gt; {X = 3, Y = 5} -&gt; (3 &lt; 5) ? 3 : 5</code>.</p>

<p>Тернарный оператор <code>A ? B : C</code> похож на if-statement, но является expression. В случае, если <code>A != 0</code>, он вернёт <code>B</code>. В противном случае он вернёт <code>C</code>.</p>

<p>Если требуется в макросе выполнить последовательность действий, обычно делают так:</p>

<pre><code class="language-cpp">#define PRINT(X, Y)        \
    {                      \
        printf("%d ", X);  \
        printf("%d\n", Y); \
    }

int main() {
    PRINT(4, 7)
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>4 7</code></p><h3 id="2.7.4">2.7.4. Макросы для обобщённого программирования</h3><p>В языке C нет встроенных способов создания функций для обобщенных типов. Мы можем написать макрос, который будет объявлять функцию для заданного типа (ведь в качестве аргументов макроса можно использовать не только значение). Однако до определенного стандарта в языке C не было автоматического определения функции на основе типа. (В языке C++ для этого есть перегрузка функций. Как она работает, и почему она отсутствует в языке C, мы узнаем позже.)</p>

<p>Есть разные способы организации функции для обобщенных типов, и в разных проектах используются разные. Вот один из способов.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE(X) \
        sizeof(X) / sizeof(X[0])
        
typedef struct {
    int x;
} S;

typedef struct {
    int x;
} T;

T foo(S s) {
    T t;
    t.x = s.x * 2;
    return t;
}

int boo(int x) {
    return x + 1;
}

#define MAP(F, A, B)                    \
B* F(B(*f)(A), A* l1, int sz) {         \
    B* l2 = (B*)malloc(sz * sizeof(B)); \
    for (int i = 0; i &lt; sz; i++) {      \
        l2[i] = f(l1[i]);               \
    }                                   \
    return l2;                          \
}

MAP(map_ii, int, int)
MAP(map_st, S, T)

int main() {
    int i;
    int lst1[4] = {1, 4, 6, 11};
    int *lst1_out = map_ii(boo, lst1, SIZE(lst1));
    for (i = 0; i &lt; SIZE(lst1); i++) {
        printf("%d ", lst1_out[i]);
    }
    printf("\n");
    
    S lst2[4] = {{1}, {3}, {5}, {9}};
    T *lst2_out = map_st(foo, lst2, SIZE(lst2));
    for (i = 0; i &lt; SIZE(lst2); i++) {
        printf("%d ", lst2_out[i].x);
    }
    printf("\n");
    
    return 0;
}</code></pre>

<p>Реализуем функцию <code>map</code> из функциональных языков, которая принимает функцию и массив элементов, после чего создает новый массив, полученный поэлементным применением функции к исходному массиву. Посмотрим на сам макрос:</p>

<pre><code class="language-cpp">#define MAP(F, A, B)                    \
B* F(B(*f)(A), A* l1, int sz) {         \
    B* l2 = (B*)malloc(sz * sizeof(B)); \
    for (int i = 0; i &lt; sz; i++) {      \
        l2[i] = f(l1[i]);               \
    }                                   \
    return l2;                          \
}</code></pre>

<p>Макрос принимает название функции <code>F</code>, которую следует объявить, и входной и выходной типы <code>A</code> и <code>B</code>. Сигнатура функции выглядит так: <code>B* F(B(*f)(A), A* l1, int sz)</code>, то есть она принимает функцию из типа <code>A</code> в тип <code>B</code> и массив типа <code>A</code> с его размером, а возвращает массив типа <code>B</code>. То есть, функция <code>map</code> параметризована двумя типами.</p>

<p>Мы создаем функцию <code>map</code> для типов <code>int</code> и <code>int</code> так: <code>MAP(map_ii, int, int)</code>. После раскрытия макроса вручную мы получим такое:</p>

<pre><code class="language-cpp">int* map_ii(int(*f)(int), int* l1, int sz) {
    int* l2 = (int*)malloc(sz * sizeof(int));
    for (int i = 0; i &lt; sz; i++) {
        l2[i] = f(l1[i]);
    }
    return l2;
}</code></pre>

<p>Обратите внимание на то, что <code>map</code> не освобождает входной массив. Следует ли это делать зависит от вашего стиля создания функций обобщенных типов.</p>

<p>Вызвать функцию <code>map</code> для типов <code>int</code> и <code>int</code> мы можем так: <code>map_ii(boo, lst1, SIZE(lst1));</code>. К сожалению, нам необходимо самостоятельно подбирать правильное название функции на основе типа. В более современном языке C есть ключевое слово <code>_Generic</code>, которое выполняет эту работу за нас.</p>

<p>Вывод этой программы:</p>

<pre><code>2 5 7 12 
2 6 10 18 
</code></pre><h3 id="2.7.5">2.7.5. Задача: Написать обобщённыю функцию</h3><p>Реализуйте с помощью макроса функцию <code>zip</code>, которая принимает вторым и третьим аргументом массивы типа <code>A</code> и <code>B</code>, а первым аргументом [функцию, которая принимает два аргумента типа <code>A</code> и <code>B</code>, и возвращает тип <code>C</code>], и создает новый массив, полученный поиндексным применением функции к элементам массивов (первый к первому, второй ко второму и т.д.). Подставьте эту программу.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

#define SIZE(X) \
        sizeof(X) / sizeof(X[0])
        
typedef struct {
    int x;
} S;

typedef struct {
    int x;
} T;

typedef struct {
    int x;
} U;

U doo(S s, T t) {
    U u;
    u.x = s.x * t.x;
    return u;
}

ZIP(zip_stu, S, T, U);

int main() {
    int i;
    S lst1[4] = {{1}, {3}, {5}, {9}};
    T lst2[4] = {{2}, {6}, {10}, {17}};
    U *lst3 = zip_stu(doo, lst1, lst2, SIZE(lst1));
    assert(lst3[0].x == 2);
    assert(lst3[1].x == 18);
    assert(lst3[2].x == 50);
    assert(lst3[3].x == 153);
    
    return 0;
}</code></pre><h3 id="2.7.6">2.7.6. Имитация наследования</h3><p>Указатели на функции дают возможность сделать подобие наследования. Мы можем написать функции-конструкторы, которые будут подставлять в объекты структур указатели на необходимые функции. Однако, функции через указатели не могут видеть содержимое структур, поэтому придется передавать объект структуры вместе с каждым вызовом её функции вручную. (На самом деле, в языке C++ указатель на объект, функция которого вызывается, всегда передаётся в функцию и называется <code>this</code>.)</p>

<pre><code class="language-cpp">#include &lt;stdlib.h&gt;

const float pi = 3.14f;

struct Figure;

typedef struct {
    float x;
    float (*square)(struct Figure*);
} Figure;

float circle_square(Figure *f) {
    return pi * f-&gt;x * f-&gt;x;
}

float square_square(Figure *f) {
    return f-&gt;x * f-&gt;x;
}

Figure *build_circle(float x) {
    Figure *f = (Figure*)malloc(sizeof(Figure));
    f-&gt;x = x;
    f-&gt;square = circle_square;
    return f;
}

Figure *build_square(float x) {
    Figure *f = (Figure*)malloc(sizeof(Figure));
    f-&gt;x = x;
    f-&gt;square = square_square;
    return f;
}

int main() {
    Figure *circle = build_circle(3);
    Figure *square = build_square(3);
    printf("%f %f\n", circle-&gt;square(circle), square-&gt;square(square));
    
    return 0;
}</code></pre>

<p>Функции <code>circle_square</code> и <code>square_square</code> — это соответствующие реализации функции <code>square</code> (площадь) для структур <code>circle</code> (окружность) и <code>square</code> (квадрат). Функции <code>build_circle</code> и <code>build_square</code> — это конструкторы, которые создают объект структуры и подставляют нужные реализации функций.</p>

<p>В результате этих манипуляций нам не нужно указывать вручную, какую функцию подсчета площади вызывать. На самом деле, в языке C++ выбор нужной функции организован похожим образом: объекты содержат указатели на нужные функции. Это называется виртуальными таблицами (virtual tables), и позже мы узнаем, как они устроены.</p>

<p>Тем не менее, несоответствие локальных переменных у структур в языке C решить нельзя. Если бы мы хотели ввести структуру <code>rectangle</code> (прямоугольник), которая задается двумя числами, сделать это красиво у нас не получится.</p><h3 id="2.7.7">2.7.7. Задача: Что ещё можно сымитировать?</h3><p>Подобно функциям для обобщенных типов можно с помощью макросов организовать структуры для обобщенных типов. Для создания объектов таких структур потребуется также генерация их конструкторов. Попробуйте реализовать это любым способом.</p><h2 id="3">3. Компиляция, gcc</h2><h3 id="3.1">3.1. Фазы компиляции</h3><h3 id="3.1.1">3.1.1. Фазы компиляции</h3><p>Напомню, что мы работает с компилятором <code>gcc</code>.</p>

<p>Компиляция состоит из четырёх шагов:</p>

<ol>
	<li>Препроцессирование (preprocessing)</li>
	<li>Компиляция</li>
	<li>Ассемблирование</li>
	<li>Компоновка (linking)</li>
</ol>

<p>Мы запускаем компиляцию командой <code>gcc &lt;filename&gt;</code>, где filename — название файла с кодом. Его расширение должно быть <code>.c</code>. При таком запуске мы получим исполняемый файл с неким именем по умолчание. Имя выходного файла можно задать явно флагом <code>-o &lt;filename&gt;</code>.</p>

<ul>
	<li>Чтобы выполнить только первый этап, необходимо добавить флаг <code>-E</code>.</li>
	<li>Чтобы выполнить первый и второй этап, необходимо добавить флаг <code>-S</code>.</li>
	<li>Чтобы выполнить первый, второй и третий этапы, необходимо ввести флаг <code>-c</code>.</li>
</ul>

<p> Далее мы изучим каждый из этапов подробнее.</p>

<p>С этого момента наши программы будут состоять из нескольких файлов.</p><h3 id="3.1.2">3.1.2. Препроцессирование</h3><p> <code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Препроцессирование выполняет все строки, которые начинаются с символа <code>#</code>(и следующие за ними, если они заканчиваются символом <code>\</code>). Это могут быть инструкции <code>#include</code>, <code>#define</code>, <code>#ifdef</code> и некоторые другие.</p>

<p>Инструкция <code>#include</code> вставляет содержимое файла. Если название файла заключено в <code>""</code>, то путь файла указывается относительно текущего файла (в примере файл <code>foo.h</code> должен находиться в одной директории с файлом <code>main.c</code>). Если название файла заключено в <code>&lt;&gt;</code>, то компилятор попытается найти файл относительно стандартной глобальной директории заголовочных файлов (там, где лежат файлы <code>stdio.h</code>, <code>stdlib.h</code> и т.д.) и относительно переданных ему директорий заголовочных файлов с помощью флага <code>-I</code> (например, <code>gcc -I. main.c</code>, что означает, искать заголовочные файлы в директории <code>.</code> (то есть, в текущей)).</p>

<p>Выполните <code>gcc main.c -E</code>, чтобы выполнить препроцессирование. Вы получите такой вывод:</p>

<pre><code class="language-cpp"># 0 "main.c"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "&lt;command-line&gt;" 2
# 1 "main.c"
# 1 "foo.h" 1
int foo(int x) {
    return x + 1;
}
# 2 "main.c" 2

int main() {
    printf("%d\n", foo(2));
    return 0;
}
</code></pre>

<p>Результатом препроцессирования всегда является один файл. Обратите внимание, что содержимое файла <code>foo.h</code> непосредственно вставилось в выходной файл без каких-либо изменений.</p>

<p>Рассмотрим такую программу.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#ifdef FOO
#define DOO 4
#elif BOO
#define DOO 5
#else
#define DOO 6
#endif

#define FOO 3

#ifdef FOO
#define BOO 4
#endif

int main() {
    printf("%d %d %d\n", FOO, BOO, DOO);
    return 0;
}</code></pre>

<p>В результате её препроцессирования "переменные" <code>FOO</code>, <code>BOO</code>, <code>DOO</code> заменятся на, соответственно, значения <code>3</code>, <code>4</code>, <code>6</code>. В целом, логика работы таких ветвлений очевидна. Обратим лишь внимание на то, что обрабатываются они просто сверху вниз, и поэтому в блоке, который определяет переменную <code>DOO</code>, переменные <code>FOO</code> и <code>BOO</code> ещё не определены, и переменная <code>DOO</code> получает значение <code>6</code>.</p>

<p>Если вы не определите значение какой либо переменной, то её замены в коде не произойдет. При этом, полученный код может оказаться корректным.</p>

<p>Инструкции <code>#define</code> могут принимать аргументы. Такие инструкции называются макросами, и мы их уже видели.</p><h3 id="3.1.3">3.1.3. Компиляция</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компиляция переписывает код в язык ассемблера (Assembly). Язык ассемблера мы изучим позже.</p>

<p>Выполните <code>gcc main.c -S</code>, чтобы выполнить компиляцию. Вы получите такой вывод (содержимое обрезано):</p>

<pre><code class="language-no-highlight">	.file	"main.c"
	.text
	.globl	foo
	.type	foo, @function
foo:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...</code></pre>

<p>Кратко охаректеризовать язык ассемблера можно так. У нас есть порядка десяти ячеек памяти, которые называются регистрами, и доступ к этим ячейкам самый быстрый. Кроме того у нас есть оперативная память (RAM), которая представляет собой большую ленту пронумерованных ячеек. Наша программа является последовательностью инструкций в оперативной памяти, которые имеют следующий вид:</p>

<ul>
	<li>Записать в регистр <code>D</code> значение, равное сумме значений в регистрах <code>B</code> и <code>I</code>.</li>
	<li>Записать в регистр <code>E</code> значение, записанное в оперативной памяти в ячейке под номером, который записан в регистре <code>A</code>.</li>
	<li>Если значение в регистре <code>H</code> равно нулю, то продолжить выполнение программы с инструкции, которая находится в оперативной памяти в ячейке под номером, который записан в регистре <code>C</code>.</li>
</ul>

<p>Понятно, что с одной стороны такой язык легко выучить из-за его простоты, с другой стороны его очень тяжело читать из-за отсутствия конструкций, отвечающих за высокоуровневую организацию кода.</p><h3 id="3.1.4">3.1.4. Ассемблирование</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Ассемблирование переписывает код, написанный на языке ассемблера, в объектный файл (имеет расширение <code>.o</code> или <code>.obj</code>). Объектный файл состоит из сегментов, которые содержат инструкции, из которых состоит наша программа, а также некоторую метаинформацию.</p>

<p>Выполните <code>gcc main.c -c</code>, чтобы выполнить ассемблирование. Выходной файл не состоит из читаемого текста. Выполним сначала <code>hd main.o</code>, чтобы посмотреть содержимое, как есть (содержимое обрезано):</p>

<pre><code class="language-no-highlight">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|
00000020  00 00 00 00 00 00 00 00  e0 02 00 00 00 00 00 00  |................|
00000030  00 00 00 00 40 00 00 00  00 00 40 00 0e 00 0d 00  |....@.....@.....|
00000040  f3 0f 1e fa 55 48 89 e5  89 7d fc 8b 45 fc 83 c0  |....UH...}..E...|
00000050  01 5d c3 f3 0f 1e fa 55  48 89 e5 bf 02 00 00 00  |.].....UH.......|
00000060  e8 00 00 00 00 89 c6 48  8d 05 00 00 00 00 48 89  |.......H......H.|
00000070  c7 b8 00 00 00 00 e8 00  00 00 00 b8 00 00 00 00  |................|
00000080  5d c3 25 64 0a 00 00 47  43 43 3a 20 28 55 62 75  |].%d...GCC: (Ubu|
00000090  6e 74 75 20 31 31 2e 34  2e 30 2d 31 75 62 75 6e  |ntu 11.4.0-1ubun|
000000a0  74 75 31 7e 32 32 2e 30  34 29 20 31 31 2e 34 2e  |tu1~22.04) 11.4.|
000000b0  30 00 00 00 00 00 00 00  04 00 00 00 10 00 00 00  |0...............|
000000c0  05 00 00 00 47 4e 55 00  02 00 00 c0 04 00 00 00  |....GNU.........|
...</code></pre>

<p>Это мало что нам говорит. Для анализа объектных файлов есть специальные программы.</p>

<p><code>readelf</code> покажет нам структуру файла и содержимое некоторых секций (sections). Выполните <code>readelf main.o -a</code>.</p>

<pre><code class="language-no-highlight">ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
...
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000042  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000001f0
       0000000000000048  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000082
       0000000000000000  0000000000000000  WA       0     0     1
...
Relocation section '.rela.text' at offset 0x1f0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000021  000400000004 R_X86_64_PLT32    0000000000000000 foo - 4
00000000002a  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000037  000600000004 R_X86_64_PLT32    0000000000000000 printf - 4
...
Symbol table '.symtab' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     4: 0000000000000000    19 FUNC    GLOBAL DEFAULT    1 foo
     5: 0000000000000013    47 FUNC    GLOBAL DEFAULT    1 main
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
...</code></pre>

<p>Мы изучим это содержимое позже.</p>

<p><code>objdump</code> покажет нам машинный код на языке ассемблера. Выполните <code>objdump main.o -d</code>.</p>

<pre><code class="language-no-highlight">
main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt; foo&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 01             	add    $0x1,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    

0000000000000013 &lt; main&gt;:
  13:	f3 0f 1e fa          	endbr64 
  17:	55                   	push   %rbp
  18:	48 89 e5             	mov    %rsp,%rbp
  1b:	bf 02 00 00 00       	mov    $0x2,%edi
  20:	e8 00 00 00 00       	call   25 &lt;main+0x12&gt;
  25:	89 c6                	mov    %eax,%esi
  27:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 2e &lt;main+0x1b&gt;
  2e:	48 89 c7             	mov    %rax,%rdi
  31:	b8 00 00 00 00       	mov    $0x0,%eax
  36:	e8 00 00 00 00       	call   3b &lt;main+0x28&gt;
  3b:	b8 00 00 00 00       	mov    $0x0,%eax
  40:	5d                   	pop    %rbp
  41:	c3                   	ret</code></pre>

<p>Здесь объявлены две функции. В <code>&lt;&gt;</code> скобках показаны названия функций. Сравните их содержимое с результатом выполнения команды <code>gcc main.c -S</code>.</p><h3 id="3.1.5">3.1.5. Компоновка</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компоновка объединяет несколько объектных файлов, подставляет реализации функций, формирует сегменты (segments) из секций в объектных файлах. В результате мы получаем исполняемый файл (но можно получить и, например, shared object), который на ОС Linux не имеет расширения, а его формат называется <code>elf</code>; на ОС Windows имеет расширение <code>.exe</code>, а его формат называется <code>PE</code> (Portable Executable).</p>

<p>Выполните <code>gcc main.c</code>, чтобы выполнить компоновку. Выходной файл не состоит из читаемого текста. Рассматривать его мы не будем. Вместо этого выполним <code>readelf a.out -a</code>. (По умолчанию, выходной исполняемый файл называется <code>a.out</code>. Вы можете задать название явно с помощью флага <code>-o</code>: <code>gcc main.c -o program</code>.)</p>

<pre><code class="language-no-highlight">...
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000628 0x0000000000000628  R      0x1000
...
 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got</code></pre>

<p>Структура исполняемого файла похожа на структуру объектного файла. Однако здесь помимо секций у нас присутствуют и сегменты (по какой то причине, program headers это section headers). Обратите внимание на таблицу внизу, которая показывает, из каких секций состоит каждый сегмент. Например, сегмент под номером <code>01</code> (в первой таблице мы видим, что это сегмент с названием <code>INTERP</code> (по какой-то причине, они не пронумерованы, нумерация идет с <code>00</code>)) состоит из одной секции <code>.interp</code>. То, как происходит это сопоставление, написано в linker script-е. <code>gcc</code> имеет стандартный linker script, но мы можем написать свой (и мы это сделаем).</p>

<p>Выполним <code>objdump a.out -d</code>.</p>

<pre><code class="language-no-highlight">...
Disassembly of section .init:

0000000000001000 &lt;_init&gt;:
    1000:	f3 0f 1e fa          	endbr64 
    1004:	48 83 ec 08          	sub    $0x8,%rsp
    1008:	48 8b 05 d9 2f 00 00 	mov    0x2fd9(%rip),%rax        # 3fe8 &lt;__gmon_start__@Base&gt;
    100f:	48 85 c0             	test   %rax,%rax
    1012:	74 02                	je     1016 &lt;_init+0x16&gt;
    1014:	ff d0                	call   *%rax
    1016:	48 83 c4 08          	add    $0x8,%rsp
    101a:	c3                   	ret
...
Disassembly of section .text:

0000000000001060 &lt;_start&gt;:
    1060:	f3 0f 1e fa          	endbr64 
    1064:	31 ed                	xor    %ebp,%ebp
    1066:	49 89 d1             	mov    %rdx,%r9
    1069:	5e                   	pop    %rsi
    106a:	48 89 e2             	mov    %rsp,%rdx
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1071:	50                   	push   %rax
    1072:	54                   	push   %rsp
    1073:	45 31 c0             	xor    %r8d,%r8d
    1076:	31 c9                	xor    %ecx,%ecx
    1078:	48 8d 3d dd 00 00 00 	lea    0xdd(%rip),%rdi        # 115c &lt;main&gt;
    107f:	ff 15 53 2f 00 00    	call   *0x2f53(%rip)        # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;
    1085:	f4                   	hlt    
    1086:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    108d:	00 00 00
...
0000000000001149 &lt; foo&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
    1151:	89 7d fc             	mov    %edi,-0x4(%rbp)
    1154:	8b 45 fc             	mov    -0x4(%rbp),%eax
    1157:	83 c0 01             	add    $0x1,%eax
    115a:	5d                   	pop    %rbp
    115b:	c3                   	ret    

000000000000115c &lt; main&gt;:
    115c:	f3 0f 1e fa          	endbr64 
    1160:	55                   	push   %rbp
    1161:	48 89 e5             	mov    %rsp,%rbp
    1164:	bf 02 00 00 00       	mov    $0x2,%edi
    1169:	e8 db ff ff ff       	call   1149 &lt;foo&gt;
    116e:	89 c6                	mov    %eax,%esi
    1170:	48 8d 05 8d 0e 00 00 	lea    0xe8d(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1177:	48 89 c7             	mov    %rax,%rdi
    117a:	b8 00 00 00 00       	mov    $0x0,%eax
    117f:	e8 cc fe ff ff       	call   1050 &lt;printf@plt&gt;
    1184:	b8 00 00 00 00       	mov    $0x0,%eax
    1189:	5d                   	pop    %rbp
    118a:	c3                   	ret
...</code></pre>

<p>Количество кода резко увеличилось. Даже в секции <code>.text</code>, в которой раньше находились наши две функции, теперь присутствует множество новых функций. Все они были сгенерированы в результате выполнения linker script-а.</p>

<p>Обратите внимание на значение <code>Entry point address: 0x1060</code> в начале вывода программы <code>readelf</code>. Это адрес инструкции, с которой начнется выполнение программы. Попобуйте найти соответствующий адрес в выводе программы <code>objdump</code>. Это не функция <code>main</code>!</p><h3 id="3.1.6">3.1.6. Задача: О памяти</h3><p>Вспомним строку <code>Entry point address: 0x1060</code> из вывода программы <code>readelf</code> на исполняемый файл. Здесь имеется ввиду адрес в оперативной памяти (RAM). Значит ли это, что программа этой строкой уже решила, что она будет находится именно в этом месте памяти? А что будет, если мы запустим её дважды — как удовлетворить условие для обоих процессов?</p><h3 id="3.2">3.2. Многомодульные программы</h3><h3 id="3.2.1">3.2.1. Прототипы и реализации функций</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">int foo(int);

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p>В этой программе объявлена функция <code>foo</code>. Но её реализация отсутствует. Попробуем выполнить компиляцию без компоновки: <code>gcc main.c -c</code>. Компиляция завершена успешно и мы получили объектный файл <code>main.o</code>!</p>

<p>Если же мы попытаемся выполнить компоновку <code>gcc main.c</code>, то получим ошибку:</p>

<pre><code class="language-no-highlight">/usr/bin/ld: /tmp/cchwCA2L.o: in function `main':
main.c:(.text+0xe): undefined reference to `foo'
collect2: error: ld returned 1 exit status</code></pre>

<p>Задача компоновщика подставить реализации функций из других модулей, которые мы ему подали. Мы подали компоновщику единственный модуль, в котором он не нашел реализацию функции <code>foo</code>.</p>

<p>Как же выглядит функция <code>foo</code> в объектном файле, когда её реализация отсутствует? В инструкциях вызова этой функции не указывается её адрес (ведь он неизвестен). А информация о том, что этот адрес должен быть подставлен на этапе компоновки, хранится в секциях, в названии которых есть подстрока <code>rel</code> (проверьте, есть ли такие секции в вашем объектном файле).</p>

<p>Реализуем функцию <code>foo</code> в другом модуле.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}
</code></pre>

<p>Если мы попытаемся скомпилировать это в исполняемый файл, то получим ошибку   <code>undefined reference to `main' </code>. Скомпилируем в объектный файл <code>gcc foo.c -c</code>.      </p>

<p>Чтобы выполнить компоновку обоих объектных файлов, просто напишем их всех при вызове <code>gcc</code>: <code>gcc main.o foo.o</code>. Полученный исполняемый файл можно запустить.</p><h3 id="3.2.2">3.2.2. Заголовочные файлы</h3><p>В предыдущем примере мы, чтобы иметь возможность вызывать функцию <code>foo</code> в модуле <code>main.c</code>, объявили её: <code>int foo(int);</code>. Делать это таким способом не удобно. Для каждого <code>.c</code> файла создают заголовочный (header) <code>.h</code> файл, в котором записаны объявления функций, и который мы добавляем с помощью <code>#include</code>, чтобы получить эти объявления.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p>Скомпилировать такой проект можно так:</p>

<pre><code class="language-no-highlight">gcc main.c -c
gcc foo.c -c
gcc main.o foo.o</code></pre>

<p>, либо так: <code>gcc main.c foo.c</code></p>

<p>Обычно, внешние библиотеки распространяются только в виде заголовочных и объектных файлов; без исходного кода реализаций функций. (При этом объектные файлы могут быть объединены в архивы и/или быть shared.) При этом сами реализации функций могут быть и не на языке C (мы это сделаем позже).</p>

<p>Но как компилятор может удостовериться в том, что сигнатура функции в заголовочном файле соответствует её сигнатуре в реализации, когда компилятор видит только объектный файл? (Вам придется пока поверить мне, что общих способов узнать сигнатуру функции по объектному файлу нет.) Ответ простой — никак!</p>

<p>Изменим только файл <code>foo.c</code></p>

<pre><code class="language-cpp">void foo(int x) {
    
}</code></pre>

<p>Это успешно скомпилируется и скомпонуется, а значение, которое <code>printf</code> выведет, не имеет отношения к функции <code>foo</code>.</p><h3 id="3.2.3">3.2.3. Header Guards</h3><p>Разрешается объявлять функции в программе многократно, а определять их только единожды. По хорошему, реализации функций должны быть только в <code>.c</code> файлах (хотя в C++ есть способы делать это и в <code>.h</code> файлах).</p>

<p>Однако, в заголовочных файлах мы также объявляем структуры (ведь, если они используются другими модулями, они должны знать содержимое структуры). Структуры можно объявлять лишь единожды, что может вызвать проблемы.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">#include "boo.h"

int foo(int x) {
    if (x == 0)
        return x + 1;
    else
        return x + boo(x - 1);
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">struct foo {
    int x;
};</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">#include "boo.h"

void add(struct boo *b) {
    b-&gt;f.x++;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">#include "foo.h"

struct boo {
    struct foo f;
};

void add(struct boo *b);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"
#include "boo.h"

int main() {
    struct foo f;
    struct boo b;
    b.f.x = 3;
    add(&amp;b);
    return 0;
}</code></pre>

<p>В этой программе в модуле <code>main.c</code> структура <code>foo</code> объявлена дважды, что приводит к ошибке. Проблема в том, что и модулю <code>main.c</code>, и модулю <code>boo.c</code> необходима эта структура. Мы не можем убрать <code>#include "foo.h"</code> из <code>boo.h</code>, так как тогда в модуле <code>boo.c</code> не будет определена эта структура.</p>

<p>Данную проблему решают с помощью header guard-а (или include guard-а). Это простая конструкция для препроцессора.</p>

<pre><code class="language-cpp">#ifndef FOO
#define FOO

struct foo {
    int x;
};

#endif</code></pre>

<p>Напомню, что препроцессинг происходит независимо для каждого модуля, поэтому содержимое этого <code>if</code>-а будет добавлено лишь по одному разу в каждый из модулей.</p>

<p>Ещё один случай, при котором пригодится header guard: структура <code>foo</code> содержит указатель на <code>boo</code>, а структура <code>boo</code> содержит указатель на <code>foo</code>. В таком случае у нас будет два header файла, которые include друг-друга. Попробуйте проверить, что произойдет в таком случае при отсутствии header guard-а.</p>

<p>Иногда, вместо такой конструкции в самое начало файла вставляют такую строку: <code>#pragma once</code>, однако она есть не во всех компиляторах.</p><h3 id="3.2.4">3.2.4. Библиотеки .a</h3><p>Пусть мы хотим написать библиотеку, которая будет состоять из нескольких файлов, а соответственно, будет компилироваться в несколько объектных файлов. Хоть мы и можем написать под них общий заголовочный файл, пользователю всё равно придется добавить множество наших объектных файлов. Эту проблему можно решить, объединив наши объектные файлы в <code>.a</code> архив с помощью программы <code>ar</code>, что часто называют статической библиотекой.</p>

<p>Пусть наша библиотека выглядит так:</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p>Скомпилируем файлы нашей библиотеки в объектные файлы, а затем создадим архив с помощью программы <code>ar</code>:</p>

<pre><code class="language-no-highlight">gcc foo.c -c
gcc boo.c -c
ar -rc libfboo.a foo.o boo.o</code></pre>

<p>Флаг <code>-r</code> означает добавить указанные файлы в архив, заместив ими файлы с теми же названиями. Флаг <code>-c</code> означает создать архив, если его нет.</p>

<p>Файл библиотеки обязан начинаться с <code>lib</code>.</p>

<p>Пусть теперь пользователь хочет воспользоваться нашей библиотекой.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Тогда для выполнения компиляции ему необходимо будет упомянуть только архив:</p>

<pre><code class="language-no-highlight">gcc main.c -L. -lfboo</code></pre>

<p><code>-L.</code> означает искать файлы статических библиотек в директории <code>.</code> (то есть, в текущей). <code>-lfboo</code> означает прикомпоновать эту библиотеку. Обратите внимание на странный формат названий: <code>libfboo.a</code> -&gt; <code>lfboo</code>.</p>

<p>IDE Visual Studio имеет свой формат для статических библиотек — <code>.lib</code>, в то время как MinGW имеет формат <code>.a</code>.</p><h3 id="3.2.5">3.2.5. Shared Objects .so</h3><p>Shared object — это объектные файлы, которые прикомпоновываются к программам при их запуске. Они используются для оптимизации места на диске, так как их могут использовать различные программы, не повторяя реализации тех же функций. Часто shared objects называют динамическими библиотеками.</p>

<p>Оформим пример из предыдущего шага в виде динамической библиотеки. Скомпилируем библиотеку:</p>

<pre><code class="language-no-highlight">gcc foo.c boo.c -c
gcc -shared -o libfboo.so foo.c boo.c</code></pre>

<p>Во втором вызове <code>gcc</code> мы, с помощью флага <code>-shared</code>, создаём shared object.</p>

<p>Выполним <code>readelf libfboo.so -a</code>.</p>

<pre><code class="language-no-highlight">...
  Type:                              DYN (Shared object file)
...</code></pre>

<p>Полученный объектный файл пользователь может положить в директорию со своей программой и попросить <code>gcc</code> искать его там. Но это неправильно. Для того, чтобы библиотека была shared, она должна находиться в месте, где глобально хранятся все shared objects (в директории проекта должны быть только заголовочные файлы). Скопируем файл туда:</p>

<pre><code class="language-no-highlight">cp libfboo.so /usr/lib</code></pre>

<p>Теперь пользователь может скомпилировать свою программу:</p>

<pre><code class="language-no-highlight">gcc main.c -lfboo</code></pre>

<p>Чтобы посмотреть, какие shared objects требует исполняемый файл, введём <code>ldd a.out</code>.</p>

<pre><code class="language-no-highlight">	linux-vdso.so.1 (0x00007ffc58396000)
	libfboo.so =&gt; /lib/libfboo.so (0x00007171575e0000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x0000717157200000)
	/lib64/ld-linux-x86-64.so.2 (0x0000717157606000)</code></pre>

<p>Помимо <code>libfboo.so</code> здесь присутствует, например, <code>libc.so.6</code>.</p>

<p>Когда мы запускаем программу, загрузчик ищет shared objects:</p>

<ul>
	<li>В директориях <code>/lib*</code> и <code>/usr/lib*</code></li>
	<li>В директориях в environmental variable <code>LD_LIBRARY_PATH</code></li>
	<li>В директориях в <code>rpath</code>, который пишется в исполняемый файл в процессе компиляции с помощью флага <code>-rpath</code></li>
</ul>

<p>В ОС Windows формат динамических библиотек — <code>.dll</code>, и его использование выглядит значительно менее приятно, чем использование <code>.so</code> на Unix, так как требует использование директив компилятора. (Можете изучить пример: <a href="https://github.com/TransmissionZero/MinGW-DLL-Example" rel="noopener noreferrer nofollow">https://github.com/TransmissionZero/MinGW-DLL-Example</a>)</p><h3 id="3.2.6">3.2.6. Задача: Нужны ли заголовочные файлы?</h3><p>В современных системных языках отсутствуют заголовочные файлы. Импорт модуля в них обозначает обычно лишь добавление сигнатур функций. Есть ли реальная необходимость в заголовочных файлах?</p><h3 id="3.3">3.3. GNU make</h3><h3 id="3.3.1">3.3.1. Мотивация системы сборки</h3><p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Продолжим работать с той же программой. Можно сделать вывод, что процесс сборки такой программы уже нетривиальный, и мы тратим много времени на ввод повторяющегося набора команд. Чтобы решить эту проблему, мы можем написать все команды в один <code>shell</code> скрипт, и запускать его.</p>

<p><code>build.sh</code></p>

<pre><code class="language-no-highlight">rm foo.o boo.o main.o a.out
gcc foo.c -c
gcc boo.c -c
gcc main.c -c
gcc foo.o boo.o main.o</code></pre>

<p>Все команды, кроме первой, можно объединить в одну, но в целях наглядности проблемы я намеренно напишу их так.</p>

<p>Обратите внимание на первую команду: удаление всех файлов, полученных в результате компиляции. Зачем это необходимо? Если мы допустим ошибку компиляции в одном из модулей, то соответствующий объектный файл не сформируется. Однако старый не будет удален, и скрипт продолжит выполняться. В результате мы получим либо ошибку компоновки, либо скомпонованную программу, один из модулей в которой устаревший.</p>

<p>Обратите внимание на такую проблему. Пусть мы изменили реализацию функции <code>foo</code> (но не её сигнатуру). Конечно, модуль <code>foo</code> следует перекомпилировать. Но нет смысла в перекомпиляции других модулей, ведь они никак не изменились.</p>

<p>Обратите внимание на строки 2-4 скрипта — их выполнение является независимым, и мы можем их выполнить одновременно. Сделать это с помощью <code>shell</code> скрипта непросто.</p>

<p>Пусть у нас программа является составной. Например, у нас есть компилятор и его стандартная библиотека. Скорее всего компилятору понадобиться стандартная библиотека, но в то же время, если мы хотим собрать стандартную библиотеку, нам не требуется собирать компилятор.</p>

<p>Итак, мы сформировали несколько проблем, которые решает программа <code>make</code>:</p>

<ol>
	<li>Выполнение этапа сборки только в том случае, если её результат устарел.</li>
	<li>Автоматическое распараллеливание этапов сборки.</li>
	<li>Разделение сборки на этапы и автоматическое рекурсивное определение необходимых этапов для сборки текущего этапа.</li>
</ol><h3 id="3.3.2">3.3.2. Простые рецепты</h3><p>В большинстве дистрибутивов программа <code>make</code> отсутствует. Поставьте её. Из-за особенности её названия, более разумным будет использовать <code>GNU make</code> как ключевую строку.</p>

<p>Начнём с простого make-файла. Для наглядности будем компилировать модули <code>foo</code> и <code>boo</code> с статическую библиотеку.</p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">lib:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o
	gcc main.c -L. -lfboo</code></pre>

<p>Здесь определены два рецепта: <code>lib</code> и <code>program</code>. Чтобы выполнить их, необходимо ввести <code>make lib</code> или <code>make program</code> соответственно. Первый рецепт собирает только библиотеку (пусть, например, пользователю может пригодиться только она), а второй и библиотеку, и саму программу.</p>

<p>Важно: в make-файлах требуется использовать символы табуляции, вместо пробелов. Добавьте соответствующую настройку в ваш text editor, если требуется (VS Code, например, сам ставит табуляции в make-файлах).</p>

<p>Содержимое рецептов — это почти обычные <code>shell</code> команды. Однако они запускаются не в одной <code>shell</code>-сессии, а в разных, что иногда важно.</p>

<p>Мы можем упростить наш make-файл: рецепт сборки программы включает в себя содержимое рецепта сборки библиотеки. Мы можем в требование одного рецепта вписать название другого рецепта.</p>

<pre><code class="language-makefile">lib:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program: lib
	gcc main.c -L. -lfboo</code></pre>

<p>В этом случае, перед выполнением рецепта <code>program</code> будет выполнен рецепт <code>lib</code>. Важно отметить, что рецепт <code>lib</code> будет выполнен в любом случае и полностью, а значит, экономии ресурсов мы пока не добились.</p>

<p>Добавим рецепт на удаление временных файлов:</p>

<pre><code class="language-makefile">...
clean:
	rm libfboo.a foo.o boo.o main.o a.out</code></pre>

<p>Его не следует добавлять в зависимости другим рецептам, так как удаление всех файлов сделает необходимой полную перекомпиляцию.</p>

<p>Обратите внимание, что <code>make</code> является ленивым языком. (Можете теперь рассказывать программистам на <code>haskell</code>-е, что тоже в некотором смысле пишете на ленивом языке.)</p><h3 id="3.3.3">3.3.3. Зависимости в рецептах</h3><p>Заменим название рецепта <code>lib</code> на <code>libfboo.a</code>.</p>

<pre><code class="language-makefile">libfboo.a:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program: libfboo.a
	gcc main.c -L. -lfboo
...</code></pre>

<p>На самом деле, <code>lib</code> и <code>libfboo.a</code> в этом месте обозначает не просто название рецепта, а файл, который эти рецепты производят. Конечно, на прошлом шаге рецепт <code>lib</code> не производил файл <code>lib</code>, и так делать разрешено. Теперь же, когда файл в процессе выполнения рецепта производится, логика его выполнения усложняется. Рецепт выполняется только если его целевой файл отсутствует, либо один из файлов, от которых рецепт зависит, стал новее его целевого файла (это мы увидим чуть позже).</p>

<p>Выполните <code>make program</code> несколько раз. Вы увидите, что инструкции в рецепте <code>libfboo.a</code> были выполнены лишь при первой сборке, так как уже после неё файл <code>libfboo.a</code> был создан.</p>

<p>Таким образом мы впервые добились того, что перекомпиляция происходит только для обновленных модулей. Сделаем то же самое и для итогового файла <code>a.out</code>, так как он по прежнему собирается в любом случае.</p>

<pre><code class="language-makefile">libfboo.a:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Теперь, при втором вызове <code>make program</code> вы получите сообщение: <code>make: Nothing to be done for 'program'.</code>. Обратите внимание, что инструкции в рецепте <code>program</code> исполняются, ведь файла <code>program</code> нет (можете это проверить, вставив в рецепт любые инструкции). Но рецепт <code>a.out</code> не был выполнен, так как файл <code>a.out</code> моложе всех зависимостей — единственного файла <code>libfboo.a</code>.</p>

<p>Изменим файл <code>libfboo.a</code>. Здесь есть проблема: его пересборка на <code>make libfboo.a</code> будет выполнена только в том случае, если файла <code>libfboo.a</code> нет, ведь мы не написали для этого рецепта никаких зависимостей (сейчас мы это исправим). Поэтому просто удалим <code>libfboo.a</code> и сделаем <code>make libfboo.a</code>. Теперь при вызове <code>make program</code> будет выполнена перекомпиляция <code>a.out</code>.</p>

<p>Добавим зависимости для рецепта <code>libfboo.a</code>.</p>

<pre><code class="language-makefile">libfboo.a: foo.c boo.c
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o
...</code></pre>

<p>Теперь при изменения файла <code>foo.c</code> или <code>boo.c</code> будет выполнена пересборка <code>libfboo.a</code> на команду <code>make libfboo.a</code>. Но, более того, будет выполнена пересборка <code>libfboo.a</code> и на команду <code>make program</code>. Это означает, что <code>make</code> проверяет необходимость пересборки не только в текущей точке, но и по всему дереву.</p><h3 id="3.3.4">3.3.4. Распараллеливание</h3><p>Попробуем добиться распараллеливания. Мы хотим, чтобы компиляция модулей <code>foo</code>  и <code>boo</code> велась параллельно. Сделать это легко.</p>

<pre><code class="language-makefile">foo.o: foo.c
	gcc foo.c -c

boo.o: boo.c
	gcc boo.c -c

libfboo.a: foo.o boo.o
	ar -rc libfboo.a foo.o boo.o

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Сделаем новые рецепты на компиляцию каждого их этих модулей. Пусть сборка библиотеки зависит от объектных файлов этих модулей. Теперь <code>make</code> будет распараллеливать выполнение рецептов <code>foo.o</code> и <code>boo.o</code>, так как для них обоих удовлетворены условия. Чтобы выполнить сборку с помощью двух процессов, введите <code>make program -j 2</code>.</p>

<p>Для того, чтобы удостовериться, что сборка действительно идёт параллельно, напишем такой make-файл.</p>

<pre><code class="language-makefile">foo.o: foo.c
	sleep 3
	gcc foo.c -c

boo.o: boo.c
	sleep 3
	gcc boo.c -c
...</code></pre>

<p>Обе паузы при запуске <code>sleep</code> пройдут одновременно.</p>

<p>Представьте теперь, что у вас много модулей. Писать для каждого из них такой рецепт долго и усложняет чтение make-файла. <code>make</code> имеет способ решения этого.</p>

<pre><code class="language-makefile">%.o: %.c
	gcc $&lt; -c

libfboo.a: foo.o boo.o
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Посмотрите на первый "универсальный" рецепт. Он означает следующее: для того, чтобы собрать файл с названием <code>xxx.o</code> необходим файл <code>xxx.c</code>. Чтобы иметь доступ к необходимому файлу <code>xxx.c</code> в самом скрипте, необходимо использовать оператор <code>$&lt;</code>.</p>

<p>Посмотрите на рецепт <code>libfboo.a</code>. Вместо оператора <code>$^</code>, будут подставлены все требования, то есть, <code>foo.o boo.o</code>. Если бы мы написали оператор <code>$^</code>, то было бы подставлено только первое требование: <code>foo.o</code>.</p>

<p>Существует ещё один оператор: <code>$@</code>, вместо которого подставляется файл-цель. В примере с рецептом <code>xxx.o</code> вместо оператора <code>$@</code> будет подставлено <code>xxx.o</code>.</p><h3 id="3.3.5">3.3.5. Автоматический поиск файлов</h3><p>Мы добились поставленных целей с помощью <code>make</code>. Тем не менее продолжим улучшать читаемость и организацию make-скриптов.</p>

<pre><code class="language-makefile">OBJS=foo.o boo.o

%.o: %.c
	gcc $&lt; -c

libfboo.a: $(OBJS)
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Мы можем вынести список целевых объектных файлов в отдельную переменную, и писать её, вместо файлов. (Важно: это не environmental variables, хоть и их синтаксис похож. Они не будут проталкиваться в программы, которые вы запускаете.)</p>

<p>Пойдем дальше. Если мы перенесем файлы <code>foo.c</code> и <code>boo.c</code> в отдельную директорию, то мы можем определять целевые файлы автоматически по контенту этой директории. Тогда, когда мы добавим в директорию (и, соответственно, в библиотеку) новый файл, нам не придется изменять make-файл. Перенесем <code>foo.c</code> и <code>boo.c</code> в директорию <code>lib</code>.</p>

<p>Для определения списка файлов мы можем написать что-то вроде <code>SRCS=$(shell ls lib)</code>. (Оператор <code>shell</code> запускает программу и возвращает её вывод. Присутствует не во всех программах <code>make</code>.) Вместо этого воспользуемся оператором <code>wildcard</code>.</p>

<pre><code class="language-makefile">SRCS=$(wildcard lib/*.c)</code></pre>

<p>Смысл этого оператора очевиден. В результате его выполнения, переменная <code>SRCS</code> будет равна <code>lib/foo.c lib/boo.c</code>. Для удобства вывода значений переменных можно воспользоваться оператором <code>info</code>.</p>

<pre><code class="language-makefile">$(info $(SRCS))</code></pre>

<p>Однако, нам необходимы не исходные <code>.c</code> файлы, а объектные файлы. Можно снова пошаманить со строками, а можно воспользоваться оператором <code>patsubst</code>.</p>

<pre><code class="language-makefile">OBJS=$(patsubst lib/%.c, %.o, $(SRCS))</code></pre>

<p>Смысл этого оператора тоже почти очевиден. Вы пробегаемся по каждому слову в третьем аргументе <code>$(SRCS)</code>, и преобразовываем каждое слово из формата <code>lib/xxx.c</code> в  <code>xxx.o</code>.</p>

<p>Обратите внимание, что в результате такого вызова <code>OBJS=$(patsubst %.c, %.o, $(SRCS))</code> значение <code>OBJS</code> будет <code>lib/boo.o  lib/foo.o</code>, что немного не то, что мы хотим.</p>

<p>Обратите внимание на то, что переменная <code>SRCS</code>, кроме формирования переменной <code>OBJS</code>, больше ни на что не влияет, и в рецепте <code>%.o</code> в требованиях теперь находятся несуществующие файлы (например, <code>foo.o</code> требует <code>foo.c</code>, когда его настоящее имя теперь <code>lib/foo.c</code>). Заменим требование на <code>lib/%.c</code>.</p>

<p>Наш итоговый make-файл на текущий момент:</p>

<pre><code class="language-makefile">SRCS=$(wildcard lib/*.c)
OBJS=$(patsubst lib/%.c, %.o, $(SRCS))

%.o: lib/%.c
	gcc $&lt; -c

libfboo.a: $(OBJS)
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre><h3 id="3.3.6">3.3.6. Вложенные Makefiles</h3><p>На предыдущем шаге мы начали изменять организацию нашего проекта в лучшую сторону, когда переместили файлы библиотеки <code>lfboo</code> в отдельную директорию. Выполним теперь правильную организацию проекта полностью. К сожалению, в языке C нет стандарта организации проекта. Я покажу один из способов. Для большей наглядности в некоторых местах я добавлю больше файлов и модулей.</p>

<p>Начнем с основной программы. Её <code>.c</code> файлы будут лежать в директории <code>src</code>, а <code>.h</code> файлы будут лежать в директории <code>include</code>. Мы добавим туда ещё один модуль <code>goo</code>.</p>

<p><code>src/goo.c</code></p>

<pre><code class="language-cpp">int goo(int x) {
    return x + 4;
}</code></pre>

<p><code>include/goo.h</code></p>

<pre><code class="language-cpp">int goo(int x);</code></pre>

<p><code>src/main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;fboo/fboo.h&gt;
#include &lt;doo/doo.h&gt;
#include &lt;goo.h&gt;

int main() {
    printf("%d\n", foo(2) + boo(2) + doo(2) + goo(2));
    return 0;
}</code></pre>

<p>Создадим директорию <code>build</code>, в которую будем складировать объектные файлы и финальный исполняемый файл. В результате компиляции файла <code>xxx/src/yyy.c</code> будет получаться файл <code>build/xxx/yyy.o</code>. (Например, <code>src/main.c</code> -&gt; <code>build/main.o</code>, <code>lib/fboo/src/foo.c</code> -&gt; <code>build/fboo/foo.o</code>.)</p>

<p>Библиотеки мы будем хранить в директории <code>lib</code>. В директории каждой библиотеки также будут директории <code>src</code> и <code>include</code>. Кроме того, библиотеки будут иметь публичный заголовочный файл (в данном случае <code>lib/fboo/fboo.h</code>) в корне директории библиотеки, на который мы и будем ссылаться из основной программы.</p>

<p><code>lib/fboo/src/foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>lib/fboo/src/boo.c</code></p>

<pre><code class="language-cpp">#include &lt;box.h&gt;

int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>lib/fboo/include/box.h</code></p>

<pre><code class="language-cpp">struct box {
    int x;
};</code></pre>

<p><code>lib/fboo/fboo.h</code></p>

<pre><code class="language-cpp">int foo(int x);
int boo(int x);</code></pre>

<p>Для удобства в директории каждой библиотеки будет свой <code>Makefile</code>.</p>

<p><code>lib/fboo/Makefile</code></p>

<pre><code class="language-makefile">SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/fboo/%.o, $(SRCS))
CFLAGS+=-Iinclude

$(BUILD_DIR)/fboo/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/fboo/libfboo.a: $(OBJS)
	ar -rc $@ $^

fboo: $(BUILD_DIR)/fboo/libfboo.a

prepare:
	mkdir -p $(BUILD_DIR)/fboo

clean:
	rm -rf $(BUILD_DIR)/fboo</code></pre>

<p>Здесь переменная <code>$(BUILD_DIR)</code> равна абсолютному пути директории <code>build</code>, и будет нам передана "верхним" make-файлом. Для того, чтобы уже сейчас проверить этот файл, мы можем добавить <code>BUILD_DIR=../../build</code> и вызвать <code>make fboo</code> из директории <code>lib/fboo</code>. Флаг <code>-Iinclude</code> нам необходим, чтобы файлы в директории <code>lib/fboo/include</code> были видимы. С помощью рецепта <code>prepare</code> мы создаём директорию <code>build/fboo</code>, так как <code>gcc</code> не создаёт её самостоятельно.</p>

<p>Организуем таким же образом библиотеку <code>doo</code>.</p>

<p><code>lib/doo/src/doo.c</code></p>

<pre><code class="language-cpp">int doo(int x) {
    return x + 3;
}</code></pre>

<p><code>lib/doo/doo.h</code></p>

<pre><code class="language-cpp">int doo(int x);</code></pre>

<p><code>lib/doo/Makefile</code></p>

<pre><code class="language-makefile">SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/doo/%.o, $(SRCS))
CFLAGS+=-Iinclude

$(BUILD_DIR)/doo/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/doo/libdoo.a: $(OBJS)
	ar -rc $@ $^

doo: $(BUILD_DIR)/doo/libdoo.a
	echo $(BUILD_DIR)

prepare:
	mkdir -p $(BUILD_DIR)/doo

clean:
	rm -rf $(BUILD_DIR)/doo</code></pre>

<p>Здесь также можно абстрагировать название модуля <code>doo</code>.</p>

<p>Напишем, наконец, главный <code>Makefile</code></p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">BUILD_DIR=$(abspath build)
SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/%.o, $(SRCS))
LIBS=$(BUILD_DIR)/fboo/libfboo.a $(BUILD_DIR)/doo/libdoo.a
CFLAGS+=-Iinclude -Ilib

$(BUILD_DIR)/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/fboo/libfboo.a:
	$(MAKE) -C lib/fboo fboo BUILD_DIR=$(BUILD_DIR)

$(BUILD_DIR)/doo/libdoo.a:
	$(MAKE) -C lib/doo doo BUILD_DIR=$(BUILD_DIR)

$(BUILD_DIR)/program: $(OBJS) $(LIBS)
	gcc $(OBJS) $(LIBS) -o $@

program: $(BUILD_DIR)/program

prepare:
	mkdir -p $(BUILD_DIR)

clean:
	rm -rf $(BUILD_DIR)</code></pre>

<p>Для начала, мы создаём переменную <code>BUILD_DIR</code>, в которую записываем абсолютный путь директории <code>build</code>, который мы добываем с помощью функции <code>abspath</code>. К флагам мы добавляем флаг <code>-Ilib</code>, чтобы мы могли добавлять файлы из библиотек.</p>

<p>С помощью <code>$(MAKE) -C dir recipe</code> мы рекурсивно вызываем <code>make</code> в директории <code>dir</code> с рецептом <code>recipe</code>. Мы проталкиваем к дочернему <code>make</code> переменную <code>BUILD_DIR</code> с помощью <code>BUILD_DIR=$(BUILD_DIR)</code>.</p>

<p>Для того, чтобы получить исполняемый файл <code>build/program</code> необходимо ввести <code>make program</code> (либо <code>make dir</code>, где <code>dir</code> это абсолютный путь до исполняемого файла, но так менее удобно).</p>

<p>В этом make-файле есть недостатки. Например, названия библиотек недостаточно абстрагированы. Я намеренно не стал этим усложнять пример.</p><h3 id="3.3.7">3.3.7. Задача: Улучшение структуры Makefiles</h3><p>Попробуйте найти недостатки в организации проекта, который показан на предыдущем шаге, и исправить их.</p><h3 id="3.3.8">3.3.8. Задача: Как быть с заголовочными файлами?</h3><p>До сих пор мы рассматривали только зависимости от <code>.c</code> файлов. Пусть теперь мы изменили <code>.h</code> файл. В таком случае, необходима перекомпиляция всех модулей, которые его добавляют. К сожалению, нет адекватных общих способов определить это множество модулей. Исследуйте способы, как эта проблема может быть решена.</p><h3 id="3.3.9">3.3.9. Проект: Программа со структурой</h3><p>Напишите любую программу (полная свобода мысли) вместе с несколькими её библиотеками и систему сборки для неё. Используйте контент шестого шага в качестве образца.</p><h2 id="4">4. Unix</h2><h3 id="4.1">4.1. Shell</h3><h3 id="4.1.1">4.1.1. Терминал и простые cli программы</h3><p>Разберемся подробнее в том, что такое "терминал". Запустите терминал. У вас начнется сессия с командной оболочкой (shell). В зависимости от вашего дистрибутива, запускаемая оболочка может быть различной. Однако, скорее всего, в вашем дистрибутиве по умолчанию будет запущен <code>bash</code>. Существуют другие оболочки: например, древняя и более примитивная <code>sh</code>, или более продвинутая <code>zsh</code>. Начнем с <code>sh</code>. Введите <code>sh</code> в терминале, чтобы запустить его. Какие при этом происходят действия, мы узнаем немного позже.</p>

<p>Prompt (приглашение) в <code>sh</code> очень простое — <code>$</code>. Чтобы запустить локальную программу в любом shell, необходимо ввести <code>./program</code>, где program — название исполняемого файла. Чтобы запустить глобальную программу, необходимо просто ввести название её исполняемого файла. Shell будет искать этот исполняемый файл во всех директориях, которые записаны в переменной <code>PATH</code> (об этом позже).</p>

<p>Чтобы узнать текущую директорию, в которой мы находимся, можно воспользоваться программой <code>pwd</code>.</p>

<pre><code class="language-no-highlight">$ pwd
/home/igor/test</code></pre>

<p>Чтобы создать папку, можно воспользоваться программой <code>mkdir</code>.</p>

<pre><code class="language-no-highlight">$ mkdir dir</code></pre>

<p>Чтобы посмотреть все файлы в текущей директории, можно воспользоваться программой <code>ls</code>.</p>

<pre><code class="language-no-highlight">$ ls
dir</code></pre>

<p>Чтобы сменить директорию, воспользуйтесь <strong>командой</strong> <code>cd</code>.</p>

<pre><code class="language-no-highlight">$ cd dir
$ pwd
/home/igor/test/dir</code></pre>

<p>Чтобы создать файл, можно воспользоваться программой <code>touch</code>.</p>

<pre><code class="language-no-highlight">$ touch file
$ ls
file</code></pre>

<p>Чтобы редактировать файл в терминале, можно воспользоваться одним из текстовых редакторов: <code>nano</code>, <code>vim</code>, etc. (Их необходимо осваивать отдельно.)</p>

<p>Чтобы вывести содержимое файла в текстовом, можно воспользоваться программой <code>cat</code>.</p>

<pre><code class="language-no-highlight">$ cat file
A dog</code></pre>

<p>Чтобы вывести содержимое файла в hex, можно воспользоваться программой <code>hd</code>.</p>

<pre><code class="language-no-highlight">00000000  41 20 64 6f 67 0a                                 |A dog.|
00000006</code></pre>

<p>Чтобы узнать расположение исполняемого файла программы, можно воспользоваться программой <code>which</code>.</p>

<pre><code class="language-no-highlight">$ which ls
/usr/bin/ls
$ which which
/usr/bin/which
$ which cd</code></pre>

<p>Чтобы удалить файл, можно воспользоваться программой <code>rm</code>.</p>

<pre><code class="language-no-highlight">$ rm file
$ ls</code></pre>

<p>Чтобы перейти не папку наверх, необходимо аргументом к команде <code>cd</code> написать <code>..</code>.</p>

<pre><code class="language-no-highlight">$ cd ..</code></pre>

<p>Чтобы удалить папку, можно воспользоваться программой <code>rmdir</code>.</p>

<pre><code class="language-no-highlight">$ rmdir dir
$ ls</code></pre><h3 id="4.1.2">4.1.2. Фоновые процессы</h3><p>Чтобы "зависнуть" на некоторое время, можно воспользоваться программой <code>sleep</code>.</p>

<pre><code class="language-no-highlight">$ sleep 5</code></pre>

<p>Можно выполнить процесс "на фоне" (background), то есть, shell не будет ждать завершения процесса, а продолжит выполнять команды. Для этого в конце команды следует написать <code>&amp;</code>.</p>

<pre><code class="language-no-highlight">$ sleep 5 &amp;
$ pwd
/home/igor/test
$ 
[1] + Done                       sleep 5</code></pre>

<p>Здесь, после ввода первой команды я сразу же ввёл вторую команду. После ввода очередной команды shell уведомляет о завершенных фоновых командах.</p>

<p>Когда у вас выполняется программа не на фоне, вы можете нажать комбинацию <code>Ctrl + Z</code>. Данная комбинация ставит процесс на паузу и помещает его наверх специального буфера. Чтобы возобновить процесс с вершины буфера, введите <strong>команду</strong> <code>fg</code> (foreground).</p>

<pre><code class="language-no-highlight">$ sleep 5
^Z[1] + Stopped                    sleep 5
$ fg
sleep 5</code></pre>

<p>Обратите внимание (при личном тесте), что между нажатием комбинации Ctrl + Z и введением команды fg, таймер продолжает идти (то есть, программа <code>sleep</code> игнорирует просьбу о паузе). Пока таймер не истёк, вы не можете вводить команды, так как команда выполняется не на фоне.</p>

<p>Чтобы возобновить программу из буфера на фоне, вместо команды <code>fg</code> введите команду <code>bg</code> (background).</p>

<pre><code class="language-no-highlight">$ sleep 5
^Z[1] + Stopped                    sleep 5
$ bg
[1] sleep 5
$ 
[1] + Done                       sleep 5</code></pre>

<p>Обратите внимание (хотя это и не так важно), что буфер имеет форму стека (то есть берётся последний пришедший).</p>

<pre><code class="language-no-highlight">$ sleep 5
^Z[1] + Stopped                    sleep 5
$ sleep 6
^Z[2] + Stopped                    sleep 6
$ bg
[2] sleep 6
$ bg
[1] sleep 5</code></pre><h3 id="4.1.3">4.1.3. Потоки Streams</h3><p>Запустим программу <code>grep</code> которая принимает как аргумент слово и ищет его в своём стандартном вводе (stdin). Как только она на очередной строке, ограниченной символом <code>\n</code> находит слово, как подстроку, она выводит всю строку.</p>

<p>Как только вы запустим программу, которая ожидает данные в стандартном вводе, мы увидем в терминале не prompt, а пустую строку. Каждая наша строка, которую мы завершаем нажатием enter-а, передаётся программе в её стандартный ввод. В свою очередь, программа может что-то выводить в свой стандартный вывод (stdout), и мы также его будем видеть.</p>

<pre><code class="language-no-highlight">$ grep a  
aaa
aaa
bbb
aba
aba</code></pre>

<p>Первую, третью и четвёртую строку ввёл я. Вторую и пятую строку вывода вывела программа grep. Всё, что мы ввели будет передаваться программе grep, пока она не закроет свой stdin, однако она его никогда не закроет. Чтобы нам закрыть его, мы должны нажать комбинацию <code>Ctrl + D</code>.</p>

<p>Мы пожем связать стандартый вывод программы с файлом. Тогда всё, что она выводит, окажется в файле. Для этого, следует к команде добавить <code>&gt; file</code>.</p>

<pre><code class="language-no-highlight">$ grep a &gt; file
aaa
bbb
aba
$ cat file
aaa
aba</code></pre>

<p>При такой команде всё, что было до этого в файле, удаляется. Чтобы вместо этого выполнить дозапись в файл, следует вместо <code>&gt;</code> написать <code>&gt;&gt;</code>.</p>

<p>Можно также связать стандартный ввод программы с файлом с помощью оператора <code>&lt;</code>. Программа <code>echo</code> выводит в стандартный вывод единственный свой аргумент.</p>

<pre><code class="language-no-highlight">$ echo aaa &gt; file
$ echo bbb &gt;&gt; file
$ echo aba &gt;&gt; file
$ grep a &lt; file
aaa
aba</code></pre>

<p>Можно запустить две программы и связать стандартный вывод одной со стандартным вводом в другой. Для этого необходимо воспользоваться оператором <code>|</code> (pipe).</p>

<pre><code class="language-no-highlight">$ cat file | grep a
aaa
aba</code></pre>

<p>Stdin и stdout — это streams. (Данное слово, как и слова thread и flow переведены на русский язык, как поток. Причём, по смыслу эти три слова совсем не близки.) Есть ещё один частоиспользуемый stream — стандартный вывод ошибок (stderr). В него обычно пишут программы при нарушении правил общения с ними.</p>

<p>В терминале мы видим и stdout и stderr от выполняемой программы, и отличить их нельзя. Попробуем перенаправить stdout у этой команды.</p>

<pre><code class="language-no-highlight">$ ls dirrr &gt; out
ls: cannot access 'dirrr': No such file or directory
$ cat out</code></pre>

<p>Не перенаправилось. Значит, эту строку ls вывел в stderr. Чтобы перенаправить его, следует воспользоваться оператором <code>2&gt;</code>.</p>

<pre><code class="language-no-highlight">$ ls dirrr 2&gt; out
$ cat out
ls: cannot access 'dirrr': No such file or directory</code></pre>

<p>Чтобы перенаправить оба потока в один файл, следует написать так.</p>

<pre><code class="language-no-highlight">$ ls &gt; out 2&gt;&amp;1</code></pre>

<p>Чтобы в программе на C выполнить вывод в stderr, можно воспользоваться функцией <code>fprintf</code>, которая первым аргументом принимет дескриптор stream-а. Дескриптор stderr-а храниться в глобальной переменной <code>stderr</code>.</p>

<pre><code class="language-cpp">fprintf(stderr, "%d\n", 42);</code></pre>

<p>Теперь мы можем понять, что когда мы в самом начале запустили <code>sh</code>, то мы начали с ним интерактивную сессию, такую же, как и с <code>grep</code> здесь. Мы можем её прервать комбинацией <code>Ctrl + D</code>.</p><h3 id="4.1.4">4.1.4. Аргументы программы и переменные среды</h3><p>Когда вы вводите команду <code>cat file</code>, вы запускаете программу <code>cat</code> и передаёте ей аргумент <code>file</code>. Посмотрим, как эти аргументы можно читать из программы на C.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>На самом деле, в функцию <code>main</code> передаётся два аргумента — количество аргументов программы <code>argc</code>, и массив этих аргументов <code>argv</code>, которые являются строками. (На ещё более самом деле, в функцию main может передаваться аргумент <code>envp</code>, но он есть не на всех системах.) Благодаря том, как устроен application binary interface, мы можем просто не писать суффикс аргументов, и это не вызовет никаких проблем. Подробнее об этом мы узнаем позже.</p>

<p>Данная программа просто выводит аргументы. Потестируем её.</p>

<pre><code class="language-cpp">$ ./main
./main
$ /home/igor/test/main	
/home/igor/test/main
$ ./main a -b c
./main
a
-b
c</code></pre>

<p>Аргументы вида <code>--help</code> и <code>-h</code> называются флагами. Используются также аргументы вида <code>--output=file</code>. Сам shell никак не задаёт формат аргументов: вам необходимо обработать его самостоятельно.</p>

<p>Обратите внимание, что первым аргументом программы получают путь к своему исполняемому файлу. Когда мы будем запускать программы с помощью системного вызова <code>exec</code>, мы сможем нарушить это правило. В таком случае, некоторые программы могут отказаться работать.</p>

<p>Чтобы считать переменные среды (environmental variables), можно воспользоваться третьим аргументом <code>envp</code>.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp) {
    int i;
    for (i = 0; envp[i] != NULL; i++) {
        printf("%s\n", envp[i]);
    }
    return 0;
}</code></pre>

<p>Массив <code>envp</code>, в отличии от <code>argv</code>, является ноль-терминированным. (Напомню, что это по сути два способа хранения массивов: либо хранить отдельно длину массива, либо завершать его нулем.)</p>

<pre><code class="language-no-highlight">$ ./main
LESSOPEN=| /usr/bin/lesspipe %s
no_proxy=localhost,127.0.0.0/8,::1
USER=igor
LC_TIME=ru_RU.UTF-8
all_proxy=socks://127.0.0.1:1080/
XDG_SESSION_TYPE=x11
SHLVL=1
HOME=/home/igor
...</code></pre>

<p>Мы можем установить значение переменной в sh с помощью оператора <code>export</code>. Чтобы получить значение переменной, нужно перед её названием написать символ <code>$</code>.</p>

<pre><code class="language-no-highlight">$ export DOG=Shepherd
$ echo $DOG</code></pre>

<p>Переменные среды видны всем процессам-потомкам, то есть, в том числе тем, которые запущены в данном sh.</p>

<pre><code class="language-no-highlight">$ ./main | grep DOG
DOG=Shepherd</code></pre>

<p>Один из других способов вывести переменные среды — это воспользоваться глобальной переменной <code>environ</code>.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

extern char **environ;

int main(int argc, char **argv) {
    int i;
    for (i = 0; environ[i] != NULL; i++) {
        printf("%s\n", environ[i]);
    }
    return 0;
}</code></pre>

<p>Ключевое слово <code>extern</code> достаёт на этапе компоновки переменную <code>environ</code> из другого модуля, так как эта переменная не определена в заголовочных файлах. Переменна environ определена где-то в файлах <code>libc</code>. Конечно, использование extern-а считается плохой практикой.</p>

<p>Чтобы установить значение переменной, можно воспользоваться функцией <code>int setenv(const char *name, const char *value, int overwrite);</code>. Если overwrite равен нулю, то она записывает value в name, только если name не определено. В противном случае, записывает всегда.</p>

<p>Чтобы прочитать значение переменной, можно воспользоваться функцией <code>char *getenv(const char *name);</code>. В случае, если переменная name отсутствует, функция возвратит <code>NULL</code>.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
    printf("%s\n", getenv("HOME"));
    setenv("HOME", "/bin", 0);
    printf("%s\n", getenv("HOME"));
    setenv("HOME", "/bin", 1);
    printf("%s\n", getenv("HOME"));
    printf("%d\n", getenv("HOM"));
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ ./main
/home/igor
/home/igor
/bin
0</code></pre><h3 id="4.1.5">4.1.5. Код возврата процесса</h3><p>Когда мы запускаем программу, запускается процесс, выполняющий эту программу. После завершения каждый процесс возвращает число. По хорошему, при успешном завершении процесс должен возвращать ноль, а при неуспешном — не ноль. Узнать, какое число вернул последний процесс, мы можем, напечатав значение переменной <code>$?</code>.</p>

<pre><code class="language-no-highlight">$ pwd	
/home/igor/test
$ echo $?
0
$ gcc
gcc: fatal error: no input files
compilation terminated.
$ echo $?
1
$ gcc main.c -o main
$ echo $?
0</code></pre>

<p>Когда мы пишем shell-скрипты, мы так проверяем, был ли запуск программы успешен.</p>

<p>Чтобы выполнить несколько программ друг за другом, мы можем написать их на одной строке, разделив символом <code>;</code>.</p>

<pre><code class="language-no-highlight">$ pwd ; ls
/home/igor/test
main  main.c</code></pre>

<p>Чтобы выполнять программы из списка, пока одна из них не завершится успешно (вернёт 0), мы можем написать их на одной строке, разделив оператором <code>||</code>.</p>

<pre><code class="language-no-highlight">$ pwd || ls
/home/igor/test
$ gcc || ls
gcc: fatal error: no input files
compilation terminated.
main  main.c</code></pre>

<p>В первом случае программа pwd завершилась успешно, поэтому программа ls не запускалась.</p>

<p>Во втором случае программа gcc завершилась неуспешно, поэтому программа ls запустилась.</p>

<p>Чтобы выполнять программы из списка, пока они выполняются успешно, мы можем написать их на одной строке, разделив оператором <code>&amp;&amp;</code>. (Звучит, как оператор, который часто будет пригождаться.)</p>

<pre><code class="language-no-highlight">$ pwd &amp;&amp; ls
/home/igor/test
main  main.c
$ gcc &amp;&amp; ls
gcc: fatal error: no input files
compilation terminated.</code></pre>

<p>В первом случае программа pwd завершилась успешно, поэтому программа ls запускалась.</p>

<p>Во втором случае программа gcc завершилась неуспешно, поэтому программа ls не запустилась.</p>

<p>Каждый процесс при запуске получает уникальный PID (process identifier). Когда мы запускаем процесс на фоне, в некоторых shell-ах нам выводится его PID (но не в sh). Его же мы можем прочитать из переменной <code>$!</code>. Пока мы мало что умеем делать с процессами. Мы можем завершить процесс с помощью программы <code>kill</code>.</p>

<pre><code class="language-no-highlight">$ sleep 100 &amp;
$ echo $!
18865
$ kill $!
$ 
[1] + Terminated                 sleep 100</code></pre>

<p>Нетрудно догадаться, что код возврата — это то, что мы возвращаем из функции <code>main</code>.</p>

<pre><code class="language-cpp">int main() {
    return 123;
}</code></pre>

<pre><code class="language-no-highlight">$ ./main
$ echo $?
123</code></pre><h3 id="4.1.6">4.1.6. Задача: Мини grep</h3><p>Напишите простую программу, работающую аналогично программе <code>grep</code>. Выберите и реализуйте 1-3 её флага. Не следует реализовывать весь её функционал, так как он очень большой. Чтобы узнать флаги, которые принимает программа, введите флаг <code>--help</code>.</p>

<pre><code class="language-no-highlight">grep --help</code></pre><h3 id="4.1.7">4.1.7. Скрипты, Shebang</h3><p>В sh есть более сложные синтаксические конструкции. Например, так мы можем написать if-statement.</p>

<pre><code class="language-no-highlight">$ if gcc
&gt; then
&gt; echo 1
&gt; else 
&gt; echo 2
&gt; fi
gcc: fatal error: no input files
compilation terminated.
2</code></pre>

<p>Заметьте, что пока мы не завершили if-statement ключевым словом <code>fi</code>, sh выводит особый prompt, который подсказывает нам, что мы вводим сейчас вводим сложную синтаксическую конструкцию. Так как gcc вернул не ноль, выполнилась ветка else.</p>

<p>Очевидно, что можно сохранить такой скрипт в отдельном файле, и просто подать этот файл на stdin к sh.</p>

<p><code>script</code></p>

<pre><code class="language-bash">if gcc
then
    echo 1
else
    echo 2
fi</code></pre>

<pre><code class="language-no-highlight">$ sh &lt; script
gcc: fatal error: no input files
compilation terminated.
2</code></pre>

<p>Но такой способ требует, чтобы мы сами указали обработчик скрипта. В Unix есть возможность указать обработчик скрипта прямо в файле. В таком случае, мы можем просто запустить скрипт, как исполняемый файл, и загрузчик программ запустит указанный в файле обработчик скрипта и передаст ему путь к скрипту.</p>

<p><code>script</code></p>

<pre><code class="language-bash">#!/bin/sh
if gcc
then
    echo 1
else
    echo 2
fi</code></pre>

<p>На первой строке написан Shebang. Если файл начинается с текстовых символов <code>#!</code> то загрузчик программ (не shell) запустит программу, путь к которой указан следом (в данном случае, <code>/bin/sh</code>), и передаст ей вторым аргументом путь к скрипту.</p>

<pre><code class="language-no-highlight">$ chmod +x script
$ ./script
gcc: fatal error: no input files
compilation terminated.
2</code></pre>

<p>Нам необходимо разрешить запускать скрипт. Сделать это можно с помощью программы <code>chmod</code>.</p>

<p>Давайте напишем свой обработчик скриптов.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p><code>script</code></p>

<pre><code class="language-no-highlight">#!./main</code></pre>

<p> Укажем путь к исполняемому файлу нашего обработчика: <code>./main</code>.</p>

<pre><code class="language-no-highlight">$ ./script	
./main
./script</code></pre>

<p>Видим, что вторым аргументом указан путь к скрипту.  Теперь мы можем в нашем обработчике открыть этот файл и что-то сделать.</p><h3 id="4.1.8">4.1.8. Статистика процессов</h3><p>Мы можем посмотреть список процессов-потомков с помощью программы <code>ps</code>.</p>

<pre><code class="language-no-highlight">$ sleep 5 &amp;
$ ps              
    PID TTY          TIME CMD
  30872 pts/1    00:00:00 bash
  71987 pts/1    00:00:00 sh
  72063 pts/1    00:00:00 sleep
  72070 pts/1    00:00:00 ps</code></pre>

<p>Здесь мы видем <code>bash</code>, который был запущен у меня изначально; <code>sh</code>, который я запустил в нём; <code>ps</code>, который вывел этот текст; и <code>sleep</code>, запущенный ранее на фоне.</p>

<p>Мы можем проверить время работы процесса с помощью программы <code>time</code>.</p>

<p>Напишем вспомогательную программу.</p>

<pre><code class="language-cpp">int main() {
    int i;
    for (i = 0; i &lt; 1000000000; i++);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ time sleep 2
0.00user 0.00system 0:02.00elapsed 0%CPU (0avgtext+0avgdata 2048maxresident)k
0inputs+0outputs (0major+87minor)pagefaults 0swaps
$ time ./main
1.80user 0.00system 0:01.80elapsed 99%CPU (0avgtext+0avgdata 1152maxresident)k
0inputs+0outputs (0major+63minor)pagefaults 0swaps</code></pre>

<p>По какой-то причине, вывод в sh не отформатирован. Обратите внимание, что всё время работы программы sleep приходится на system, в то время как всё время работы программы main приходится на user. Это связано с тем, что программа sleep просит процессор не выполнять её некоторое время, в то время как main всё это время полностью использует процессор.</p>

<p>Мы можем посмотреть информацию обо всех процессах с помощью программы <code>top</code>. Данная программа является интерактивной, то есть, она меняет текст в терминале. Чтобы выйти из программы, нажмите <code>q</code>. Мы можем получить мгновенный статус с помощью флага <code>-n</code> со значением <code>1</code>. Проверим статус процесса sh. Нам понадобится флаг <code>-b</code>, чтобы top не выводил символы форматирования.</p>

<pre><code class="language-no-highlight">$ top -n 1 -b | grep sh
...
  30872 igor      20   0   11556   4776   3788 S   0,0   0,1   0:00.45 bash
...
  71987 igor      20   0    2892   1664   1664 S   0,0   0,0   0:00.00 sh
...</code></pre><h3 id="4.1.9">4.1.9. Задача: A + B на shell</h3><p>На sh-скриптах можно решать задачи. Так мы можем решить задачу <code>A + B</code>.</p>

<pre><code class="language-bash">read a
read b
c=$(($a + $b))
echo $c</code></pre>

<p>Изучите синтаксические конструкции в sh (они простые, хоть и очень странные). В sh есть только один тип данных — строка.</p>

<p>Напишите решение любой более сложной задачи. Например, задачи про брокера Василия из главы "Контроль потока".</p><h3 id="4.1.10">4.1.10. Проект: Judge System</h3><p>Напишите локальную тестирующую систему, работающую по аналогии с <a href="https://codeforces.com/" rel="noopener noreferrer nofollow">https://codeforces.com/</a> и подобными сайтами.</p>

<ul>
	<li>В директории, отведенной под задачу должны быть:
	<ul>
		<li>Директория с тестами</li>
		<li>Директория с ответами на тесты</li>
	</ul>
	</li>
	<li>Пользователь запускает bash-скрипт, передавая ему исходный код своей программы-решения (выбор поддерживаемых языков неважен) и путь к директории задачи. bash-скрипт проходит по всем парам &lt;тест, ответ на тест&gt; и запускает решение (предварительно скомпилированное), подавая ему в stdin тест и сравнивая вывод в stdout с ответом на тест.
	<ul>
		<li>Если программа не скомпилировалась, пользователь должен получить вердикт "Compilation error"</li>
		<li>Если программа использует больше X памяти, она должна прерваться, и пользователь должен получить вердикт "Memory limit exceeded".</li>
		<li>Если программа использует больше Y времени, она должна быть прерванное, и пользователь должен получить вердикт "Time limit exceeded"</li>
		<li>Если программа вернула не <code>0</code>, пользователь должен получить вердикт "Runtime error"</li>
		<li>Если вывод программы не совпал с ответом на тест, пользователь должен получить вердикт "Wrong answer"</li>
		<li>В противном случае, пользовать должен получить вердикт "Accepted"</li>
	</ul>
	</li>
</ul>

<p>По желанию, можете изучить, что такое checkers (чекеры) и добавить их поддержку. Но это почти не усложнит логику.</p><h3 id="4.2">4.2. Системные вызовы</h3><h3 id="4.2.1">4.2.1. Системный вызов fork</h3><p>Возможности наших программ сильно ограничены. Многие вещи, которые наши программы в прошлом делали, например, считывали ввод или создавали файлы, на самом деле они выполняли не самостоятельно. Программы могут лишь делать что-либо в своих сегментах (если у них есть на это права) и выполнять <em>системные вызовы</em>.</p>

<p>Во время существования программы её оперативная память сильно изолирована. Программа не может получить доступ к памяти других программ. Эта изоляция достигается за счет механизма <em>paging</em>-а. Каждый процесс имеет свою <em>page directory</em>, и, когда ОС переключает процесс, она также переключает и page directory. Подробнее об этом мы узнаем позже.</p>

<p>Системные вызовы — это примерно то же самое, что и функции. Их реализует ОС. Именно с помощью них мы и делаем такие действия, как взаимодействие с stream-ами, файлами, процессами. Самостоятельно вызвать системные вызовы из кода на C мы не можем — на нём просто нет соответствующих конструкций. Мы сможем самостоятельно вызывать их из кода на Assembly, но позже. Пока мы будем пользоваться функциями-обёртками.</p>

<p>Здесь указан список системных вызовов в ОС Linux на разных архитектурах. Набор системных вызовов во всех случаях почти одинаковый, меняется лишь порядок. <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>

<p>Обратите внимание, что все ссылки в этой таблице ведут на документацию функций-обёрток в Linux-е. Многие из них вы скорее всего уже видели.</p>

<p>Важно понять, что механизм системных вызовов предоставляет архитектура (причём, все распространённые на данный момент архитектуры), но то, какие будут системные вызовы и как они будут реализованы, определяет ОС. Сравните системные вызовы в Linux с системными вызовами в Windows: <a href="https://j00ru.vexillium.org/syscalls/nt/64/" rel="noopener noreferrer nofollow">https://j00ru.vexillium.org/syscalls/nt/64/</a></p>

<p>Начнём с простого системного вызова (СВ) <code>fork</code>. Данный СВ:</p>

<ul>
	<li>не принимает никаких аргументов,</li>
	<li>создаёт новый процесс, полностью идентичный  родительскому,</li>
	<li>возвращает родителю pid ребёнка, а ребёнку <code>0</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int x = fork();
    printf("%d\n", x);
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">19025
0</code></pre>

<p>Ребёнок наследует stream-ы, и поэтому выводит в тот же терминал, что и родитель. Порядок вывода случайный. Попробуйте позапускать эту программу многократно.</p>

<p>Рассмотрим пример сложнее.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int t = 2, *v = (int*)malloc(sizeof(int));
    *v = 2;
    int x = fork();
    t++;
    (*v)++;
    printf("%d %d %d\n", x, t, *v);
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">20561 3 3
0 3 3</code></pre>

<p>Обратите внимание, что и переменная на стеке, и переменная на куче, в обоих процессах независимы. (Если бы это было не так, процесс, выполнивший вывод вторым, вывел бы <code>4</code>.) Это показывает, что и стек, и куча, копируются в новый процесс. Также это показывает, что кучи не являются общими для всех процессов. (О том, как работают кучи, и что делает <code>malloc</code>, мы узнаем позже. Обратите внимание, что системного вызова <code>malloc</code> или подобного нет.)</p><h3 id="4.2.2">4.2.2. Задача: fork-последовательность</h3><p>Данная программа принимает вторым аргументом целое число и выводит некоторое количество чисел. Выведете количество выведенных чисел, как функцию от значения аргумента.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char **argv) {
    int n = atoi(argv[1]);
    int i;
    while (n &gt; 0) {
        printf("%d\n", n);
        fflush(stdout);
        if (fork() == 0) {
            n -= 1;
        }
        else if(fork() == 0) {
            n -= 2;
        }
        else {
            break;
        }
    }

    return 0;
}</code></pre>

<p>Функция <code>fflush</code> необходима, если вы будете выводить в файл. Функция <code>printf</code> выполняет буферизацию (то есть, копит текст, и только затем выполняет вывод), поэтому необходимо потребовать её выполнить вывод сейчас с помощью функции <code>fflush</code>.</p><h3 id="4.2.3">4.2.3. Системный вызов exec</h3><p>СВ fork создаёт полностью идентичный процесс. Однако гараздо чаще мы хотим запускать новый процесс другой программы. С помощью системного вызова <code>execve</code> мы можем "загрузить" в процесс другую программу. Изучите аргументы этой функции в документации: <a href="https://man7.org/linux/man-pages/man2/execve.2.html" rel="noopener noreferrer nofollow">https://man7.org/linux/man-pages/man2/execve.2.html</a> . Нам необходимо передать путь к исполняемому файлу, переменные запуска и переменные среды. Пока не будем сильно задумываться об этом и рассмотрим такой пример.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char *argv[] = {"/usr/bin/pwd", NULL};
    char *envp[] = {NULL};
    execve("/usr/bin/pwd", argv, envp);
    printf("Check\n");
    return 0;
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">/home/igor/test</code></pre>

<p>В результате выполнения функции <code>execve</code> выполнение нашей программы прервалось, и вместо этого начала выполняться программа <code>pwd</code>. Проверьте, что если в первый аргумент ввести <code>pwd</code>, то функция не найдет программу и вернёт ошибку.</p>

<p>Обратите внимание, что мы передаём функции в качестве первого аргумента путь к ней. Мы здесь можем нарушить правило о том, что первым аргументом должен быть пусть к программе. На pwd это не влияет, но, например, программа <code>rustc</code> выводит такое:</p>

<pre><code class="language-no-highlight">error: unknown proxy name: 'xxx'; valid proxy names are 'rustc', 'rustdoc', 'cargo', 'rust-lldb', 'rust-gdb', 'rust-gdbgui', 'rls', 'cargo-clippy', 'clippy-driver', 'cargo-miri', 'rust-analyzer', 'rustfmt', 'cargo-fmt'</code></pre>

<p>Напишем вспомогательную программу, которая просто будет выводить аргументы и переменные среды.</p>

<p><code>test.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    printf("________________\n");
    for (i = 0; envp[i] != NULL; i++) {
        printf("%s\n", envp[i]);
    }
    return 0;
}</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char *argv[] = {"xxx", "yyy", NULL};
    char *envp[] = {"A=a", "B=b", "C=c", NULL};
    execve("./test", argv, envp);
    printf("Check\n");
    return 0;
}</code></pre>

<p>Вывод:</p>

<pre><code class="language-no-highlight">xxx
yyy
________________
A=a
B=b
C=c</code></pre>

<p>Запущенная программа не получила переменные среды своего родителя. Нам необходимо передавать их самостоятельно. Для удобства существуют дополнительные функции-обёртки для execve. Здесь можно посмотреть их: <a href="https://www.opennet.ru/docs/RUS/linux_parallel/node8.html" rel="noopener noreferrer nofollow">https://www.opennet.ru/docs/RUS/linux_parallel/node8.html .</a> Например, чтобы передать переменные среды, можно воспользоваться <code>execvp</code>.</p>

<p>Наконец, если мы хотим начать новый процесс, но при этом продолжить выполнение старого, нам необходимо скомбинировать execve с fork-ом. Напомню, что ребёнку fork возвращает ноль, а родителю pid ребёнка, который больше нуля.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int pid = fork();
    if (pid == 0) {
        char *argv[] = {"/usr/bin/pwd", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/pwd", argv, envp);
    }
    else {
        printf("Check\n");
    }
    return 0;
}</code></pre>

<p>В таком случае будет присутствовать и вывод программы pwd, и строка <code>Check</code>.</p>

<p>При завершении родительского процесса, дочерний продолжит выполняться. (При этом, в иерархии процессов будут интересные действия, но мы их обсуждать не будем.) Однако, вы можете остановить родительский процесс до завершения дочернего с помощью системного вызова <code>wait4</code>. Это довольно сложный СВ, так как он позволяет также прочитать состояние интересующего нас процесса в специальной структуре. Я же просто здесь покажу, как подождать завершения процесса по его pid.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    int pid = fork();
    if (pid == 0) {
        char *argv[] = {"/usr/bin/sleep", "5", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/sleep", argv, envp);
    }
    else {
        wait4(pid, NULL, 0, NULL);
        printf("Check\n");
    }
    return 0;
}</code></pre>

<p>Строка <code>Check</code> будет выведена после завершения программы <code>sleep</code>.</p><h3 id="4.2.4">4.2.4. Системные вызовы open, read, write</h3><p>Посмотрите на системные вызовы read и write: <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md </a>. В качестве первого аргумента они принимают некий файловый дескриптор <code>fd</code>, который является числом. В Linux работа с stream-ами реализована весьма красиво, любой stream, будь он stdin, файлом, pipe-ом, определяется единственным числом — файловым дескриптором. Посмотрим на номера файловых дескрипторов для stdin, stdout и stderr.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    printf("%d %d %d\n", STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>0 1 2</code></p>

<p>Попробуем вывести текст с помощью функции write в файловый дескриптор <code>1</code>, то есть, stdout.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    write(1, "Abacaba\n", 8);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>Abacaba</code></p>

<p>Мы можем также считать данные с помощью функции read.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char buffer[1024];
    int cnt = read(0, buffer, 1024);
    printf("%.*s", cnt, buffer);
    return 0;
}</code></pre>

<p>Обратите внимание, что функция read не добавляет нулевой символ после считанной строки. Поэтому нам необходимо считать длину считанной строки и попросить функции printf вывести ровно столько символов, а не до первого нуля.</p>

<p>Вспомним, что ранее вы выводили текст в stderr с помощью функции fprintf, в которую мы передавали первым аргументом переменную <code>FILE *stderr</code>. Структура <code>FILE</code> является высокоуровневой абстракцией над файловыми дескрипторами, которая предоставляет дополнительную информацию. <code>FILE</code> можно получить по дескриптору с помощью функции <code>fdopen</code>. Я не буду здесь рассказывать про эти функции, так как после изучения дескрипторов читатель без проблем сможет изучить это самостоятельно. (Думаю, на этом этапе вы уже согласитесь, что C является высокоуровневым языком.)</p>

<p>Как вывести текст в файл с помощью системных вызовов? Очень просто. Нам понадобится (внезапно) системный вызов <code>open</code>. Я особо не буду рассказывать о его аргументов. Отмечу лишь, что нам необходимо наличие флага <code>O_WRONLY</code> или <code>O_RDWR</code> во втором аргументе.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fd = open("file", O_WRONLY, 0);
    printf("%d\n", fd);
    write(fd, "Abacaba\n", 8);
    return 0;
}</code></pre>

<p>Чтобы вызов функции open завершился успешно, файл "file" должен существовать. Вы можете также сами посмотреть в документации, что нужно передать в функцию, чтобы она создала файл сама.</p>

<p>В моём случае вывод этой программы: <code>3</code></p>

<p>Можно перечислить несколько флагов с помощью оператора <code>|</code>. Например, <code>O_WRONLY | O_APPEND</code>. Часто передачу флагов делают так. Чтобы такое работало, необходимо, чтобы у всех флагов множество битов не пересекалось.</p>

<p>Обратите внимание на номер дескриптора: <code>3</code>. Это означает, что, в отличии от, например, pid, номера дескрипторов не являются глобальными.</p><h3 id="4.2.5">4.2.5. Задача: Действия с файлами</h3><p>Изучите, с помощью каких системных вызовов можно манипулировать файлами (open может только создавать файлы).</p>

<p><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>

<p>Реализуйте любую программу, использующую эти системные вызовы.</p><h3 id="4.2.6">4.2.6. Системный вызов pipe</h3><p>С помощью системного вызова <code>pipe</code> мы можем получить сразу два таких дескриптора, что при записи данных в один из них, мы сможем считать эти данные из другого. Эта связка дескрипторов называется pipe (канал). Функция pipe принимает указатель на массив двух чисел и записывает в первый элемент принимающего, а во второй отправителя.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fds[2];
    pipe(fds);
    
    write(fds[1], "Hello\n", 6);

    char buffer[1024];
    read(fds[0], buffer, 1024);
    printf("%s", buffer);
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">3 4
Hello</code></pre>

<p>Использование двух полученных дескрипторов никак не отличается от использования stdin/stdout. Нам просто необходимо подставлять нужный дескриптор. Обратите внимание, что если мы поменяем местами write и read, то на вызове write наша программа зависнет в ожидании ввода, который никогда не получит.</p>

<p>Напомню, что все стандартные функции вывода выполняют вывод в stdout, то есть конкретный файловый дескриптор. Пусть мы хотим, чтобы эти функции выполняли вывод в наш pipe, а не в терминал. (Который, кстати, скорее всего тоже связан с нашей программой с помощью своего pipe-а.) С помощью системного вызова <code>dup2</code> мы можем закрыть stdout stream (не путайте с stdout-дескриптором, то есть, с числом <code>1</code>) и связать его дескриптор с отправляющей стороной pipe-а. В результате и при выводе в stdout, и при выводе в <code>fds[1]</code> будет выполнен вывод в pipe.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    dup2(fds[1], STDOUT_FILENO);
    write(STDOUT_FILENO, "Hello\n", 6);
    // write(fds[1], "Hello\n", 6);
    // printf("Hello\n");
    // fflush(stdout);

    char buffer[1024];
    int cnt = read(fds[0], buffer, 1024);
    int fd = open("file", O_WRONLY, 0);
    write(fd, buffer, cnt);

    return 0;
}</code></pre>

<p>После вызова функции <code>dup2</code> и при выводе в <code>1</code>, и при выводе в <code>fds[1]</code>, будет выполнен вывод в pipe, который мы позже сможем считать через <code>fds[0]</code>. По желанию можно закрыть дескриптор <code>fds[1]</code> с помощью функции <code>close</code>: <code>close(fds[1])</code>. В таком случае вывод в <code>fds[1]</code> станет вызывать ошибку.</p>

<p>Так как теперь дескриптор <code>1</code> связан с pipe-ом, функция printf будет выводить в него. Только так как она выполняет буферизацию (то есть, копит текст, и только затем выполняет СВ write), вам необходимо будет потребовать её выполнить write сейчас с помощью функции <code>fflush</code>.</p>

<p>Так как stdout больше не связан с терминалом (и снова его связать простым способом невозможно), мы посмотрим на результат, выполним вывод в файл.</p>

<p>До сих пор мы с помощью pipe-а отправляли данные из процесса в него же. Но такое применение довольно бессмысленное. Обычно мы хотим с помощью pipe-ов передавать данные между процессами. Когда мы выполняем fork, оба процесса наследуют общий pipe, у которого теперь два дескриптора отправителя и два принимающих дескриптора. Имейте ввиду, что когда у вас два процесса считывают данные из одного pipe, то сложность системы сильно увеличивается. Это называется состоянием гонки (race condition).</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    if (fork() != 0) {
        char buffer[1024];
        write(fds[1], "Cat\n", 4);
        read(fds[0], buffer, 1024);
    }
    else {
        char buffer[1024];
        read(fds[0], buffer, 1024);
        write(fds[1], "Dog\n", 4);
    }

    return 0;
}</code></pre>

<p>Если бы отправители и/или принимающие были связаны с разными pipe-ами, какой-то из процессов бы завис в ожидании ввода. Однако, этого не происходит.</p>

<p>При некоторых конфигурациях кода мне необходимо "потыркать" stream-ы, чтобы они немедленно передали данные. Иногда они могут это не сделать сразу, из-за чего программа зависнет. Например, у меня это происходит, если заменить <code>fork() != 0</code> на <code>fork() == 0</code>.</p>

<p>В процессах детях также можно переоткрыть pipe-ы в дескрипторы стандартных потоков с помощью dup2. Вам может это понадобиться, если вы хотите запустить в дочернем процессе другую программу с помощью execve и общаться с ней через её стандартные потоки.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    if (fork() != 0) {
        char buffer[1024];
        write(fds[1], "Cat\n", 4);
        write(fds[1], "Dog\n", 4);
        write(fds[1], "Crab\n", 5);
    }
    else {
        dup2(fds[0], STDIN_FILENO);
        char *argv[] = {"/usr/bin/grep", "a", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/grep", argv, envp);
    }

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Cat
Crab</code></pre>

<p>Здесь мы передаём дочернему процессу, выполняющему программу grep, данные в стандартный ввод через наш pipe.</p>

<p>Когда вы будете сами пробовать работать с pipe-ами, у вас часто будут проблемы с недосброшенными буферами, из-за чего ваши программы будут зависать. Я не знаю, как нормально решать эту проблему. Здесь я не использовал СВ <code>close</code>, который закрывает дескриптор, но иногда он может быть необходим.</p><h3 id="4.2.7">4.2.7. Потоки Threads</h3><p>Вы, наверное, слышали про thread (поток), который является альтернативой создания нового процесса. Чем thread отличается от процесса? Тем, насколько дочерний процесс/поток отделён от родительского. Мы видели, что новый процесс имеет свой стек (что логично, ведь блуждание по функциям меняет стек) и свою кучу. Новый поток же своей кучи не имеет. После создания нового потока, основную программу мы будем называть основным потоком.</p>

<p>Посмотрите на список СВ: <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md </a>— в нём нет СВ, имеющих какое-то отношение к потоку. Функции создания потоков в libc используют СВ <code>clone</code>, который выполняет то же самое, что и fork, но имеет возможность настройки нового процесса.</p>

<p>Я не буду объяснять большинство функций здесь. Информация о потоках здесь лишь для ознакомления.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void *thread_main() {
    printf("Thread begin\n");
    sleep(2);
    printf("Thread end\n");
    return NULL;
}

int main() {
    pthread_t thr;
    pthread_create(&amp;thr, NULL, thread_main, NULL);
    sleep(1);
    printf("Main end\n");

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Thread begin
Main end</code></pre>

<p>Мы создаём поток с помощью функции <code>pthread_create</code>. В первый аргумент функция записывает дескриптор потока, по которому мы будем этот поток упоминать. Третий аргумент — это функция, которая будет вызвана при старте потока (это сделано для удобства, так как обычно в потоках мы не запускаем другие программы с помощью execve).</p>

<p>Обратите внимание, что завершение основного потока прервало дочерний поток, и он не вывел строку <code>Thread end</code>. (Дочерние процессы продолжают выполнение и вывод.)</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void *thread_main() {
    printf("Thread begin\n");
    sleep(2);
    printf("Thread end\n");
    return NULL;
}

int main() {
    pthread_t thr;
    pthread_create(&amp;thr, NULL, thread_main, NULL);
    sleep(1);
    pthread_join(thr, NULL);
    printf("Main end\n");

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Thread begin
Thread end
Main end</code></pre>

<p>Функция <code>pthread_join</code> останавливает текущий поток до завершения потока, дескриптор которого мы передали в первый аргумент. Это аналог функции wait4 для процессов.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

int *x;

void *thread_main() {
    (*x)++;
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 2;
    pthread_t thr;
    pthread_create(&amp;thr, NULL, thread_main, NULL);
    pthread_join(thr, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">3</code></pre>

<p>В данном примере мы видим, что куча у обоих потоков общая.</p><h3 id="4.2.8">4.2.8. Задача: Делегация обязанностей</h3><p>Напишите любую программу, в которой несколько потоков объединены в цикл из pipe-ов и по кругу передают друг-другу сообщение.</p><h3 id="4.2.9">4.2.9. Семафоры</h3><p>Посмотрим на такую программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

int *x;

void *thread_main() {
    if (*x &gt; 0) {
        sleep(1);
        (*x)--;
    }
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 1;
    pthread_t thr1, thr2;
    pthread_create(&amp;thr1, NULL, thread_main, NULL);
    pthread_create(&amp;thr2, NULL, thread_main, NULL);
    pthread_join(thr1, NULL);
    pthread_join(thr2, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<p>Программа немного искусственная, но она покажет нам проблему. Мы создаём два потока. Каждый из них уменьшает счётчик на единицу, если он больше нуля. Однако вывод прогаммы:</p>

<pre><code class="language-no-highlight">-1</code></pre>

<p>Чтобы лучше понять, что произошло, я покажу порядок, в котором исполнялись statement-ы потоков.</p>

<pre><code>Thread 1: if (*x &gt; 0)
Thread 1: sleep(1);
Thread 2: if (*x &gt; 0)
Thread 2: sleep(1);
Thread x: (*x)--;
Thread x: return NULL;
Thread y: (*x)--;
Thread y: return NULL;</code></pre>

<p>Здесь из-за блокировки функции sleep, после которой процессор переходит к другому потоку, сначала выполнились две проверки, а только потом два уменьшения. Это называется состоянием гонки (race condition), и исправить проблему можно с помощью использования семафора (semaphore).</p>

<p>Мы воспользуемся posix semaphore-ами, функции которых имеют вид <code>sem_xxx</code>. Существует много других реализаций, но я не вижу в них смысла. Как и в случае с thread-ами, эта реализация семафоров основана на не очень дружелюбных системных вызовах <code>semxxx</code> (можете найти их в таблице СВ). Я так же покажу лишь пример использования этого.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

int *x;
sem_t sem;

void *thread_main() {
    sem_wait(&amp;sem);
    if (*x &gt; 0) {
        sleep(1);
        (*x)--;
    }
    sem_post(&amp;sem);
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 1;
    sem_init(&amp;sem, 0, 1);
    pthread_t thr1, thr2;
    pthread_create(&amp;thr1, NULL, thread_main, NULL);
    pthread_create(&amp;thr2, NULL, thread_main, NULL);
    pthread_join(thr1, NULL);
    pthread_join(thr2, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<p>Функция <code>sem_init</code> записывает дескриптор семафора в первый аргумент, а третий аргумент — это начальное значение семафора. Пусть сначала оно будет равно единице.</p>

<p>Функция <code>sem_wait</code> уменьшает значение семафора на один, но если оно сейчас равно нулю, блокирует поток до момента, когда оно станет больше нуля.</p>

<p>Функция <code>sem_post</code> увеличивает значение семафора на один.</p>

<p>Нам необходимо обрамить блок, использующий общую переменную в sem_wait и sem_post. Теперь порядок выполнения statement-ов такой:</p>

<pre><code class="language-no-highlight">Thread 1: sem_wait(&amp;sem);
Thread 1: if (*x &gt; 0)
Thread 1: sleep(1);
Thread 2: sem_wait(&amp;sem);
Thread 1: (*x)--;
Thread 1: sem_post(&amp;sem);
Thread 1: return NULL;
Thread 2: if (*x &gt; 0)
Thread 2: sem_post(&amp;sem);
Thread 2: return NULL;</code></pre>

<p>Если мы заменим третий аргумент функции sem_init на <code>2</code>, то это можно понимать, как редактирование переменной одновременно не более чем двумя потоками.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

int *x;
sem_t sem;

void *thread_main() {
    sem_wait(&amp;sem);
    if (*x &gt; 0) {
        sleep(1);
        (*x)--;
    }
    sem_post(&amp;sem);
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 1;
    sem_init(&amp;sem, 0, 2);
    pthread_t thr1, thr2, thr3;
    pthread_create(&amp;thr1, NULL, thread_main, NULL);
    pthread_create(&amp;thr2, NULL, thread_main, NULL);
    pthread_create(&amp;thr3, NULL, thread_main, NULL);
    pthread_join(thr1, NULL);
    pthread_join(thr2, NULL);
    pthread_join(thr3, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">-1</code></pre><h3 id="4.2.10">4.2.10. Сигналы и обработчики сигналов</h3><p>Рассмотрим программу.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int *a = 0;
    printf("%d\n", *a);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Segmentation fault (core dumped)</code></pre>

<p>Когда наша программа нарушает правила доступа, ей поступает сигнал <code>SIGSEGV</code>. По умолчанию при получении этого сигнала программа завершается. Мы можем сами указать, что следует сделать при получении этого сигнала. Функция <code>signal</code> принимает номер сигнала и функцию, которая будет вызвана при получении этого сигнала. Попробуем перехватит SIGSEGV.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void handler(int s) {
    printf("%d\n", s);
}

int main() {
    signal(SIGSEGV, handler);
    int *a = 0;
    printf("%d\n", *a);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">11
11
11
...</code></pre>

<p>Число <code>11</code> — это номер SIGSEGV-а. Мы не завершаем программу в нашем обработчике. После возвращения из функции handler процессор снова выполняет инструкцию, которая привела к SIGSEGV. На уровне ОС есть способы "передумать" и не выполнять инструкцию, которая приводит к ошибке. Однако у нас, как у прикладной программы, таких способов нет. Поэтому обработчик SIGSEGV-а должен завершать программу.</p>

<p>А вот и квест: программа в таком состоянии не будет слушать сигналов. Как её завершить?</p>

<p>Попробуем поиграться с разными сигналами.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void handler(int s) {
    printf("%d\n", s);
}

int main() {
    signal(SIGSEGV, handler);
    signal(SIGINT,  handler);
    signal(SIGQUIT, handler);
    signal(SIGSTOP, handler);
    signal(SIGCONT, handler);
    signal(SIGTERM, handler);
    signal(SIGKILL, handler);
    signal(SIGPIPE, handler);
    signal(SIGCHLD, handler);
    
    while(1);

    return 0;
}</code></pre>

<p>Пойдем по порядку.</p>

<p>Сигнал SIGINT вызывается при нажатии комбинации <code>Ctrl + C</code> в терминале и по умолчанию прерывает процесс. Нажмите эту комбинацию, и увидете число <code>2</code>.</p>

<p>Сигнал SIGQUIT вызывается при нажатии комбинации <code>Ctrl + \</code> в терминале и по умолчанию прерывает процесс. Нажмите эту комбинацию, и увидете число <code>3</code>.</p>

<p>Сигнал SIGSTOP вызывается при нажатии комбинации <code>Ctrl + Z</code> в терминале, то есть, при переводе процесса на фон. Нажмите эту комбинацию, однако число <code>19</code>(номер этого сигнала) вы не увидете. Дело в том, что этот сигнал особенный — его нельзя перехватить.</p>

<p>Сигнал SIGCONT вызывается при возвращении фонового процесса командой <code>fg</code>. Введите эту команду, и увидете число <code>18</code>.</p>

<p>Сигнал SIGTERM вызывается при вызове программы kill с pid нашей программы. Выполните это и увидете число <code>15</code>.</p>

<p>Сигнал SIGKILL вызывается при вызове программы kill с дополнительным аргументом <code>-9</code>. При выполнении этого программа завершится и не выведет число, так как этот сигнал нельзя перехватить.</p>

<p>Для генерации следующих сигналов потребуется внести изменения в программу.</p>

<p>Сигнал SIGPIPE вызывается при записи в закрытый stream.</p>

<pre><code class="language-cpp">...
    int fds[2];
    pipe(fds);
    close(fds[0]);
    write(fds[1], "Hello\n", 6);
...</code></pre>

<p> Сигнал SIGCHLD вызывается при завершении дочернего процесса.</p>

<pre><code class="language-cpp">...
    if (fork() == 0) {
        return 0;
    }
...</code></pre>

<p>Здесь возникнет интересная ситуация. Посмотрите на таблицу процессов любым способом (например, через <code>ps</code> или <code>top</code>). Вы увидете, что дочерний процесс ещё есть, и, более того, он не будет пропадать при сигнале SIGKILL. Дочерний процесс находиться в состоянии зомби. В этом состоянии процесс уже завершен, но ОС хранит некоторую метаинформацию, которая может быть полезна родительскому процессу. ОС уничтожит эти данные после того, как родительский процесс вызовет СВ wait. Обработчик по умолчанию делает этот вызов, но наш — нет.</p>

<pre><code class="language-cpp">...
void handler(int s) {
    printf("%d\n", s);
    wait(NULL);
}
...</code></pre><h3 id="4.2.11">4.2.11. Проект: Shell</h3><p>Напишите программу, аналогичную <code>sh</code>, но без скриптов (так как их написание довольно сложно). Список, на который можно опираться:</p>

<ul>
	<li>Принимать команды, которые состоят из нескольких слов и отделены друг от друга переводами строк.</li>
	<li>Первое слово в команде определяет путь к исполняемому файлу. Остальные слова — аргументы.</li>
	<li>Может быть команда <code>cd</code>, которая меняет текущую директорию. Для её реализации необходимо воспользоваться системным вызовом <code>chdir</code>.</li>
	<li>В команде могут быть операторы <code>&lt;</code>, <code>&gt;</code> после которых идут пути к файлам. Для реализации этих операторов необходимы pipe-ы.</li>
	<li>Команды могут быть разделены символов <code>|</code>. Тогда нужно запускать программы сразу во всех таких командах и связывать их pipe-ами.</li>
	<li>В команде может быть оператор <code>&amp;</code>. Также могут быть команды <code>fd</code> и <code>bg</code>. Это также реализуется манипуляциями с pipe-ами.</li>
	<li>При получении сигналов, которые могут быть предназначены текущему дочернему процессу, передавать эти сигналы ему. Для реализации этого необходимо воспользоваться системным вызовом <code>kill</code>.</li>
</ul><h3 id="4.3">4.3. Файловая система</h3><h3 id="4.3.1">4.3.1. Монтирование</h3><p><strong>Внимание! В данной главе мы будем работать с потенциально разрушительными командами. Внимательно читайте команды перед тем, как выполнять их.</strong></p>

<p>Создадим для удобства папку <code>mnt</code> (это не более, чем обычная папка).</p>

<pre><code class="language-no-highlight">mkdir mnt</code></pre>

<p>Посмотрите содержимое директории <code>/dev</code>. Среди файлов вы увидете файлы с названиями <code>sda</code>, <code>sda1</code>, <code>sda2</code>, и т. д. <code>sda</code> — это ваш загрузочный диск, на котором располагается ОС. Диск разбит на несколько partitions (разделов), которые являются обычными, но независимыми друг от друга, директориями. Каждый из файлов <code>sdaX</code> — это соответствующий partition.</p>

<p>В Unix есть возможность "подвесить" partition к любой пустой директории. В результате этого действия вы сможете видеть директорию partition-а при в входе в эту пустую директорию. Это дествие называется mount (монтирование) и выполняется программой <code>mount</code>.</p>

<p>Монтрирование производится централизованно, и список всех можно увидеть, выполнив <code>mount -l</code>.</p>

<pre><code class="language-no-highlight">...
/dev/sda1 on /boot type ext4 (rw,relatime)
...</code></pre>

<p>Посмотрите на мой вывод. Здесь указано, что первый partition моего системного диска уже подвешен к директории /boot. Этот partition отвечает за первичную загрузку нашей ОС.</p>

<p>Давайте примонтируем этот partition к нашей директории <code>mnt</code> с помощью команды <code>sudo mount /dev/sda1 mnt</code>.</p>

<p>Теперь в выводе программы <code>mount -l</code> я получаю такую строку в конце:</p>

<pre><code class="language-no-highlight">...
/dev/sda1 on /home/igor/test/mnt type ext4 (rw,relatime)
</code></pre>

<p>Мы можем зайти в директорию и увидеть её содержимое.</p>

<pre><code class="language-no-highlight">$ ls mnt
config-6.5.0-44-generic      initrd.img-6.8.0-40-generic  System.map-6.5.0-44-generic
config-6.8.0-40-generic      initrd.img.old               System.map-6.8.0-40-generic
efi                          lost+found                   vmlinuz
grub                         memtest86+.bin               vmlinuz-6.5.0-44-generic
initrd.img                   memtest86+.elf               vmlinuz-6.8.0-40-generic
initrd.img-6.5.0-44-generic  memtest86+_multiboot.bin     vmlinuz.old</code></pre>

<p>Директорию можно редактировать, что является отличным способом сломать свою ОС.</p>

<p>Чтобы размонтировать директорию, необходимо воспользоваться программой <code>umount</code>: <code>sudo umount mnt</code></p>

<p>Давайте теперь примонтируем <code>/dev/sda3</code>. В моём случае в этом partition-е хранится основная файловая система вместе с директорией <code>/home</code>. В вашем случае, это может быть другой partition, или даже директория /home может находится в отдельном от основной файловой системы partition-е. Найдите partition с /home самостоятельно и работайте с ним.</p>

<p>При такой файловой системе вы можете вновь прийти к директории mnt, однако на этот раз она будет пуста.</p>

<pre><code class="language-no-highlight">$ ls mnt/home/igor/test/mnt</code></pre><h3 id="4.3.2">4.3.2. Loop Device</h3><p>В Linux есть возможность создать файловую систему прямо на обычном файле, а затем этот файл примонтировать и пользоваться им. Для этого используются loop devices.</p>

<p>Посмотрите содержимое директории <code>/dev</code>: во многих дистрибутивах у вас там будут использоваться loop devices (на Ubuntu их особенно много).</p>

<p>Создадим файл, состоящий только из нулей.</p>

<pre><code class="language-no-highlight">dd if=/dev/zero of=dsk count=1024</code></pre>

<p>Программа <code>dd</code> берет префикс файла <code>if</code> размера <code>bs * count</code> и пишет его в файл <code>of</code>. Файл <code>/dev/zero</code> это особенный файл, который состоит только из нулей, а его размер бесконечен.</p>

<p>Примонтировать сам файл нельзя, зато можно примонтировать loop device. Введите <code>losetup -l</code>, чтобы увидеть список loop devices, которые сейчас у вас присутствуют. В зависимости от дистрибутива, их может быть разное количество. Все их названия имеют форму <code>/dev/loopX</code>. Введите <code>losetup -f</code>, чтобы определить свободное название.</p>

<p>Я предположу, что название <code>/dev/loop100</code> у вас свободно. Создадим loop device:</p>

<pre><code class="language-no-highlight">sudo losetup /dev/loop100 dsk</code></pre>

<p>Введите теперь <code>losetup -l</code>: вы увидете ваш loop device в списке.</p>

<pre><code class="language-no-highlight">/dev/loop100         0      0         0  0 /home/igor/test/dsk                                       0     512</code></pre>

<p>Попробуем его примонтировать.</p>

<pre><code class="language-no-highlight">$ sudo mount /dev/loop100 mnt
mount: /home/igor/test/mnt: wrong fs type, bad option, bad superblock on /dev/loop100, missing codepage or helper program, or other error.</code></pre>

<p>Монтировать можно только корректные файловые системы, а у нас просто последовательность нулей. Создадим файловую систему <code>ext4</code> (об этом чуть позже).</p>

<pre><code class="language-no-highlight">$ mkfs.ext4 dsk
mke2fs 1.46.5 (30-Dec-2021)

Filesystem too small for a journal
Discarding device blocks: done                            
Creating filesystem with 128 4k blocks and 64 inodes

Allocating group tables: done                            
Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done

$ sudo mkfs.ext4 /dev/loop100
mke2fs 1.46.5 (30-Dec-2021)
/dev/loop100 contains a ext4 file system
	created on Wed Sep 11 13:38:27 2024
Proceed anyway? (y,N)  
</code></pre>

<p>Обратите внимание: вы можете упомянуть как сам файл, так и loop device.</p>

<p>Теперь мы можем выполнить монтирование.</p>

<pre><code class="language-no-highlight">$ sudo mount /dev/loop100 mnt
$ ls mnt
lost+found
</code></pre>

<p>В этой файловой системе у вас изначально есть директория <code>lost+found</code>.</p>

<p>Чтобы удалить loop device, необходимо выполнить <code>sudo losetup -d /dev/loop100</code> .</p><h3 id="4.3.3">4.3.3. Разделы дисков Disk Partitions</h3><p>Разберемся, как установить на диске несколько partition-ов и примонтировать их.</p>

<p>Есть несколько утилит для редактирования partition-ов диска. Мы воспользуемся утилитой <code>fdisk</code>. Введите <code>fdisk dsk</code>, чтобы начать редактирование.</p>

<p>Ранее я говорил о том, что мы создали диск с единственным partition-ом. Это не совсем так, так как диск с partition-ами должен содержать специальную метаинформацию, которой у нас не было. Когда мы запустим fdisk, он нас предупредит о том, что наш диск является чистой ext4 файловой системой, которую он просто перезапишет.</p>

<p>Интерфейс этой программы не совсем тривиальный. Внимательно читайте, что она выводит.</p>

<p>Для начала, познакомимся с форматами таблиц partition-ов. Выведите help с помощью <code>m</code> и посмотрите на последний блок, в котором написаны форматы <code>GPT</code>, <code>SGI</code>, <code>DOS</code> и <code>Sun</code>. Мы поговорим о первом и третьем.</p>

<pre><code class="language-no-highlight">...
  Create a new label
   g   create a new empty GPT partition table
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty DOS partition table
   s   create a new empty Sun partition table</code></pre>

<p>Когда вы запускаете компьютер, на нём выполняется "некий" код, который делает некоторую подготовку, а затем начинает выполнять код, написанный где-то на диске. Этот "некий" код, который ответственнен за первичную подготовку, бывает двух типов: <code>BIOS</code> и <code>EFI</code>.</p>

<p>BIOS действует очень просто: он загружает первый сектор диска и начинает его выполнять. Поэтому в первом секторе мы обязательно должны написать код, который поймет, где находится нужный нам partition, и загрузит его. (Один сектор — это, кстати, 512 байт. А вы сможете вместить такую логику в этот объем?)</p>

<p>BIOS сейчас является устаревшим, и маловероятно, что на вашем компьютере используется он. Однако, вы можете запустить виртуальную машину с BIOS (почему-то, это фукнция по умолчанию в VirtualBox).</p>

<p>EFI значительно умнее и его "некий" код изучает таблицу partition-ов и загружает нужный самостоятельно.</p>

<p>Обратите внимание, что термин "таблица partition-ов" не имеет отношения к термину "файловая система". Вы можете иметь на диске partition-ы с разными файловыми системами.</p>

<p>Итак, EFI использует формат GPT, а BIOS использует формат DOS (на самом деле, формат <code>MBR</code>, к которому относится DOS).</p>

<p>Посмотрим на используемый сейчас формат с помощью <code>p</code>.</p>

<pre><code class="language-no-highlight">Command (m for help): p
Disk dsk: 512 KiB, 524288 bytes, 1024 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xaf3f4246</code></pre>

<p>По умолчанию fdisk выбрал формат DOS. Давайте проверим, как он отформатирует наш диск. Введите <code>n</code> для создания нового partition-а и, пока что, прокликайте всё без изменения. Теперь введите <code>w</code>, чтобы выполнить форматирование.</p>

<p>Посмотрим на первый сектор, то есть, первые 512 байт получившегося файла <code>dsk</code>.</p>

<p>Посмотрите на таблицу из <a href="http://wiki.osdev.org/Partition_Table" rel="noopener noreferrer nofollow">http://wiki.osdev.org/Partition_Table</a> . Согласно таблице, информация о нашем первом partition-е должна находиться на байте <code>0x01BE</code>.</p>

<table border="1" cellpadding="4" cellspacing="0" style="background: #f9f9f9; border: 1px #aaaaaa solid;">
	<tbody>
		<tr>
			<th>Partition number</th>
			<th>Offset</th>
		</tr>
		<tr>
			<td>Partition 1</td>
			<td>0x01BE (446)</td>
		</tr>
		<tr>
			<td>Partition 2</td>
			<td>0x01CE (462)</td>
		</tr>
		<tr>
			<td>Partition 3</td>
			<td>0x01DE (478)</td>
		</tr>
		<tr>
			<td>Partition 4</td>
			<td>0x01EE (494)</td>
		</tr>
	</tbody>
</table>

<p> Проверим это с помощью <code>hd</code>: <code>hd dsk</code>.</p>

<pre><code class="language-no-highlight">00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001b0  00 00 00 00 00 00 00 00  e2 79 d9 ef 00 00 00 00  |.........y......|
000001c0  02 00 83 01 04 15 01 00  00 00 ff 03 00 00 00 00  |................|
000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|
...</code></pre>

<p>Мы действительно видим ненулевые биты на отрезке <code>0x1be - 0x1cd</code>. (Что написано на отрезке <code>0x1b8 - 0x1ba</code> можете изучить самостоятельно по той же ссылке.) Кроме того, мы здесь видим в конце первого сектора байты <code>0x55</code> и <code>0xaa</code>, которые обязательно должны быть в MBR.</p><h3 id="4.3.4">4.3.4. Задача: формат GPT</h3><p>Когда вы создаёте первый partition в DOS-диске, вы можете разместить его только начиная с 1-го сектора (везде нумерация идёт с нуля), так как первый сектор является хратит код и таблицу разделов MBR. Однако, когда вы создаёте первый partition в GPT-диске, вы можете разместить его только начиная с 34-сектора.</p>

<ul>
	<li>Что находится в первых 34-х секторах?</li>
	<li>Зачем нужет первый сектор?</li>
</ul>

<p> Можете прочитать о GPT на OSDev Wiki.</p><h3 id="4.3.5">4.3.5. Loop Devices и разделы</h3><p>Создадим диск с несколькими partition-ами с помощью fdisk. Прочитайте самостоятельно help в утилите и добейтесь похожей картины:</p>

<pre><code class="language-no-highlight">Command (m for help): p
Disk dsk: 512 KiB, 524288 bytes, 1024 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 4A705392-B1C6-E34B-B7B9-39BFA385DB58

Device Start   End Sectors  Size Type
dsk1      34   200     167 83,5K Linux filesystem
dsk2     201   990     790  395K Linux filesystem</code></pre>

<p>Формат диска не важен, так как мы планируем использовать loop devices, и они поддерживают большинство форматов.</p>

<p>Выполните <code>losetup</code> с флагом <code>-P</code>: <code>sudo losetup -P /dev/loop100 dsk</code> . Вывод <code>losetup -l</code> ничего нового не покажет, но если вы выполните <code>ls /dev</code>, то увидете интересную картину.</p>

<pre><code class="language-no-highlight">...
loop100
loop100p1
loop100p2
...</code></pre>

<p>У нас появилось по одному дополнительному loop device на каждый partition. Мы можем в каждом из них выполнить форматирование. Для интереса выполним форматирование в разные файловые системы.</p>

<pre><code class="language-no-highlight">$ sudo mkfs.fat /dev/loop100p1
$ sudo mkfs.ext4 /dev/loop100p2</code></pre>

<p>Теперь мы можем примонтировать их.</p>

<pre><code class="language-no-highlight">$ mkdir mnt1 mnt2
$ sudo mount /dev/loop100p1 mnt1
$ sudo mount /dev/loop100p2 mnt2
$ ls mnt1
$ ls mnt2
lost+found</code></pre>

<p>Расскажу ещё немного о файловых системах. Есть три основных часто используемых файловых систем:</p>

<ul>
	<li>ext4 — сложная файловая система, часто используемая на Linux</li>
	<li>NTFS — сложная файловая система, используемая на Windows</li>
	<li>fat — простая файловая система, драйвер к которой можно написать самостоятельно</li>
</ul><h3 id="4.3.6">4.3.6. Задача: Манипуляции с диском при установке ОС</h3><p>Выполните установку любого дистрибутива с ручной установкой (я рекомендую Arch) на виртуальную машину в VirtualBox. Нас интересует часть, связанная с разметкой диска. Попробуйте выполнить установку и на машину с BIOS, и на машину с EFI (меняется в настройках машины).</p><h3 id="4.3.7">4.3.7. Системный вызов chroot</h3><p>Предположим, что мы хотим запустить процесс так, чтобы он видел лишь некое поддерево файловой системы. Есть два способа достичь этого: <code>chroot</code> и системный вызов <code>clone</code> с флагом <code>CLONE_NEWNS</code>. Второй способ использует namespaces, которые были введены в Linux не очень давно для контейнеризации (изоляции процессов), и именно его сейчас используют утилиты <code>LXC</code> и <code>Docker</code>. Namespaces способны изолировать не только файловую систему и значительно сложнее chroot-а, поэтому будем здесь работать с ним.</p>

<p>При использовании любого способа, так как программа не будет видеть ничего вне выбранного поддерева, необходимо будет иметь как минимум, необходимые shared objects, а, желательно, почти всю ОС в этом поддереве.</p>

<p>Попробуем запустить pwd в изолированной директории. Создайте директорию <code>dir</code> и скопируйте туда pwd.</p>

<pre><code class="language-no-highlight">$ mkdir dir
$ cp /usr/bin/pwd dir</code></pre>

<p>Попробуем запустить его с помощью программы chroot.</p>

<pre><code class="language-no-highlight">$ sudo chroot dir /pwd
chroot: failed to run command ‘/pwd’: No such file or directory</code></pre>

<p>Первым аргументом мы вводим поддерево, которое будет видеть процесс, а вторым — путь к исполняемому файлу относительно корня этого поддерева.</p>

<p>Ошибка очень неочевидная и она говорит о том, что загрузчик процесса не смог найти необходимые shared objects. (Как это понять, история умалчивает.) Мы можем посмотреть необходимые shared objects с помощью программы <code>ldd</code>, а затем скопировать их в dir.</p>

<pre><code class="language-no-highlight">$ cd dir
$ ldd pwd
	linux-vdso.so.1 (0x00007ffd1aed3000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007d59e6000000)
	/lib64/ld-linux-x86-64.so.2 (0x00007d59e637a000)
$ mkdir -p lib/x86_64-linux-gnu lib64
$ cp /lib/x86_64-linux-gnu/libc.so.6 lib/x86_64-linux-gnu/
$ cp /lib64/ld-linux-x86-64.so.2 lib64
$ cd ..
$ sudo chroot dir /pwd
/</code></pre>

<p><code>linux-vdso.so.1</code> — особый shared object, который импортируется в из ядра в любую программу. Обратите внимание, что pwd вывел свою позицию относительно поддерева.</p>

<p>Для запуска sh скопируем в dsk образ ОС. (Ведь, чтобы запускать другие программы в sh, необходимо будет их всех также скопировать вместе с их зависимостями.) Наверное, легче всего скачивать образы с помощью утилиты Docker. Очистите директорию dsk и выполните <code>docker export $(docker create ubuntu) | tar -C dsk -xvf -</code> , чтобы скачать и образ ОС Ubuntu и разархивировать его в dsk.</p>

<p>Выполните <code>sudo chroot dsk /bin/sh</code> , чтобы запустить sh. Попробуйте походить по папкам, чтобы удостовериться, что вы не имеете доступа к основной файловой системе.</p>

<p>chroot имеет некоторые уязвимости, которые устраняют namespaces. Можете изучить самостоятельно, что нехорошего может сделать программа, запущенная из chroot-а.</p><h3 id="4.3.8">4.3.8. Проект: Containerization</h3><p>Напишите программу для контейнеризации, которая позволяет:</p>

<ul>
	<li>Создавать файлы-диски и монтировать их (создавать контейнеры)</li>
	<li>Автоматически устанавливать на контейнер ОС (можно загружать их с помощью docker-а)</li>
	<li>Монтировать несколько дисков</li>
	<li>Запускать программы в контейнерах в chroot</li>
</ul>

<p>По желанию, можете использовать namespaces, но это намного сложнее.</p><h2 id="5">5. Assembly</h2><h3 id="5.1">5.1. Регистры, базовые инструкции</h3><h3 id="5.1.1">5.1.1. Мотивация языка ассемблера</h3><p>Начнём изучать язык ассемблера (assembly language). Мы уже знаем, что в процессе компиляции код на C переписывается на язык ассемблера, а затем он переписывается ассемблером в объектный файл с машинным кодом.</p>

<p>Для чего может быть нужно знание ассемблера? На самом деле, ответ такой же, как и на вопрос о том, зачем знать C. Мы очень не хотим писать на языке ассемблера, так как это очень сложно (чуть позже увидим почему). Обычно мы прибегаем к его использованию в следующих случаях:</p>

<ul>
	<li>Мы хотим организовать среду, в которой сможет работать код, написанный на языке C. Это касается embedded programming (встраимоевого программирования).</li>
	<li>Мы хотим изучить результат работы компилятора на предмет возможных недостатков. Иногда специфические математические алгоритмы лучше написать на языке ассемблера, так как компилятор может не догадываться, как их писать правильно.</li>
	<li>Мы пишем непосредственно генерацию кода для ассемблера.</li>
</ul>

<p>Первый случай отличается от двух других гараздо сильнее, чем может показаться на первый взгляд. Остальные случаи относятся к написанию кода на прикладном уровне. Возможно, вы уже слышали такую мудрость: Для написания кода на ассемблере достаточно знать <code>random_range(5, 10)</code> инструкций.  Для прикладного уровня это так, и с него мы и начнём изучение. Организация же среды в embedded program требует взаимодействия с состояниями процессора с помощью инструкций, которые мы, по понятной причине, не можем применять на прикладном уровне.</p>

<p>Существует много различных архитектур процессоров. Все они работают по одной модели, но отличаются множеством состояний и набором инструкций. Самые часто используемые на практике процессоры: <code>x86</code>, <code>arm</code>, <code>risс-v</code>. Подобно тому, как мы можем использовать другие операционные системы с помощью виртуальной машины, мы можем выполнить эмуляцию других процессоров (понятно, что не аппаратно, а программно). Однако, мы будем в основном работать с архитектурой <code>x86</code>, так как, скорее всего, эта архитектура и стоит на вашем компьютере.</p><h3 id="5.1.2">5.1.2. Структура кода на языке ассемблера</h3><p>Сама архитектура задаёт только инструкции, которые мы будем видить при дизассемблировании. Однако, даже ассемблеры имеют конструкции для структуризации кода, которые называются директивами. Проблема в том, что хоть все ассемблеры имеют одинаковые инструкции (ведь их задаёт архитектура), директивы в них отличаются.</p>

<p>Мы будем пользоваться ассемблером <code>GNU Assembler</code>, который и используется в процессе компиляции программы на C компилятором gcc. Существует два основных синтаксиса  языков ассемблера: <code>AT&amp;T</code> и <code>Intel</code>. По умолчанию, gcc использует синтаксис <code>AT&amp;T</code>, с которого мы и начнём, но позже посмотрим и на второй. Чтобы gcc использовал синтаксис <code>Intel</code>, следует добавить флаг <code>-masm=intel</code>.</p>

<p>Когда мы пишем на ассемблере, следует соблюдать некоторые протоколы взаимодействия. ОС Linux использует специальные объектные файлы, поэтому, когда мы пишем программу на Linux, следует генерировать именно объектный файл. Другие ОС имеют другие структуры у подобных файлов. Если мы хотим на своей ОС иметь свой формат, аналогичный объектным файлам, нам придётся написать свой ассемблер. Также ассемблеры могут генерировать flat binary файлы, то есть файлы, состоящие непосредственно из секций, без какой-либо метаинформации. Естественно, мы их не сможем запустить на Linux-е, но они могут быть неплохой отправной точкой, когда мы пишем загрузчик программ для своей ОС.</p>

<p>Итак, перейдем к языку ассемблера.</p>

<p><code>main.s</code></p>

<pre><code class="language-no-highlight">    .text
    .globl  main
main:
    mov     $2, %rax # comment
    mov     $3, %rbx
    add     %rax, %rbx
    ret</code></pre>

<p>Первые три строки являются директивами. То есть, они говорят ассемблеру, что делать, но сами в результирующий объектный файл не попадают.</p>

<p><code>.text</code> говорит о том, что все следующие инструкции следует положить в секцию <code>text</code>. Компоновщик gcc требует наличие этой секции. Но позже мы научимся регулировать это.</p>

<p><code>.globl</code> говорит о том, что label (метка) <code>main</code> должна быть видна извне данного файла. В данном случае она нужно, чтобы компоновщик gcc увидел эту метку и записал, что выполнять программу следует с этого адреса.</p>

<p><code>main</code> — это метка, на которую мы можем ссылаться в других местах нашей программы. Каждое использование слова <code>main</code> будет заменено её адресом (каким адресом, мы узнаем позже).</p>

<p>Комментарии в gnu assembler начинаются с символа <code>#</code>.</p>

<p>Далее идут четыре инструкции. В языке ассемблера у нас есть регистры, в которых мы храним результаты провежуточных вычислений. Это ячейки памяти с самым быстрым доступом. Обычно регистров общего назначения около десяти, но помимо них могут быть десятки более специфических регистров. <code>rax</code> и <code>rbx</code> — это регистры общего назначения. Мы изучим полный их список позже. Можно воспринимать их, как очень глобальные переменные.</p>

<p>Что делают инструкции <code>mov</code> и <code>add</code> догадаться просто. Инструкция <code>mov</code> кладёт значение в первом аргументе (source — источник) во второй аргумент (destination — цель, назначение) (что происходит, когда второй аргумент не является регистром, узнаем чуть позже). Инструкция <code>add</code> складывает оба аргумента и кладёт результат во второй аргумент. Инструкция <code>ret</code> более сложная, мы её изучим позже.</p>

<p>Скомпилируем: <code>gcc main.s -o main</code> и запустим <code>./main</code>. Программа ничего не выведет. Написать ввод и вывод в языке ассемблера несколько сложнее, чем в C, и мы научимся этому позже.</p><h3 id="5.1.3">5.1.3. Дебаггер gdb</h3><p>Научимся отлаживать (debug) код на языке ассемблера. Сама отладка, по моему мнению, по большей части бессмысленна, но конкретно сейчас она хорошо покажет, как выполняется программа на уровне регистров и памяти.</p>

<p>Установите <code>GNU Debugger</code> — <code>gdb</code>. Запустите его на нашей программе из прошлого шага: <code>gdb main</code>. Начнётся интерактивная сессия, подобная тем, которые используются в текстовых редакторах.</p>

<p>Я хочу выполнить четыре инструкции в нашей программе и посмотреть на то, что происходит с регистрами.</p>

<ul>
	<li>Чтобы видеть наши инструкции, следует написать <code>layout asm</code>. Это выполнит дизассемблирование, поэтому директивы мы не увидим.</li>
	<li>Чтобы видет регистры, следует написать <code>layout regs</code>.</li>
	<li>На самом деле, до и после выполнения функции main выполняется немало другого кода. Поэтому начинать с самого начала нам пока не следует (хотя позже мы изучим, что это за код, и как он генерируется). Поставьте точку останова (breakpoint) на метке main: <code>b main</code></li>
	<li>Наконец, запустите программу: <code>r</code>. Чтобы перейти к следующей инструкции, напишите <code>ni</code>. Наблюдайте за подсвеченной командой в коде и значениями регистров <code>rax</code> и <code>rbx</code>.</li>
</ul>

<p>Что вы должны видеть в процессе ввода команд <code>ni</code>.</p>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│rax            0x2                 2                                                                   │
│rbx            0x0                 0                                                                   │
│rcx            0x555555557df8      93824992247288                                                      │
│rdx            0x7fffffffdc98      140737488346264                                                     │
│rsi            0x7fffffffdc88      140737488346248                                                     │
│rdi            0x1                 1                                                                   │
│rbp            0x1                 0x1                                                                 │
│rsp            0x7fffffffdb78      0x7fffffffdb78                                                      │
│r8             0x7ffff7e1bf10      140737352154896                                                     │
│r9             0x7ffff7fc9040      140737353912384                                                     │
│r10            0x7ffff7fc3908      140737353890056                                                     │
│r11            0x7ffff7fde660      140737353999968                                                     │
│r12            0x7fffffffdc88      140737488346248                                                     │
│r13            0x555555555129      93824992235817                                                      │
│r14            0x555555557df8      93824992247288                                                      │
┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│B+  0x555555555129 &lt;main&gt;           mov    $0x2,%rax                                                   │
│  &gt; 0x555555555130 &lt;main+7&gt;         mov    $0x3,%rbx                                                   │
│    0x555555555137 &lt;main+14&gt;        add    %rax,%rbx                                                   │
│    0x55555555513a &lt;main+17&gt;        ret                                                                │
│    0x55555555513b                  add    %dh,%bl                                                     │
│    0x55555555513d &lt;_fini+1&gt;        nop    %edx                                                        │
│    0x555555555140 &lt;_fini+4&gt;        sub    $0x8,%rsp                                                   │
│    0x555555555144 &lt;_fini+8&gt;        add    $0x8,%rsp                                                   │
│    0x555555555148 &lt;_fini+12&gt;       ret                                                                │
│    0x555555555149                  add    %al,(%rax)                                                  │
│    0x55555555514b                  add    %al,(%rax)                                                  │
│    0x55555555514d                  add    %al,(%rax)                                                  │
│    0x55555555514f                  add    %al,(%rax)                                                  │
│    0x555555555151                  add    %al,(%rax)                                                  │
│    0x555555555153                  add    %al,(%rax)                                                  │
│    0x555555555155                  add    %al,(%rax)                                                  │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7f9c7 In: main                                         L??   PC: 0x555555555130 
(gdb) layout regs
(gdb) b main
Breakpoint 1 at 0x1129
(gdb) r
Starting program: /home/igor/test/main
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, 0x0000555555555129 in main ()
(gdb) ni
0x0000555555555130 in main ()
(gdb) 
</code></pre>

<p>Чтобы не вводить постоянно эти команды, можно написать скрипт.</p>

<p><code>.gdbinit</code></p>

<pre><code class="language-no-highlight">layout asm
layout regs
b main
r</code></pre>

<p>После того, как вы запустите в следующий раз gdb, среди текста вам будет выведено такое сообщение с вашими путями.</p>

<pre><code class="language-no-highlight">warning: File "/home/igor/test/.gdbinit" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
To enable execution of this file add
	add-auto-load-safe-path /home/igor/test/.gdbinit
line to your configuration file "/home/igor/.config/gdb/gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/home/igor/.config/gdb/gdbinit".</code></pre>

<p>Удовлетворите это условие, и при следующих запусках gdb будет выполнять скрипт.</p><h3 id="5.1.4">5.1.4. Инструкции mov и lea</h3><p>Инструкция <code>mov</code> имеет несколько вариантов. (Мне здесь не особо известна терминология. Возможно, правильно говорить, что есть неколько инструкций с названием <code>mov</code>.) Вариант, который мы использовали, имеет в качестве destination (назначения) регистр. Но назначение может быть также и адрес.</p>

<p>В языке C обычно мы начинаем изучение адресов с адресов локальных переменных. Однако, понятия локальной переменной в языке ассемблера нет — нам нужно организовать стек самостоятельно. Вызывать функции динамического выделения памяти мы тоже пока не можем. Придётся использовать глобальные переменные.</p>

<p>Здесь мы выполним более серьёзный анализ. Начнём с gnu assembly 64-bit.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, (%rax)
    ret</code></pre>

<p>Мы объявляем новую стандартную секцию <code>bss</code>, которая изначально заполнена нулями. С помощью директивы <code>.zero</code> мы объявляем последовательность из восьми байт, на начало которой указывает метка <code>arr</code>.</p>

<p>Посмотрим сначала на инструкцию <code>movq</code>. Мы взяли второй аргумент в скобки. Это означает, что мы хотим записать значение не в сам регистр, а по адресу регистра. Но какая размерность числа, которое мы записываем? (От этого зависит то, сколько старших байт регистра мы занулим.) Это мы явно сообщаем суффиксом <code>q</code> в слове <code>movq</code>.</p>

<p>Посмотрим на строку с инструкцией <code>leaq</code>. Её первый аргумент упоминает метку <code>arr</code>. Может показаться, что здесь упоминается регистр <code>rip</code>, который является адресом текущей инструкции. Но это не так, и это лишь директива ассемблеру, сообщающая о том, что адрес метки <code>arr</code> должен вычисляться относительно регистра <code>rip</code>. (Мы поговорим об этом отдельно. Дело в том, что в 64-bit мы хотим, чтобы все адреса в нашей программе были относительными. Это называется position independent code (PIC).)</p>

<p>Что делает инструкция <code>lea</code>? Она загружает не значение по адресу <code>arr</code> (что сделала бы инструкция <code>mov</code>), а сам адрес <code>arr</code>. (Здесь у знающих ассемблеры может быть вопрос — точно ли <code>mov</code> загружает значение? Да, и я сам не понимаю, почему в gnu assembly это работает так.)</p>

<p>Проверим программу. Запустите дебаггер и выведите память около адреса, равного значению регистра <code>rax</code>, с помощью команды <code>x</code>. (Эта команда имеет много параметров для форматирования вывода. Ищите "gdb cheet sheet".)</p>

<pre><code class="language-no-highlight">(gdb) x $rax
0x555555558011: 0x00000001</code></pre>

<p>Действительно, три нуля и единица.</p>

<p>Замените теперь инструкцию <code>leaq</code> на <code>movq</code>. Убедитесь, что программа получает SIGSEGV и дизассемблируйте её с помощью <code>objdump</code>: <code>objdump -d main</code>.</p>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre>

<p>Посмотрите на <code>opcode</code> этой инструкции: <code>0x8b</code> (число <code>48</code>, очевидно, не может быть opcode-ом, ведь эти две инструкции явно разные). Эта информация нам скоро понадобится.</p>

<p>Чтобы получить значение из ячейки по адресу, следует так же использовать скобки.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, (%rax)
    movq    arr(%rip), %rbx
    movq    (%rax), %rcx
    ret</code></pre>

<p>Так мы запишем значение по адресу <code>arr</code> в регистры <code>rbx</code> и <code>rcx</code>. (Третья и четвёртая инструкция эквивалентны, так как <code>rax</code> хранит адрес <code>arr</code>.)</p>

<p>Так мы можем работать с сдвинутыми адресами (например, обратиться к ненулевому индексу массива).</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   16

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, 8(%rax)
    movq    8+arr(%rip), %rbx
    ret</code></pre>

<p>Здесь мы создали массив для двух 64-bit чисел, и обращаемся ко второму, добавляя <code>8</code> к адресам. (Синтаксис этого, конечно, очень странный. В синтаксисе <code>Intel</code> это выглядит получше.)</p><h3 id="5.1.5">5.1.5. Задача: Об инструкции lea</h3><p>Инструкция lea (load effective address) загружает адрес, который может быть представлен в форме специфического арифметического выражения. Изучите эту форму (ищите по запросу "effective address"), а затем напишите одну инструкцию, которая сложит значения двух регистров и сохранит результат в третий (инструкция add так не может, так как принимает только два аргумента).</p><h3 id="5.1.6">5.1.6. Разрядность</h3><p>Рассмотрим, как писать 32-bit код.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   4

    .text
    .globl  main
main:
    leal    arr, %eax
    movl    $1, (%eax)
    ret</code></pre>

<p>Здесь произошли следующие изменения:</p>

<ul>
	<li>Использованы 32-битные регисты. Их названия начинаются с буквы <code>e</code>, вместо буквы <code>r</code>.</li>
	<li>Использованы команды с размерностью четыре байта, которые определяются суффиксом <code>l</code>, так как восьмибайтных команд нет.</li>
	<li>Отсутствует директива <code>(%rip)</code>, так как теперь мы можем написать position independent executable (PIE) (для этого нужен дополнительный флаг <code>-no-pie</code>).</li>
</ul>

<p>Для компиляции в 32-bit необходимы дополнительные зависимости в системе, которые в некоторых дистрибутивах может быть непросто поставить. Выполнять компиляцию в 32-bit необязательно. Я просто хочу показать, что это такое.</p>

<p>Скомпилируем программу: <code>gcc main.s -o main -m32 -no-pie</code>. Флаг <code>-m32</code> выполняет компиляцию в 32-bit.</p>

<p>Посмотрим теперь на суффиксы размерностей инструкций.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td> </td>
			<td>AT&amp;T</td>
			<td>Intel</td>
		</tr>
		<tr>
			<td>1</td>
			<td>b</td>
			<td>byte</td>
		</tr>
		<tr>
			<td>2</td>
			<td>w</td>
			<td>word</td>
		</tr>
		<tr>
			<td>4</td>
			<td>l</td>
			<td>dword</td>
		</tr>
		<tr>
			<td>8</td>
			<td>q</td>
			<td>qword</td>
		</tr>
	</tbody>
</table>

<p>Теперь посмотрим на регистр <code>rax</code>. Когда мы писали 32-bit код, мы использовали регистр <code>eax</code>. Однако этот же регистр есть и в 64-bit коде и он является младшими четырьмя байтами регистра <code>rax</code>.</p>

<p> Рассмотрим программу:</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    movq    $0x1122334455667788, %rax
    movl    $0xeeff, %eax
    ret</code></pre>

<p>С помощью дебаггера убедитесь, что обе инструкции действительно меняют значение регистра <code>rax</code>. Обратите также внимание на то, что инструкция <code>movl</code> также зануляет старшие четыре байта регистра.</p>

<p>Регистр <code>eax</code> имеет более маленькие составные части. Его младшие два байта покрываются регистром <code>ax</code>, первый байт покрывается регистром <code>al</code>, а второй байт покрывается регистром <code>ah</code>.</p>

<p>Рассмотрим теперь такую программу:</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    movl    $0x12345678, %eax
    movw    $0xabcd, %ax
    movb    $0xee, %al
    movb    $0xff, %ah
    ret</code></pre>

<p>Выполните её в дебаггере и обратите внимание на то, что инструкция <code>movw</code> занулила старшие два байта регистра <code>eax</code>. То же самое происходит и при использовании инструкции <code>movb</code> с регистрами <code>al</code> и <code>ah</code>.</p><h3 id="5.1.7">5.1.7. Как читать машинный код</h3><p>Контент этого шага сложный и необязательный для полного понимания. Здесь я покажу, как читать машинный код.</p>

<p>Информацию обо всех инструкциях мы можем найти в instruction set architecture (ISA), который предоставляется производителем процессора. Научимся их читать. Откройте ISA AMD. (Это один из производителей процессоров архитектуры x86. Возможно, на вашем компьютере процессор AMD.)  <a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf" rel="noopener noreferrer nofollow">https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf</a></p>

<p>Давайте откроем страницу с описанием инструкции <code>mov</code>.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 800px;">
	<tbody>
		<tr>
			<td>Mnemonic</td>
			<td>Opcode</td>
			<td>Description</td>
		</tr>
		<tr>
			<td>MOV reg/mem8, reg8</td>
			<td>88 /r</td>
			<td>Move the contents of an 8-bit register to an 8-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem16, reg16</td>
			<td>89 /r</td>
			<td>Move the contents of a 16-bit register to a 16-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem32, reg32</td>
			<td>89 /r</td>
			<td>Move the contents of a 32-bit register to a 32-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem64, reg64</td>
			<td>89 /r</td>
			<td>Move the contents of a 64-bit register to a 64-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg8, reg/mem8</td>
			<td>8A /r</td>
			<td>Move the contents of an 8-bit register or memory<br>
			operand to an 8-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg16, reg/mem16</td>
			<td>8B /r</td>
			<td>Move the contents of a 16-bit register or memory<br>
			operand to a 16-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg32, reg/mem32</td>
			<td>8B /r</td>
			<td>Move the contents of a 32-bit register or memory<br>
			operand to a 32-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg64, reg/mem64</td>
			<td>8B /r</td>
			<td>Move the contents of a 64-bit register or memory<br>
			operand to a 64-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg16/32/64/mem16,<br>
			segReg</td>
			<td>8C /r</td>
			<td>Move the contents of a segment register to a 16-bit, 32-<br>
			bit, or 64-bit destination register or to a 16-bit memory<br>
			operand.</td>
		</tr>
		<tr>
			<td>MOV segReg, reg/mem16</td>
			<td>8E /r</td>
			<td>Move the contents of a 16-bit register or memory<br>
			operand to a segment register.</td>
		</tr>
		<tr>
			<td>MOV AL, moffset8</td>
			<td>A0</td>
			<td>Move 8-bit data at a specified memory offset to the AL<br>
			register.</td>
		</tr>
		<tr>
			<td>MOV AX, moffset16</td>
			<td>A1</td>
			<td>Move 16-bit data at a specified memory offset to the AX<br>
			register.</td>
		</tr>
		<tr>
			<td>MOV EAX, moffset32</td>
			<td>A1</td>
			<td>Move 32-bit data at a specified memory offset to the<br>
			EAX register.</td>
		</tr>
		<tr>
			<td>MOV RAX, moffset64</td>
			<td>A1</td>
			<td>Move 64-bit data at a specified memory offset to the<br>
			RAX register.</td>
		</tr>
		<tr>
			<td>MOV moffset8, AL</td>
			<td>A2</td>
			<td>Move the contents of the AL register to an 8-bit memory<br>
			offset.</td>
		</tr>
		<tr>
			<td>MOV moffset16, AX</td>
			<td>A3</td>
			<td>Move the contents of the AX register to a 16-bit memory<br>
			offset.</td>
		</tr>
		<tr>
			<td>MOV moffset32, EAX</td>
			<td>A3</td>
			<td>Move the contents of the EAX register to a 32-bit<br>
			memory offset.</td>
		</tr>
		<tr>
			<td>MOV moffset64, RAX</td>
			<td>A3</td>
			<td>Move the contents of the RAX register to a 64-bit<br>
			memory offset.</td>
		</tr>
		<tr>
			<td>MOV reg8, imm8</td>
			<td>B0 +rb ib</td>
			<td>Move an 8-bit immediate value into an 8-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg16, imm16</td>
			<td>B8 +rw iw</td>
			<td>Move a 16-bit immediate value into a 16-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg32, imm32</td>
			<td>B8 +rd id</td>
			<td>Move an 32-bit immediate value into a 32-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg64, imm64</td>
			<td>B8 +rq iq</td>
			<td>Move an 64-bit immediate value into a 64-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg/mem8, imm8</td>
			<td>C6 /0 ib</td>
			<td>Move an 8-bit immediate value to an 8-bit register or<br>
			memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem16, imm16</td>
			<td>C7 /0 iw</td>
			<td>Move a 16-bit immediate value to a 16-bit register or<br>
			memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem32, imm32</td>
			<td>C7 /0 id</td>
			<td>Move a 32-bit immediate value to a 32-bit register or<br>
			memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem64, imm32</td>
			<td>C7 /0 id</td>
			<td>Move a 32-bit signed immediate value to a 64-bit<br>
			register or memory operand.</td>
		</tr>
	</tbody>
</table>

<p>Вспомним пример:</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    movq    arr(%rip), %rax
    movq    $1, (%rax)
    ret</code></pre>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre>

<p>Первая инструкция <code>mov</code> записывает значение, хранящееся по адресу (не сам адрес), в регистр. Найдем opcode <code>0x8b</code> в таблице. В первой колонке мы видим:</p>

<pre><code class="language-no-highlight">MOV regXX, reg/memXX</code></pre>

<p>Здесь мы видим, что первых аргументом должен быть регистр, а вторым регистр или адрес в памяти (который трактуется, как содержимое по этому адресу). Разве не наоборот? Да. Дело в том, что в данном ISA используется синтаксис Intel, в котором первым аргументом стоит destination. Поэтому нам придётся визуально поменять эти аргументы местами. Мы посмотрим синтаксис Intel чуть позже.</p>

<p>Посмотрим чуть внимательнее на инструкцию:</p>

<pre><code class="language-no-highlight">48 8b 05 e1 2e 00 00</code></pre>

<p>Обратите внимание: последние четыре байта — это число <code>0x00002ee1</code>. Оно хранится байтами наоборот (как и всё в архитектуре x86) как есть. Что же говорит о том, что это адрес, а не регистр, и что перемещение идёт в регистр <code>rax</code>? Третий байт, равный <code>0x05</code>. Это <code>ModR/M</code> байт, о наличии которого сообщает приписка <code>/r</code> во втором столбце. Можете найти таблицу кодирования этого байта, она общая для всех инструкций. Я же просто скажу, что число <code>0x05</code> находится на пересечении регистра <code>rax</code> и <code>disp32</code>.</p>

<p>Байт <code>0x48</code> является префиксом инструкции и, полагаю, говорит о том, что число в инструкции имеет размер четыре байта.</p>

<p>Напомню, что метка — это не более, чем число. Поэтому, и число, и метка относятся к <code>immXX</code>.</p><h3 id="5.1.8">5.1.8. Задача: Прочитать код инструкции</h3><p>Выполните анализ второй инструкции.</p>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre><h3 id="5.1.9">5.1.9. Синтаксис языка ассемблера</h3><p>Мы уже увидели некоторую проблему в синтаксисе <code>AT&amp;T</code>, поэтому не будет ошибкой попробовать перейти на синтаксис <code>Intel</code>.</p>

<pre><code class="language-no-highlight">    .intel_syntax   noprefix

    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    lea     rax, arr[rip]
    movq    [rax], 1
    ret</code></pre>

<p>Что изменилось:</p>

<ul>
	<li>Операнды в инструкциях поменялись местами.</li>
	<li>Вместо круглых скобок используются квадратные.</li>
	<li>Перед названиями регистров и константами больше нет знаков <code>%</code> и <code>$</code>.</li>
</ul>

<p>Есть проблема в том, что обычно на gnu assembly не используют синтаксис intel, и в разных ассемблерах директивы разные. Мы будем использовать ассемблер <code>nasm</code>, так как он более известен среди ассемблеров с синтаксисом intel.</p>

<p>Итак, установите <code>nasm</code>. Обычно, его файлы имеют расширение <code>.asm</code>.</p>

<pre><code class="language-no-highlight">section .bss
arr:
    resb    8

section .text
global _start
_start:
    lea     rax, [rel arr] ; comment
    mov     qword [rax], 1
    ret</code></pre>

<p>Это та же самая программа на nasm-е. Обратите внимание: директивы теперь выглядят совсем по другому.</p>

<ul>
	<li>При объявлении секции присутствует ключевое слово <code>section</code></li>
	<li>Вместо <code>.globl</code> теперь <code>global</code></li>
	<li>Другой синтаксис обозначения размерности инструкции: вместо <code>movq</code> теперь <code>mov qword</code></li>
	<li>Другой синтаксис обозначения того, что адрес относительно <code>rip</code>: вместо <code>arr[rip]</code> теперь <code>[rel arr]</code></li>
	<li>Комментарии начинаются с символа <code>;</code>.</li>
</ul>

<p>В общем, хоть синтаксис и одинаковый, код для этих ассемблеров плохо совместим.</p>

<p>Обратите внимание на метку: теперь используется метка <code>_start</code>. Это стартовая метка для стандартного linker script-а ассемблера <code>nasm</code>. В отличии от gnu assembly исполнение здесь начинается непосредственно с нашего кода.</p>

<p>Выполним компиляцию и компоновку.</p>

<pre><code class="language-no-highlight">$ nasm -felf64 main.asm -o main.o
$ ld main.o -o main</code></pre>

<p>При запуске программы вы получите SIGSEGV. Это происходит из-за инструкции <code>ret</code>, так как она переходит к внешней функции с помощью стека, а на данный момент у нас стек пустой.</p>

<p>Проверим entry point.</p>

<pre><code class="language-no-highlight">$ objdump -d main

main:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
  401000:	48 8d 05 f9 0f 00 00 	lea    0xff9(%rip),%rax        # 402000 &lt;__bss_start&gt;
  401007:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
  40100e:	c3                   	ret    
$ readelf -h main
...
  Entry point address:               0x401000
...</code></pre>

<p>Entry point (то есть, первая исполняемая инструкция) действительно метка <code>_start</code>.</p><h3 id="5.1.10">5.1.10. Арифмитические инструкции и флаги, как читать ISA</h3><p>Далее для удобства мы будем использовать ассемблер <code>nasm</code>.</p>

<p>Изучим арифметические инструкции. Инструкции <code>add</code> и <code>sub</code> для сложения и вычитания являются очевидными. Посмотрим на инструкцию <code>mul</code> для умножения.</p>

<p>В ISA AMD написано:</p>

<blockquote>
<p>Multiplies the unsigned byte, word, doubleword, or quadword value in the specified register or<br>
memory location by the value in AL, AX, EAX, or RAX and stores the result in AX, DX:AX,<br>
EDX:EAX, or RDX:RAX (depending on the operand size). It puts the high-order bits of the product in<br>
AH, DX, EDX, or RDX.</p>

<p>If the upper half of the product is non-zero, the instruction sets the carry flag (CF) and overflow flag<br>
(OF) both to 1. Otherwise, it clears CF and OF to 0. The other arithmetic flags (SF, ZF, AF, PF) are<br>
undefined.</p>
</blockquote>

<p>Данная инструкция принимает только один операнд (причём, не imm), а в качестве второго использует регистр <code>*A*</code>. При размерности операндов равной <code>X</code> младшие <code>X</code> байт результата помещается в регистр <code>*A*</code>, а старшие в регистр <code>*D*</code>. Во втором абзаце упоминаются некие флаги.</p>

<p>В x86 есть специальный регистр <code>FLAGS/EFLAGS/RFLAGS</code>, к которому у нас нет свободного доступа, но на который влияют многие инструкции. В данном случае при переполнения младших <code>X</code> байт результата нас дополнительно уведомляют об этом, включая биты, соответствующие флагам <code>carry</code> (перевод в следующий разряд) и <code>overflow</code> (переполнение). (Эти флаги не эквивалентны при знаковых вычислениях.) Здесь есть странность терминологии: часто под "включает флаг, если X" подразумевается также "выключает флаг, если не X".</p>

<pre><code class="language-no-highlight">section .text
global _start
_start:
    mov     eax, 0xffffffff
    mov     ebx, 0x2
    mul     ebx
    ret</code></pre>

<p>Посмотрим на это в gdb (не забудьте поставить точку останова на метку <code>_start</code>). Мы можем вывести флаги с помощью команды <code>p $eflags</code>.</p>

<pre><code class="language-no-highlight">(gdb) p $eflags
$4 = [ CF IF OF ]</code></pre>

<p> Помимо carry flag и overflow flag у нас также есть следующие арифметические флаги (это их примерные словесные описания, так как инструкции, работающие с ними, разные):</p>

<ul>
	<li>Parity flag — чётность количества единичных битов в результате (когда это может быть полезно?).</li>
	<li>Zero flag — равен ли результат нулю.</li>
	<li>Sign flag — отрицателен ли результат.</li>
	<li>Direction flag — в какое направление будет идти итерирование по массиву при выполнении инструкций циклов. Мы сами управляем этим флагом.</li>
</ul>

<p>На остальные флаги мы влиять не можем или они для нас бесполезны. IF — это interrupt flag, который выключается инструкцией <code>cli</code>. Что будет, если мы её выполним?</p>

<pre><code class="language-no-highlight">section .text
global _start
_start:
    cli
    ret</code></pre>

<p>При выполнении этой инструкции мы получим SIGSEGV. Некоторые инструкции, например, cli, требуют большие права для выполнения. Условно, на текущий уровень прав ссылаются сегментные регистры, и мы на них влиять не можем (иначе в чём смысл такой защиты?).</p><h3 id="5.1.11">5.1.11. Control Flow</h3><p>Control flow выполняется с помощью условных прыжков, которые совершают переход к адресу при условии, что какой-то флаг включен. Например, инструкция <code>jz</code> выполняет прыжок, если включен ZF.</p>

<p>Мы можем написать <code>if (rax == rbx)</code> такой последовательностью инструкций:</p>

<pre><code class="language-no-highlight">    sub     rax, rbx
    jz      if_true</code></pre>

<p>Если при выполнении инструкции вычитания получается ноль, то включается ZF. Если он включен, выполняется переход не к инструкции, следующей за инструкцией <code>jz</code>, а к метке <code>if_true</code>.</p>

<p>Рассмотрим более полный пример. Так мы пишем if statement на языке ассемблера.</p>

<pre><code class="language-no-highlight">section .text
global _start
_start:
    mov     rax, 1
    mov     rbx, 2

    sub     rax, rbx
    jz      if_true
if_else:
    mov     rcx, 0
    jmp     if_end
if_true:
    mov     rcx, 1
if_end:

    ret</code></pre>

<p>Проследите за логикой прыжков когда регистры rax и rbx равны, и когда не равны.</p>

<p>Не много ли меток (метка <code>if_else</code> присутствует для наглядности и не используется)? Давайте посмотрим, как скомпилирует if statement компилятор gcc.</p>

<pre><code class="language-cpp">int main() {
    int a = 1, b = 2, c;
    if (a == b) {
        c = 1;
    }
    else {
        c = 0;
    }
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ gcc main.c -S -masm=intel -o main.s</code></pre>

<pre><code class="language-no-highlight">...
	cmp	eax, DWORD PTR -8[rbp]
	jne	.L2
	mov	DWORD PTR -4[rbp], 1
	jmp	.L3
.L2:
	mov	DWORD PTR -4[rbp], 0
.L3:
...</code></pre>

<p>Здесь есть следующие отличия:</p>

<ul>
	<li>Вместо регистров используется стек. Конечно, я не могу заставить компилятор использовать регистры, ведь это смысл компилятора — использовать регистры эффективно. Поэтому он обращается к стеку, адрес которого содержится в регистре <code>rbp</code>. Чуть позже мы это изучим.</li>
	<li>Вместо инструкции <code>sub</code> используется инструкция <code>cmp</code>. Она выставляет флаги так же, как и инструкция <code>sub</code>, но сам destination регист не меняет.</li>
	<li>Вместо инструкции <code>jz</code> используется инструкция <code>jne</code> — jump not equal, которая выполняет прыжок, если ZF выключен.</li>
</ul>

<p>В остальном, сама структура меток и прыжков полностью идентична нашей.</p>

<p>Изучите самостоятельно все conditional jump инструкции, например, <code>jl</code> (jump less), <code>jg</code> (jump greater) и т.д.</p>

<p>Помимо обычных меток есть и локальные метки, названия которых начинаются с символа <code>.</code>.</p>

<pre><code class="language-no-highlight">section .text
global _start

_start:
    jmp     .aba
.1:
    jmp     foo
.aba:
    jmp     .1

foo:
    jmp     .1
.1:
    jmp     $</code></pre>

<p>В данном примере nasm транслирует название локальной метки <code>.1</code> под меткой <code>_start</code> в <code>_start.1</code>, название локальной метки <code>.aba</code> под меткой <code>_start</code> в <code>_start.aba</code>, а название локальной метки <code>.1</code> под меткой <code>.foo</code> в <code>foo.1</code>. Попробуйте самостоятельно проследить за порядком выполнения инструкций в этой программе.</p>

<p>Оператор <code>$</code> транслируется в адрес начала текущей инструкции, поэтому в результате выполнения инструкции <code>jmp $</code> мы перейдем в неё же, создав бесконечный цикл.</p>

<p>Существует также оператор <code>$$</code>, который транслируется в адрес начала текущей секции. Однако область его применения достаточно специфична, поэтому мы на него здесь не посмотрим.</p><h3 id="5.1.12">5.1.12. Задача: Написать циклы</h3><p>Напишите циклы while, do while и for.</p><h3 id="5.1.13">5.1.13. Инструкции для строк и массивов</h3><p>В x86_64 есть следующие регистры общего назначения: <code>rax</code>, <code>rbx</code>, <code>rcx</code>, <code>rdx</code>, <code>rdi</code>, <code>rsi</code>, <code>rbp</code>, <code>rsp</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>. Изучить их составные регистры можно по этой картинке: <a href="https://upload.wikimedia.org/wikipedia/commons/1/15/Table_of_x86_Registers_svg.svg" rel="noopener noreferrer nofollow">https://upload.wikimedia.org/wikipedia/commons/1/15/Table_of_x86_Registers_svg.svg</a></p>

<p>У этих регистров есть роли. Некоторые из этих ролей задаются самой архитектурой (например, инструкция mul выполняла перемножение строго с регистром rax), некоторые задаются "стилем" написания кода, который называется Application Binary Interface (ABI).</p>

<p>Посмотрим на роли со стороны архитектуры. Для работы с массивами мы используем инструкции <code>stos</code> и <code>lods</code>. Первая инструкция копирует данные в маcсив, в вторая — их массива. Прочитаем их описание в ISA.</p>

<blockquote>
<p>STOS<br>
STOSB<br>
STOSW<br>
STOSD<br>
STOSQ</p>

<p>Copies a byte, word, doubleword, or quadword from the AL, AX, EAX, or RAX registers to the<br>
memory location pointed to by ES:rDI and increments or decrements the rDI register according to the<br>
state of the DF flag in the rFLAGS register.<br>
If the DF flag is 0, the instruction increments the pointer; otherwise, it decrements the pointer. It<br>
increments or decrements the pointer by 1, 2, 4, or 8, depending on the size of the value being copied.</p>
</blockquote>

<p>Рассмотрим код, выполняющий эту инструкцию.</p>

<pre><code class="language-no-highlight">section .bss
arr:
    resb 32

section .text
global _start
_start:
    mov     rax, 0x1122334455667788
    lea     rdi, arr
    stosq
    stosq
    stosq
    stosq
    ret</code></pre>

<p>Здесь мы четыре раза кладём значение регистра rax в очередные восемь байт массива. Посмотрим содержимое массива после выполнения этих инструкций. (Здесь <code>32</code> — это количество блоков, <code>x</code> — это формат вывода (шестнадцатеричный), <code>b</code> — это размерность блока.)</p>

<pre><code class="language-no-highlight">...
(gdb) x/32xb &amp;arr
0x402000:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402008:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402010:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402018:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
...</code></pre>

<p>Обратите внимание на второй абзац описания инструкции — там упоминается о том, что есть мы установим direction flag, то итерирование будет в обратную сторону. Чтобы включить и выключить DF, следует использовать инструкции <code>std</code> и <code>cld</code>. Помните, что он глобальный, что может поломать функции, которые вы вызываете.</p>

<pre><code class="language-no-highlight">section .bss
arr:
    resb    32

section .text
global _start
_start:
    std
    mov     rax, 0x1122334455667788
    lea     rdi, arr
    stosq
    stosq
    stosq
    stosq
    ret</code></pre>

<p>После выполнения первой инструкции <code>stosq</code> у вас будет такая картина:</p>

<pre><code class="language-no-highlight">...
(gdb) x/32xb &amp;arr
0x402000:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402008:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402010:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402018:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
...</code></pre>

<p>При выполнении второй инструкции вы получите SIGSEGV, так как значение регистра edi будет на <code>0x402000</code>, а <code>0x401ff8</code>.</p>

<p>Самостоятельно прочитайте описание инструкции <code>lods</code>. Рассмотрим программу:</p>

<pre><code class="language-no-highlight">section .data
arr:
    dw      0xaaaa, 0xbbbb, 0xcccc

section .text
global _start
_start:
    lea     rsi, arr
    lodsw
    lodsw
    lodsw
    ret</code></pre>

<p>Чтобы было, что копировать из памяти, я создал инициализированный массив. Он должен находиться в секции <code>data</code> (так как секция <code>bss</code> хранит только нули). Директива <code>dw</code> означает, что мы хотим положить в секцию words (2 байта), которые перечислены далее (аналогично, есть директивы <code>db</code>, <code>dd</code>, и <code>dq</code>).</p>

<p>Выполните программу в дебаггере и убедитесь, что значние регистра <code>al</code> меняется после каждого выполнения инструкции <code>lodsw</code> на очередной элемент массива.</p><h3 id="5.1.14">5.1.14. Задача: strcpy</h3><p>Напишите программу, которая выполнит копирование из одного ноль-терминированного массива в другой с помощью функций lods и stos.</p><h3 id="5.2">5.2. Application Binary Interface</h3><h3 id="5.2.1">5.2.1. Функции и стек</h3><p> Научимся писать функции.</p>

<pre><code class="language-no-highlight">section .text

set_1:
    mov     rax, 1
    ret

global _start
_start:
    mov     rax, 0
    call    set_1
    ret</code></pre>

<p>Здесь мы объявили метку <code>set_1</code>, после которой идёт реализация нашей функции (понятия функции в языке ассемблера нет).</p>

<p>Мы вызываем функцию с помощью инструкции <code>call</code>. Эта инструкция кладёт на вершину стека адрес следующей инструкции (в данном случае, инструкции <code>ret</code> в функции <code>_start</code>) и выполняет прыжок к адресу, равному значению аргумента. Мы выходим из функции с помощью инструкции <code>ret</code>. Эта инструкция вытаскивает адрес с вершины стека и прыгает в него.</p>

<p>Стек — это массив в отдельном сегменте, на который мы можем записывать данные. Мы оперируем с ним так же, как и со структурой данных "стек". Адрес текущей вершины стека хранится в регистре <code>rsp</code> (sp = stack pointer). В отличии от других регистров общего назначения, из-за обилия инструкций, которые влияют на этот регистр, мы не можем его комфортно использовать так, как мы захотим. (Это же часто касается и регистра <code>rbp</code> (bp = base pointer), но о нём позже.)</p>

<p>Проверим это. Запустим программу в дебаггере и выведем стек, находясь в функции <code>set_1</code>. Если мы выполним команду <code>ni</code>, находясь на инструкции <code>call</code>, то мы не войдём в функцию. Чтобы в неё войти, следует использовать команду <code>si</code>.</p>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│rax            0x0                 0                                                                   │
│rbx            0x0                 0                                                                   │
│rcx            0x0                 0                                                                   │
│rdx            0x0                 0                                                                   │
│rsi            0x0                 0                                                                   │
│rdi            0x0                 0                                                                   │
│rbp            0x0                 0x0                                                                 │
│rsp            0x7fffffffdc78      0x7fffffffdc78                                                      │
│r8             0x0                 0                                                                   │
│r9             0x0                 0                                                                   │
│r10            0x0                 0                                                                   │
│r11            0x0                 0                                                                   │
│r12            0x0                 0                                                                   │
│r13            0x0                 0                                                                   │
│r14            0x0                 0                                                                   │
┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│  &gt; 0x401000 &lt;set_1&gt;        mov    $0x1,%eax                                                           │
│    0x401005 &lt;set_1+5&gt;      ret                                                                        │
│B+  0x401006 &lt;_start&gt;       mov    $0x0,%eax                                                           │
│    0x40100b &lt;_start+5&gt;     call   0x401000 &lt;set_1&gt;                                                    │
│    0x401010 &lt;_start+10&gt;    ret                                                                        │
│    0x401011                add    %al,(%rax)                                                          │
│    0x401013                add    %al,(%rax)                                                          │
│    0x401015                add    %al,(%rax)                                                          │
│    0x401017                add    %al,(%rax)                                                          │
│    0x401019                add    %al,(%rax)                                                          │
│    0x40101b                add    %al,(%rax)                                                          │
│    0x40101d                add    %al,(%rax)                                                          │
│    0x40101f                add    %al,(%rax)                                                          │
│    0x401021                add    %al,(%rax)                                                          │
│    0x401023                add    %al,(%rax)                                                          │
│    0x401025                add    %al,(%rax)                                                          │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
native process 16786 In: set_1                                                        L??   PC: 0x401000 
Function "main" not defined.
--Type &lt;RET&gt; for more, q to quit, c to continue without paging--Make breakpoint pending on future shared
library load? (y or [n]) [answered N; input not from terminal]
Breakpoint 1 at 0x401006

Breakpoint 1, 0x0000000000401006 in _start ()
(gdb) ni
0x000000000040100b in _start ()
(gdb) si
0x0000000000401000 in set_1 ()
(gdb) x/32xb $rsp
0x7fffffffdc78: 0x10    0x10    0x40    0x00    0x00    0x00    0x00    0x00
0x7fffffffdc80: 0x01    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x7fffffffdc88: 0x34    0xe0    0xff    0xff    0xff    0x7f    0x00    0x00
0x7fffffffdc90: 0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
</code></pre>

<p>Верхние четыре байта на стеке — <code>0x00401010</code>. Видно, что это же является адресом инструкции <code>ret</code> в функции <code>_start</code>. Также мы видим, что следующие четыре байта на стеке — <code>0x00000000</code>, в которые и прыгнет инструкция <code>ret</code> в функции <code>_start</code>.</p>

<p>Чтобы передать в функцию аргументы, мы должны перед её вызовом положить их в стек. (Если вы ещё не заметили по выводу в дебаггере: когда мы кладём что-либо на стек, адрес его вершины уменьшается, а когда мы вытаскиваем что-либо из стека, адрес его вершины увеличивается.) Тогда эти аргументы будут под адресом возврата, и последний аргумент, который мы положили на стек, в вызванной функции будет находится по адресу <code>[rsp + 8]</code> (или не <code>8</code>, если у вас другая разрядность программы).</p>

<pre><code class="language-no-highlight">section .text

sum:
    mov     rax, [rsp + 8]
    add     rax, [rsp + 16]
    ret

global _start
_start:
    push    2
    push    3
    call    sum
    add     rsp, 16
    ret</code></pre>

<p>Назначение функции <code>push</code> очевидно — она кладёт свой аргумент на вершину стека. Мы можем имитировать её поведение комбинацией из двух инструкций:</p>

<pre><code class="language-no-highlight">    sub     rsp, 8
    mov     dword [rsp], 2</code></pre>

<p>Чтобы вытащить аргументы, можно воспользоваться инструкцией <code>pop</code>. Но нам не нужно их вытаскивать — вместо этого мы можем просто сдвинуть адрес вершины стека.</p><h3 id="5.2.2">5.2.2. Вызов функций в 32-bit</h3><p>Попробуем вызвать функцию <code>printf</code>. В 32-bit правила такие же: все аргументы должны быть положены на стек в обратном порядке их перечисления в сигнатуре (правда, мы видели, что практически сигнатура не налагает никаких ограничений).</p>

<p>Сделать это несколько проблематично: при комбинациях для компиляции и компоновки <code>gcc</code> +  <code>gcc</code> и <code>nasm</code> + <code>ld</code> у меня были нетривиальные проблемы. (В первом случае gcc упорно добавлял PIC, а во втором не получалось нормально прикомпоновать <code>libc</code>.) При комбинации <code>nasm</code> + <code>gcc</code> получилось проще всего.</p>

<p><code>main.asm</code></p>

<pre><code class="language-no-highlight">section .data
format:
    db      "Check... %d", 0xA, 0x0

section .text

extern printf

global main
main:
    push    dword 123
    push    format
    call    printf
    add     esp, 8
    ret</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf32 main.asm -o main.o
$ gcc -m32 -no-pie main.o -o main
$ ./main
Check... 123</code></pre>

<p><strong>Внимание! При выполнении операций со стеком будет поддерживаться инвариант "значение rsp делится на 8". Однако, фунцкия printf требует, чтобы значение rsp делилось на 16. Простой способ этого добиться — добавлять 8 байт на стек, когда нужно. Необходимость таких сдвигов носит случайный характер, поэтому на вашей системе код может быть нерабочим, и вам понадобится выполнить сдвиг стека самостоятельно.</strong></p>

<p>Чтобы <code>nasm</code> поверил, что метка <code>printf</code> появится на этапе компоновки, мы пользуемся директивой <code>extern</code>.</p>

<p>Под меткой <code>format</code> написана строка <code>Check... %d\n\0</code>. (Помните, что ассемблеры обычно сами не добавляют нули в конце строки. Например, в gnu assembly для создания строки без нуля и с нулём на конце используются директивы <code>.ascii</code> и <code>.asciz</code> соответственно.)</p>

<p>Обратите внимание — программа перестала завершаться SIGSEGV-ом. Это произошло потому, что gcc использовал свой скрипт для компоновки (поэтому же я также использовал метку <code>main</code>).</p>

<p>Сейчас мы впервые прикомпоновали нашу программу с функцией во внешнем объектном файле. Функция успешно вызвалась и выполнилась, потому что мы положили аргументы на стек именно так, как она ожидала. Есть некие стандарты о том, как следует передавать аргументы функциям, и как функции должны их считывать. Это необходимо, так как на таком уровне у нас нет никаких автоматических способов это контролировать (подобно тому, как в цельной программе на высокоуровневом языке C компилятор не позволит нам передать что-либо неправильно). Эти стандарты называются <code>Application Binary Interface</code> (<code>ABI</code>).</p><h3 id="5.2.3">5.2.3. Задача: На цикл, но на языке ассемблера с libc</h3><p>Напишите решение любой задачи (например, задачи про брокера Василия из главы "Контроль потока") на языке ассемблера, используя функции libc. Попробуйте хранить данные как в секции <code>.bss/.data</code>, так и в динамическом массиве, создав его с помощью функции <code>malloc</code>.</p><h3 id="5.2.4">5.2.4. System V ABI</h3><p>С ABI всё довольно запутано. По хорошему, мы будем стремиться использовать <code>System V</code>. В основном, нас интересуют только две вещи в очередном ABI:</p>

<ul>
	<li>Как передаются аргументы в функции.</li>
	<li>Какие регистры являются scratch/caller saved и какие регистры являются preserved/callee saved.</li>
</ul>

<p>Посмотрим на таблицу с System V для 32-bit и 64-bit. (На самом деле, <code>cdecl</code>, который используется в C — это не совсем System V.) <a href="https://wiki.osdev.org/Calling_Conventions" rel="noopener noreferrer nofollow">https://wiki.osdev.org/Calling_Conventions</a></p>

<table border="1" cellpadding="4" cellspacing="0" style="background: #f9f9f9; border: 1px #aaaaaa solid;">
	<tbody>
		<tr>
			<th>Platform</th>
			<th>Return Value</th>
			<th>Parameter Registers</th>
			<th>Additional Parameters</th>
			<th>Stack Alignment</th>
			<th>Scratch Registers</th>
			<th>Preserved Registers</th>
			<th>Call List</th>
		</tr>
		<tr>
			<td>System V i386</td>
			<td>eax, edx</td>
			<td>none</td>
			<td>stack (right to left)<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note1" rel="noopener noreferrer nofollow">1</a></sup></td>
			<td> </td>
			<td>eax, ecx, edx</td>
			<td>ebx, esi, edi, ebp, esp</td>
			<td>ebp</td>
		</tr>
		<tr>
			<td>System V X86_64<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note2" rel="noopener noreferrer nofollow">2</a></sup></td>
			<td>rax, rdx</td>
			<td>rdi, rsi, rdx, rcx, r8, r9</td>
			<td>stack (right to left)<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note1" rel="noopener noreferrer nofollow">1</a></sup></td>
			<td>16-byte at call<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note3" rel="noopener noreferrer nofollow">3</a></sup></td>
			<td>rax, rdi, rsi, rdx, rcx, r8, r9, r10, r11</td>
			<td>rbx, rsp, rbp, r12, r13, r14, r15</td>
			<td>rbp</td>
		</tr>
		<tr>
			<td>Microsoft x64</td>
			<td>rax</td>
			<td>rcx, rdx, r8, r9</td>
			<td>stack (right to left)<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note1" rel="noopener noreferrer nofollow">1</a></sup></td>
			<td>16-byte at call<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note3" rel="noopener noreferrer nofollow">3</a></sup></td>
			<td>rax, rcx, rdx, r8, r9, r10, r11</td>
			<td>rbx, rdi, rsi, rsp, rbp, r12, r13, r14, r15</td>
			<td>rbp</td>
		</tr>
		<tr>
			<td>ARM (32-bit)</td>
			<td>r0, r1</td>
			<td>r0, r1, r2, r3</td>
			<td>stack</td>
			<td>8 byte<sup><a href="https://wiki.osdev.org/Calling_Conventions#Note4" rel="noopener noreferrer nofollow">4</a></sup></td>
			<td>r0, r1, r2, r3, r12</td>
			<td>r4, r5, r6, r7, r8, r9, r10, r11, r13, r14</td>
			<td> </td>
		</tr>
	</tbody>
</table>

<p>Разберёмся для начала с 32-bit (i386 (история x86 полна сюрпризов)).</p>

<ul>
	<li>Ранее я говорил, что результат функции возвращается в регистре <code>*ax</code>. Напомню также, что результат умножения хранится в регистрах <code>*dx:*ax</code>.</li>
	<li>Аргументы в функции не передаются в регистрах (мы этого и не наблюдали).</li>
	<li>Дополнительные (а, так как аргументов в регистрах и нет, то все) аргументы передаются на стеке, и кладутся вызываемой функцией справа налево (есть ABI, где наоборот) в порядке, указанном в сигнатуре функции.</li>
</ul>

<p>Обратим внимание на scratch и preserved registers. Напомню, что регистры являются глобальными, поэтому за ними нужно очень внимательно наблюдать. Если вы выполняете какое-либо вычисление в регистрах, и в процессе этого вызываете функцию, значения регистров могут быть изменены. Для того, чтобы не потерять промежуточные вычисления, следует либо сохранить эти регистры на стек перед вызовом функции, либо поверить, что вызываемая функция их не изменит.</p>

<p>Итак, регистры, которые функция обязана не менять называются preserved (callee (вызываемый) saved), а регистры, которые функция может изменить (а поэтому их должна сохранить на стек вызывающая функция) называются scratch (caller (вызывающий) saved).</p>

<p>Зачем нужны scratch регистры, если без проблем можно сохранять все регистры? Для экономии времени выполнения, так как мы можем намеренно не хранить промежуточные вычисления в этих регистрах и не сохранять их вообще.</p>

<p>Помните, что "недобросовестная" функция без каких либо проблем может не сохранить preserved регистры (может быть, она была написана под особым ABI).</p>

<pre><code class="language-no-highlight">foo:
    push    rbx
    mov     rcx, 1
    mov     rbx, 1
    mov     rax, rbx
    add     rax, rcx
    pop     rbx
    ret</code></pre>

<p>Посмотрите на эту функцию-пример. Она использует для своих вычислений регистры rbx и rcx. При этом, так как регистр rbx является preserved, она его сохраняет на стеке, а затем восстанавливает.</p>

<p>Обратите внимание, что некоторые регистры в 32-bit и 64-bit имеют разную принадлежность. Например, esi в 32-bit является preserved, а rdi в 64-bit является scratch.</p><h3 id="5.2.5">5.2.5. Вызов функций в 64-bit, системный вызов</h3><p>Обратим теперь внимание на 64-bit ABI. Помимо добавления новых регистров <code>r8-15</code> (которые ничем не отличаются от первых восьми) и перераспределения их по группам scratch/preserved, теперь первые аргументы функций передаются в регистрах (так как операции с регистрами быстрее, а раньше регистров не хватало).</p>

<p><code>main.asm</code></p>

<pre><code class="language-no-highlight">section .data
format:
    db      "Check... %d", 0xA, 0x0

section .text

extern printf

global main
main:
    sub     rsp, 8 ; for printf
    mov     rdi, format
    mov     rsi, 123
    call    printf
    add     rsp, 8 ; for printf
    ret</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf64 main.asm -o main.o
$ gcc main.o -o main -no-pie
$ ./main
Check... 123</code></pre>

<p>Посмотрев на таблицу, мы видим, что первый аргумент передаётся в регистре <code>rdi</code>, а второй — в регистре <code>rsi</code>.</p>

<p>(Здесь я добавил сдвиг стека для удовлетворения printf-а.)</p>

<p>Откроем таблицу системных вызовов: <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>

<p>Мы готовы вызывать системные вызовы самостоятельно!</p>

<p>Начнём с простейшего СВ — fork. Посмотрите на таблицу. Функция кодируется значеним регистра rax. У СВ fork это значение — <code>0x39</code>. Аргументы в СВ передаются в регистрах почти также, как и в функции в System V (единственное отличие — третий аргумент передаётся в регистре <code>r10</code>, вместо <code>rcx</code>).</p>

<pre><code class="language-no-highlight">section .data
format:
    db      "Check... %d", 0xA, 0x0

section .text

extern printf

global main
main:
    mov     rax, 0x39
    syscall
    
    push    rbp
    mov     rdi, format
    mov     rsi, 123
    call    printf
    pop     rbp
    ret</code></pre>

<p>Чтобы выполнить СВ, мы заполняем регистры нужными значениями, а затем выполняем инструкцию <code>syscall</code>.</p>

<pre><code class="language-no-highlight">$ ./main
Check... 123
Check... 123</code></pre>

<p>Для 32-bit дейтвия чуть другие.</p>

<pre><code class="language-no-highlight">section .data
format:
    db      "Check... %d", 0xA, 0x0

section .text

extern printf

global main
main:
    mov     eax, 0x2
    int     0x80

    push    dword 123
    push    format
    call    printf
    add     esp, 8
    ret</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf32 main.asm -o main.o
$ gcc -m32 -no-pie main.o -o main
$ ./main
Check... 123
Check... 123</code></pre>

<p>Во-первых, номер СВ теперь <code>0x2</code> (другая таблица), а во-вторых, нам необходимо использовать инструкцию <code>int</code> с аргументов <code>0x80</code> (об этой инструкции позже).</p><h3 id="5.2.6">5.2.6. Задача: Системный вызов exit</h3><p>Изучите системный вызов <code>exit</code> и с помощью неё завершите программу не SIGSEGV-ом.</p><h3 id="5.2.7">5.2.7. Системные вызовы fork, read, write</h3><p>Научимся выводить текст без помощи libc. Для этого нужно воспользоваться СВ write, которые, в отличии от СВ fork, имеет несколько аргументов: дескриптор stream-а (в нашем случае, stdout, то есть, <code>1</code>), буфер для вывода (никакое форматирование не поддерживается) и длина буфера (буфер не обязан заканчиваться нулём).</p>

<pre><code class="language-no-highlight">section .data
buffer:
    db      "Check...", 0xA
length: 
    dd      length - buffer

section .text
global _start
_start:
    mov     rax, 0x39
    syscall
    
    mov     rax, 0x1
    mov     rdi, 0x1
    mov     rsi, buffer
    mov     rdx, [length]
    syscall
    ret</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf64 main.asm -o main.o
$ ld main.o -o main</code></pre>

<p>Чтобы добыть длину буфера, мы вычитаем из метки, находящейся после буфера метку, находящеюся до буфера. Длина числа, согласно документации — четыре байта.</p>

<p>Так мы можем написать программу, которая считывает строку и выводит её же.</p>

<pre><code class="language-no-highlight">%define LENGTH 1024

section .bss
buffer:
    resb    LENGTH
length:
    resb    4

section .text
global _start
_start:
    mov     rax, 0x0
    mov     rdi, 0x0
    mov     rsi, buffer
    mov     rdx, LENGTH
    syscall
    mov     [length], rax

    mov     rax, 0x1
    mov     rdi, 0x1
    mov     rsi, buffer
    mov     rdx, [length]
    syscall
    ret</code></pre>

<p>Здесь я для удобства использовал макрос <code>%define</code>. Макросы работают в nasm-е так же, как и в gcc.</p>

<p>Если подать СВ write длину, равную <code>LENGTH</code>, то оставшиеся в буфере нули мы никак в терминале не увидим. Тем не менее, следует вывести ровно столько байт, сколько мы считали. СВ возвращают значение в регистре <code>rax</code>. СВ read возвращает количество символов, которые он считал. Сохраним это число и используем как длину сообщения, которое следует вывести.</p><h3 id="5.2.8">5.2.8. Задача: На цикл, но на языке ассемблера без libc</h3><p>Напишите решение любой задачи (например, задачи про брокера Василия из главы "Контроль потока") на языке ассемблера, используя системные вызовы.</p><h3 id="5.2.9">5.2.9. Анализ вывода компилятора gcc в 64-bit</h3><p>Чтобы получить лучшее представление о том, как следует складировать локальные переменные и аргументы функций на стеке, обратимся к компилятору и посмотрим, как он это делает. Здесь же мы наконец поймем, для чего нужен регистр <code>rbp</code>.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">int boo(int x, int y) {
    return x * y;
}

int foo(int x, int y) {
    int a = x + y;
    int b = x - y;
    return boo(a, b);
}

int main() {
    int x = 2;
    int y = 3;
    int z = foo(x, y);
}</code></pre>

<p>При обычной компиляции вы будете получать такие <code>cfi*</code> директивы, которые используют дебаггеры, чтобы понять, где в стеке какие функции. Для удобства уберём их флагом <code>-fno-asynchronous-unwind-tables</code> .</p>

<p>Начнём в 64-bit.</p>

<pre><code class="language-no-highlight">$ gcc main.c -o main.S -S -masm=intel -fno-asynchronous-unwind-tables</code></pre>

<p>Пойдем по каждой функции.</p>

<pre><code class="language-no-highlight">boo:
	endbr64
	push	rbp
	mov	rbp, rsp
	mov	DWORD PTR -4[rbp], edi
	mov	DWORD PTR -8[rbp], esi
	mov	eax, DWORD PTR -4[rbp]
	imul	eax, DWORD PTR -8[rbp]
	pop	rbp
	ret</code></pre>

<p>Инструкция (не директива) <code>endbr64</code> является защитной: при определенной комбинации флагов в контрольных регистрах процессор будет производить прерывание, если вы совершите инструкцию <code>call</code> не в адрес, на котором стоит <code>endbr64</code>. (Это сделано для предотвращения атаки, при которой вы подменяете адрес и прыгаете не в начало функции.)</p>

<p>Манипуляции с регистром rbp пока не особо понятны. Этот регистр зачем-то временно сохраняется на стек и в него записывается значение регистра rsp.</p>

<p>После выполнения <code>push rbp</code> и <code>mov rbp, rsp</code> по адресу <code>rbp</code> хранится старый rbp, а по адресу <code>rbp + 8</code> хранится адрес возврата. Аргументы передаются в регистрах <code>edi</code> и <code>esi</code> (так как имеют размерность четыре байта) и сразу же сохраняются на стек (обратите внимание, что это делается не инструкцией push, поэтому регистр rsp не меняется, и поэтому выполнение инструкции call здесь затрёт аргументы). После этого выполняется умножение об эти аргументы, сохранённые на стеке.</p>

<p>Почему аргументы были сначала помещены на стек, если можно перемножить сразу регистры? Из-за низкого уровня оптимизации. (Его можно установить флагами <code>-O1</code>, <code>-O2</code> и т.д.) (На самом деле, эта задача весьма сложна, и я плохо понимаю, как её решать.)</p>

<pre><code class="language-no-highlight">foo:
	endbr64
	push	rbp
	mov	rbp, rsp
	sub	rsp, 24

	mov	DWORD PTR -20[rbp], edi
	mov	DWORD PTR -24[rbp], esi

	mov	edx, DWORD PTR -20[rbp]
	mov	eax, DWORD PTR -24[rbp]
	add	eax, edx
	mov	DWORD PTR -8[rbp], eax

	mov	eax, DWORD PTR -20[rbp]
	sub	eax, DWORD PTR -24[rbp]
	mov	DWORD PTR -4[rbp], eax

	mov	edx, DWORD PTR -4[rbp]
	mov	eax, DWORD PTR -8[rbp]
	mov	esi, edx
	mov	edi, eax
	call	boo

	leave
	ret</code></pre>

<p>Здесь я разделил программу на шесть блоков. Я в предыдущей функции говорил: "обратите внимание, что это делается не инструкцией push, поэтому регистр rsp не меняется, и поэтому выполнение инструкции call здесь затрёт аргументы". Теперь компилятор эту проблему исправил: он сдвинул регистр <code>rsp</code> на то расстояние, которое использовал в функции для локальных вычислений, а при выходе использовал инструкцию <code>leave</code> (прочитайте самостоятельно в ISA, что она делает).</p>

<p>Во втором блоке компилятор просто сохранил переданные аргументы на стек, но несколько дальше, чем в прошлый раз.</p>

<p>В третьем блоке компилятор выполнил вычисление <code>int a = x + y;</code>. Для этого он достал аргументы из стека в регистры <code>edx</code> и <code>eax</code>, сложил, и сохранил назад на стек. То же самое он сделал и в четвёртой строке для вычисления <code>int b = x - y</code>.</p>

<p>В пятом блоке компилятор достал <code>a</code> и <code>b</code> в регистры <code>edx</code> и <code>eax</code>, переместил их в регистры <code>edi</code> и <code>esi</code> и выполнил вызов функции <code>boo</code>.</p>

<p>Обратите внимание, что ячейки <code>rbp - 12</code> и <code>rbx - 16</code> не были использованы. Полагаю, это лишь из-за недостаточного уровня оптимизации.</p>

<p>Функцию main можете разобрать самостоятельно.</p><h3 id="5.2.10">5.2.10. Анализ вывода компилятора gcc в 32-bit</h3><p>Посмотрим, как gcc компилирует в 32-bit ту же программу. Из-за того, что на стеке теперь хранятся и аргументы функций, манипуляции с ним стали чуть сложнее.</p>

<pre><code class="language-no-highlight">$ gcc main.c -o main.S -S -m32 -masm=intel -fno-asynchronous-unwind-tables -fno-pie</code></pre>

<pre><code class="language-no-highlight">boo:
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR [ebp+8]
	imul	eax, DWORD PTR [ebp+12]
	pop	ebp
	ret</code></pre>

<p>Посмотрите, где теперь функция boo берёт аргументы. Напомню, что в 32-bit мы передаём все аргументы на стеке, причем кладём их справа налево в порядке, который указан в сигнатуре функции. То есть, левые аргументы будут ближе к верху стека (иметь меньшие адреса). Мы знаем, что в <code>ebp</code> хранится старый ebp, а в <code>ebp + 4</code> хранится адрес возврата. Тогда в <code>ebp + 8</code> хранится первый аргумент, а в <code>ebp + 12</code> хранится второй аргумент.</p>

<pre><code class="language-no-highlight">foo:
	push	ebp
	mov	ebp, esp
	sub	esp, 16

	mov	edx, DWORD PTR [ebp+8]
	mov	eax, DWORD PTR [ebp+12]
	add	eax, edx
	mov	DWORD PTR [ebp-8], eax

	mov	eax, DWORD PTR [ebp+8]
	sub	eax, DWORD PTR [ebp+12]
	mov	DWORD PTR [ebp-4], eax

	push	DWORD PTR [ebp-4]
	push	DWORD PTR [ebp-8]
	call	boo
	add	esp, 8

	leave
	ret</code></pre>

<p>Здесь фаза сохранения аргументов из регистров на стек отсутствует (так как они изначально на стеке). Здесь стек использован несколько оптимальнее: локальная переменная <code>a</code> хранится в <code>ebp - 8</code>, а локальная переменная <code>b</code> хранится в <code>ebp - 4</code>. При этом стек всё равно сдвигается на <code>16</code>: <code>sub esp, 16</code>. Полагаю, чтобы значение esp по прежнему делилось на <code>16</code>.</p>

<p>Я заметил пару забаных вещей по сравнению с 32-bit компиляцией.</p>

<ul>
	<li>Здесь появилась инструкция <code>add esp, 8</code>. Её смысл понятен — она возвращает вершину стека на место после того, как мы положили на него аргументы функции <code>boo</code>. Но из-за логики работы инструкции <code>leave</code>, в этой инструкции <code>add</code> нет смысла.</li>
	<li>Почему-то в 64-bit адреса пишутся в формате <code>-4[rbp]</code>, а в 32-bit в формате <code>[ebp-4]</code>. (Насколько я знаю, они ничем не отличаются.)</li>
</ul><h3 id="5.2.11">5.2.11. Проект: Компилятор</h3><p>Это масштабный, сложный и интересный проект.</p>

<p>Напишите компилятор для простейшего языка C подобного языка, который будет переписывать код на язык ассемблера. Ключевым здесь является наличие функций, локальных переменных и ветвлений.</p>

<p>Примерный план, как это можно сделать. Для простоты, язык будет иметь только statement-ы.</p>

<ul>
	<li>Считать текст и разбить его на statement-ы.</li>
	<li>Создать структуры для statement-ов.</li>
	<li>Один из statement-ов — блок, содержащий список statement-ов.</li>
	<li>Остальные statement-ы:
	<ul>
		<li>if — <code>if (a == 0) BLOCK</code> (по хорошему, аргумент должен быть expression, но можно проверять и только на ноль)</li>
		<li>definition — <code>def a, b</code></li>
		<li>assignment — <code>a = 5</code></li>
		<li>addition — <code>a = b + 4</code> (по хорошему, это должен быть expression)</li>
		<li>function definition — <code>func foo(a, b) BLOCK</code></li>
		<li>function call — <code>foo(a, b)</code></li>
	</ul>
	</li>
	<li>Statement-ы должны быть организованы в дерево, и компиляция выполняется обходом по этому дереву.</li>
	<li>Компиляция каждого из statement-ов, после изучения вывода компилятора gcc, должна быть очевидной.</li>
</ul><h3 id="5.3">5.3. Компоновка</h3><h3 id="5.3.1">5.3.1. Немного reverse engineering-а</h3><p>В коде на языке C мы без ограничений можем вызывать функции, которые определены в отдельном объектном файле, который был ассемблирован nasm-ом или любым другим ассемблером. Необходимо лишь, чтобы названия меток были одинаковыми.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int my_fork();

int main() {
    int x = my_fork();
    printf("%d\n", x);
}</code></pre>

<p><code>fork.asm</code></p>

<pre><code class="language-no-highlight">section .text
global my_fork
my_fork:
    mov     rax, 0x39
    syscall</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf64 fork.asm -o fork.o
$ gcc main.c -c -o main.o
$ gcc main.o fork.o -o main
$ ./main
51517
0
</code></pre>

<p>Так ли реализована функция fork, которую мы вызываем в C? Проверим это с помощью дебаггера.</p>

<pre><code class="language-cpp">#include &lt;unistd.h&gt;

int main() {
    fork();
}</code></pre>

<pre><code class="language-no-highlight">    0x7ffff7ceab30 &lt;__GI__Fork&gt;     endbr64                                                            │
    0x7ffff7ceab34 &lt;__GI__Fork+4&gt;   mov    %fs:0x10,%rax                                               │
    0x7ffff7ceab3d &lt;__GI__Fork+13&gt;  xor    %r8d,%r8d                                                   │
    0x7ffff7ceab40 &lt;__GI__Fork+16&gt;  xor    %edx,%edx                                                   │
    0x7ffff7ceab42 &lt;__GI__Fork+18&gt;  xor    %esi,%esi                                                   │
    0x7ffff7ceab44 &lt;__GI__Fork+20&gt;  mov    $0x1200011,%edi                                             │
    0x7ffff7ceab49 &lt;__GI__Fork+25&gt;  lea    0x2d0(%rax),%r10                                            │
    0x7ffff7ceab50 &lt;__GI__Fork+32&gt;  mov    $0x38,%eax                                                  │
  &gt; 0x7ffff7ceab55 &lt;__GI__Fork+37&gt;  syscall                                                            │
</code></pre>

<p>В моём случае функция сделала некоторую подготовительную работу и вызвала системный вызов <code>0x38</code> (что видно по инструкции перед syscall). Номер <code>0x38</code> имеет СВ clone, частным случаем которого является fork.</p>

<p>Сделаем еще один эксперимент и проверим, какой системный вызов использует функция <code>malloc</code>.</p>

<pre><code class="language-cpp">#include &lt;stdlib.h&gt;

int main() {
    void *a = malloc(1);
}</code></pre>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│rax            0xc                 12                                                                  │
│rbx            0x21000             135168                                                              │
│rcx            0x2b0               688                                                                 │
│rdx            0x0                 0                                                                   │
│rsi            0x7ffff7e1ac80      140737352150144                                                     │
│rdi            0x0                 0                                                                   │
│rbp            0x7ffff7e22218      0x7ffff7e22218 &lt;__curbrk&gt;                                           │
│rsp            0x7fffffffd998      0x7fffffffd998                                                      │
│r8             0x2                 2                                                                   │
│r9             0x7ffff7fc9040      140737353912384                                                     │
│r10            0x7ffff7e1ace0      140737352150240                                                     │
│r11            0x7ffff7e1ace0      140737352150240                                                     │
│r12            0x0                 0                                                                   │
│r13            0x7ffff7e1ace0      140737352150240                                                     │
│r14            0x1000              4096                                                                │
┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│    0x7ffff7d1a820 &lt;__brk&gt;          endbr64                                                            │
│    0x7ffff7d1a824 &lt;__brk+4&gt;        mov    $0xc,%eax                                                   │
│  &gt; 0x7ffff7d1a829 &lt;__brk+9&gt;        syscall                                                            │
│    0x7ffff7d1a82b &lt;__brk+11&gt;       mov    0xff62e(%rip),%rdx        # 0x7ffff7e19e60                  │
│    0x7ffff7d1a832 &lt;__brk+18&gt;       mov    %rax,(%rdx)                                                 │
│    0x7ffff7d1a835 &lt;__brk+21&gt;       cmp    %rdi,%rax                                                   │
│    0x7ffff7d1a838 &lt;__brk+24&gt;       jb     0x7ffff7d1a840 &lt;__brk+32&gt;                                   │
│    0x7ffff7d1a83a &lt;__brk+26&gt;       xor    %eax,%eax                                                   │
│    0x7ffff7d1a83c &lt;__brk+28&gt;       ret                                                                │
│    0x7ffff7d1a83d &lt;__brk+29&gt;       nopl   (%rax)                                                      │
│    0x7ffff7d1a840 &lt;__brk+32&gt;       mov    0xff5c9(%rip),%rax        # 0x7ffff7e19e10                  │
│    0x7ffff7d1a847 &lt;__brk+39&gt;       movl   $0xc,%fs:(%rax)                                             │
│    0x7ffff7d1a84e &lt;__brk+46&gt;       mov    $0xffffffff,%eax                                            │
│    0x7ffff7d1a853 &lt;__brk+51&gt;       ret                                                                │
│    0x7ffff7d1a854                  cs nopw 0x0(%rax,%rax,1)                                           │
│    0x7ffff7d1a85e                  xchg   %ax,%ax                                                     │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>

<p>На этот раз подготовительного кода было намного больше, и вам скорее всего потребуется несколько попыток, чтобы разобраться в нём и не потеряться. В конечном итоге будет вызван СВ с номером <code>0xC</code>, то есть, <code>brk</code>.</p>

<p>Скажу просто как факт: malloc использует два системного вызова в зависимости от ситуации: <code>brk</code> и <code>mmap/mmunmap</code>.</p>

<p>СВ brk изменяет размер сегмента <code>.data</code> (данный СВ считается устаревшим и информацию о нём найте непросто), а <code>mmap/munmap</code> работают примерно как <code>malloc/free</code>, но дают больший контроль над адресами, которые мы можем получить.</p>

<p>В любом случае, мы не можем делать системный вызов на каждый вызов malloc-а, поскольку выполнение любого системного вызова довольно медленное (поэтому, например, printf выполняет буферизацию). Вместо этого для реализации malloc-а мы должны один раз выделить большой отрезок памяти а затем построить на нём структуру данных "куча/heap" (не путать с кучей из теории алгоритмов (здесь терминология совпала и на английском языке)).</p>

<p>Сейчас мы выполнили reverse engineering. Будьте аккуратны — это в общем случае незаконно.</p><h3 id="5.3.2">5.3.2. Задача: Своя реализация функций для системных вызовов</h3><p>В любой ранее написанной программе замените как можно больше libc-функций (<code>fork</code>, <code>open</code>, <code>printf</code>), выполняющих системные вызовы, на свои функции, выполняющие системные вызовы и написанные на языке ассемблера.</p><h3 id="5.3.3">5.3.3. Перегрузка и экранирование символов в C++</h3><p>Попробуем прикомпоновать функцию, написанную на языке ассемблера, к программе, написанной на языке C++. Воспользуемся GNU GCC компилятором — <code>g++</code>. Его использование ничем не отличается, от использования компилятора gcc.</p>

<p><code>main.cpp</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int foo(int x);

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p><code>foo.asm</code></p>

<pre><code class="language-no-highlight">section .text
global foo
foo:
    mov     rax, rdi
    add     rax, 1
    ret</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf64 foo.asm -o foo.o
$ g++ main.cpp -c -o main.o
$ g++ main.o foo.o -o main
/usr/bin/ld: main.o: in function `main':
main.cpp:(.text+0xe): undefined reference to `foo(int)'
collect2: error: ld returned 1 exit status</code></pre>

<p>Хм, компоновщик сообщает, что функция foo не определена. На самом деле, он немного лжёт и говорит о другой функции. Посмотрим на файл <code>main.o</code> подробнее с помощью readelf.</p>

<pre><code class="language-no-highlight">$ readelf -a main.o
...
Symbol table '.symtab' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.cpp
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     4: 0000000000000000    47 FUNC    GLOBAL DEFAULT    1 main
     5: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND _Z3fooi
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
...</code></pre>

<p>Секция <code>.symtab</code>, которую автоматически генерирует ассемблер, хранит метки, используемые в файле. Посмотрите на список: в нём нет метки <code>foo</code>, но есть некая метка <code>_Z3fooi</code>. Это и есть наша функция foo.</p>

<p>Если вы ещё не знали, в C++ существует перегрузка функций (function overloading). Это означает, что вы можете определить несколько функций, которые имеют одинаковое название, на разную сигнатуру, и компилятор будет подставлять нужную функцию, исходя из типов аргументов.</p>

<p><code>main.cpp</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int foo(int x) {
    return x + 1;
}

int foo(const char *str) {
    return strlen(str);
}

int main() {
    printf("%d %d\n", foo(2), foo("Hello"));
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ g++ main.cpp -o main
$ ./main
3 5</code></pre>

<p>Компоновщик не знает о перегрузке функций, поэтому компилятор языка C++ просто кодирует сигнутуру функции прямо в название её метки. Это называется mangling (на русском, полагаю, можно назвать экранированием). Чтобы расшифровать метку, можно использовать программу <code>c++filt</code>.</p>

<pre><code class="language-no-highlight">$ c++filt
_Z3fooi
foo(int)</code></pre>

<p>Чтобы g++ не выполнил mangle, следует в объявлении функции написать директиву <code>extern "C"</code>. (Либо же можно в файле ассемблера объявить метку <code>_Z3fooi</code>, что, конечно, неудобно.)</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

extern "C" int foo(int x);

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ g++ main.cpp -c -o main.o
$ g++ main.o foo.o -o main
$ ./main
3</code></pre><h3 id="5.3.4">5.3.4. Анализ секций</h3><p>Разберёмся с тем, какие секции присутствуют в объектном файле, и как компоновщих ищет и подставляет адреса меток из разных модулей.</p>

<p><code>main.asm</code></p>

<pre><code class="language-no-highlight">section .data
buffer:
    db      "Check...", 0xA
length: 
    dd      length - buffer

section .text
extern exit
global _start
_start:
    mov     rax, 0x1
    mov     rdi, 0x1
    mov     rsi, buffer
    mov     rdx, [length]
    syscall

    call    exit</code></pre>

<p>Выполним ассемблирование, а затем дизассемблирование объектного файла.</p>

<pre><code class="language-no-highlight">$ nasm -felf64 main.asm -o main.o
$ objdump -d main.o

main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt;_start&gt;:
   0:	b8 01 00 00 00       	mov    $0x1,%eax
   5:	bf 01 00 00 00       	mov    $0x1,%edi
   a:	48 be 00 00 00 00 00 	movabs $0x0,%rsi
  11:	00 00 00 
  14:	48 8b 14 25 00 00 00 	mov    0x0,%rdx
  1b:	00 
  1c:	0f 05                	syscall 
  1e:	e8 00 00 00 00       	call   23 &lt;length+0x1a&gt;</code></pre>

<p>Посмотрите на инструкцию call. Если вы посмотрите в ISA, то увидете, что после такого opcode-а идёт адрес, в который следует прыгнуть. Но здесь записано число ноль, как временное значение, так как адреса метки exit мы пока не знаем.</p>

<p>Здесь идёт речь не об адресе в файле, а об адресе в оперативной памяти во время исполнения (возможно, относительно регистра <code>rip</code>, если код position independent). А проектировать то, как будет лежать программа в оперативной памяти, будет компоновщик с использованием linker script-а.</p>

<p>Посмотрим на структуру объектного файла.</p>

<pre><code class="language-no-highlight">$ readelf -a main.o
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          64 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           64 (bytes)
  Number of section headers:         8
  Section header string table index: 4

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .data             PROGBITS         0000000000000000  00000240
       000000000000000d  0000000000000000  WA       0     0     4
  [ 2] .bss              NOBITS           0000000000000000  00000250
       0000000000000010  0000000000000000  WA       0     0     4
  [ 3] .text             PROGBITS         0000000000000000  00000250
       0000000000000023  0000000000000000  AX       0     0     16
  [ 4] .shstrtab         STRTAB           0000000000000000  00000280
       0000000000000037  0000000000000000           0     0     1
  [ 5] .symtab           SYMTAB           0000000000000000  000002c0
       00000000000000f0  0000000000000018           6     8     8
  [ 6] .strtab           STRTAB           0000000000000000  000003b0
       000000000000002a  0000000000000000           0     0     1
  [ 7] .rela.text        RELA             0000000000000000  000003e0
       0000000000000048  0000000000000018           5     3     8
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

There are no section groups in this file.

There are no program headers in this file.

There is no dynamic section in this file.

Relocation section '.rela.text' at offset 0x3e0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000c  000200000001 R_X86_64_64       0000000000000000 .data + 0
000000000018  00020000000b R_X86_64_32S      0000000000000000 .data + 9
00000000001f  000800000002 R_X86_64_PC32     0000000000000000 exit - 4
No processor specific unwind information to decode

Symbol table '.symtab' contains 10 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.asm
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .data
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    2 .bss
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 .text
     5: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    1 buffer
     6: 0000000000000009     0 NOTYPE  LOCAL  DEFAULT    1 length
     7: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT    2 zeros
     8: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND exit
     9: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT    3 _start

No version information found in this file.</code></pre>

<p>Мы видим восемь секций: , <code>.data</code>, <code>.bss</code>, <code>.text</code>, <code>.shstrtab</code>, <code>.symtab</code>, <code>.strtab</code>, <code>.rela.text</code>.</p>

<p>В нашем файле на языке ассемблера мы написали только три секции: <code>.data</code>, <code>.bss</code> и <code>.text</code>. Также, мы часто сами пишем секцию <code>.rodata</code> (read-only data), которая во время исполнения будет неизменяемой. Обычно в неё попадают <code>const char*</code>.</p>

<p>Остальные секции являются вспомогательными и генерируются ассемблером. На секцию <code>.symtab</code> мы уже смотрели. Секции <code>.shstrtab</code> и <code>.strtab</code> в данном файле являются пустыми, и мы их разбирать не будем.</p>

<p>Посмотрим на таблицу внимательнее.</p>

<pre><code class="language-no-highlight">Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .data             PROGBITS         0000000000000000  00000240
       000000000000000d  0000000000000000  WA       0     0     4
...</code></pre>

<p>Поле Address получит смысл только после выполнения компоновки. Поле Offset — это позиция секции в самом файле. Например, позиция секции <code>.data</code> — <code>0x240</code> байт. Проверим это.</p>

<pre><code class="language-no-highlight">$ hd main.o
...
00000240  43 68 65 63 6b 2e 2e 2e  0a 09 00 00 00 00 00 00  |Check...........|
...</code></pre>

<p>Действительно, в этом месте начинается строка <code>Check...</code>.</p>

<p>Поле Flags хранит, помимо не особо интересных нам флагов, флаги прав (permissions). Например, мы видим, что секция <code>.data</code> имеет флаг <code>W</code>, что означает, что она writable (изменяемая).</p>

<p>Посмотрим на секцию <code>.rela.text</code>.</p>

<pre><code class="language-no-highlight">Relocation section '.rela.text' at offset 0x3e0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
00000000000c  000200000001 R_X86_64_64       0000000000000000 .data + 0
000000000018  00020000000b R_X86_64_32S      0000000000000000 .data + 9
00000000001f  000800000002 R_X86_64_PC32     0000000000000000 exit - 4</code></pre>

<p>Посмотрите на третью строку таблицы. В ней записана метка <code>exit</code>, и адрес <code>0x1f</code>. Посмотрите на инструкцию call:</p>

<pre><code class="language-no-highlight">...
  1e:	e8 00 00 00 00       	call   23 &lt;length+0x1a&gt;</code></pre>

<p><code>0x1f</code> — это как раз место, в которое следует положить адрес метки. Вот и вся цепочка действий для подстановки адресов.</p><h3 id="5.3.5">5.3.5. Анализ сегментов</h3><p>Добавим в нашу программу модуль с реализацией функции <code>exit</code>, скомпонуем их вместе и посмотрим на структуру полученного исполняемого файла.</p>

<p><code>exit.asm</code></p>

<pre><code class="language-no-highlight">global exit
exit:
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf64 exit.asm -o exit.o
$ ld exit.o -o exit
ld: warning: cannot find entry symbol _start; defaulting to 0000000000401000
$ ./exit
$ objdump -d exit

exit:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 &lt;exit&gt;:
  401000:	b8 3c 00 00 00       	mov    $0x3c,%eax
  401005:	bf 00 00 00 00       	mov    $0x0,%edi
  40100a:	0f 05                	syscall</code></pre>

<p>Если мы скомпонуем только этот файл, то компоновщик не найдет метку _start, и сделать entry point-ом начало секции (в данном случае, функцию exit).</p>

<pre><code class="language-no-highlight">$ ld main.o exit.o -o main
$ readelf -a main
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x401000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          8584 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         3
  Size of section headers:           64 (bytes)
  Number of section headers:         7
  Section header string table index: 6

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000401000  00001000
       000000000000003c  0000000000000000  AX       0     0     16
  [ 2] .data             PROGBITS         0000000000402000  00002000
       000000000000000d  0000000000000000  WA       0     0     4
  [ 3] .bss              NOBITS           0000000000402010  0000200d
       0000000000000010  0000000000000000  WA       0     0     4
  [ 4] .symtab           SYMTAB           0000000000000000  00002010
       0000000000000108  0000000000000018           5     6     8
  [ 5] .strtab           STRTAB           0000000000000000  00002118
       0000000000000044  0000000000000000           0     0     1
  [ 6] .shstrtab         STRTAB           0000000000000000  0000215c
       000000000000002c  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000000e8 0x00000000000000e8  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000000003c 0x000000000000003c  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000402000 0x0000000000402000
                 0x000000000000000d 0x0000000000000020  RW     0x1000

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .text 
   02     .data .bss 

There is no dynamic section in this file.

There are no relocations in this file.
No processor specific unwind information to decode

Symbol table '.symtab' contains 11 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.asm
     2: 0000000000402000     0 NOTYPE  LOCAL  DEFAULT    2 buffer
     3: 0000000000402009     0 NOTYPE  LOCAL  DEFAULT    2 length
     4: 0000000000402010     0 NOTYPE  LOCAL  DEFAULT    3 zeros
     5: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS exit.asm
     6: 0000000000401000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     7: 000000000040200d     0 NOTYPE  GLOBAL DEFAULT    3 __bss_start
     8: 000000000040200d     0 NOTYPE  GLOBAL DEFAULT    2 _edata
     9: 0000000000402020     0 NOTYPE  GLOBAL DEFAULT    3 _end
    10: 0000000000401030     0 NOTYPE  GLOBAL DEFAULT    1 exit

No version information found in this file.</code></pre>

<p>Начнём со списка секций. Здесь есть одно изменение: пропала секция <code>.rela.text</code>. Это логично, так как она уже была использована по назначению — для подстановки адресов меток.</p>

<p>Теперь посмотрите на эту таблицу:</p>

<pre><code class="language-no-highlight"> Section to Segment mapping:
  Segment Sections...
   00     
   01     .text 
   02     .data .bss </code></pre>

<p>Загрузчик, который будет создавать процесс, выполняющий нашу программу, будет загружать его по сегментам, а не секциям. Данная таблица говорит о наличии трёх сегментов:</p>

<ul>
	<li>Первый фиктивный</li>
	<li>Второй с секцией <code>.text</code></li>
	<li>Третий с секциями <code>.data</code> и <code>.bss</code></li>
</ul>

<p>В одном сегменте может быть несколько секций.</p>

<p>Посмотрите на поле Address у секций:</p>

<pre><code class="language-no-highlight">Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000401000  00001000
       000000000000003c  0000000000000000  AX       0     0     16
  [ 2] .data             PROGBITS         0000000000402000  00002000
       000000000000000d  0000000000000000  WA       0     0     4
  [ 3] .bss              NOBITS           0000000000402010  0000200d
       0000000000000010  0000000000000000  WA       0     0     4
...</code></pre>

<p>Ранее там были записаны нули. Теперь же там записаны числа, например, <code>0x401000</code> для секции <code>.text</code>, <code>0x402000</code> для секции <code>.data</code> и <code>0x402010</code> для секции <code>.bss</code>. Какое это влияние оказывает на загрузчик? На самом деле, никакое. Эти числа здесь только как подсказка о том, где в процессе исполнения будут находиться в памяти данные секции.</p>

<p>Запустим программу в дебаггере.</p>

<pre><code class="language-no-highlight">└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
│B+&gt; 0x401000 &lt;_start&gt;       mov    $0x1,%eax                                                           │
│    0x401005 &lt;_start+5&gt;     mov    $0x1,%edi                                                           │
│    0x40100a &lt;_start+10&gt;    movabs $0x402000,%rsi                                                      │
</code></pre>

<pre><code class="language-no-highlight">(gdb) x/8c 0x402000
0x402000:       67 'C'  104 'h' 101 'e' 99 'c'  107 'k' 46 '.'  46 '.'  46 '.'</code></pre>

<p>Действительно, выполнение начинается с адреса <code>0x401000</code>, а по адресу <code>0x402000</code> записана наша строка.</p>

<p>Посмотрим на сегменты. (Здесь program header = заголовки сегментов. Отличная терминология.)</p>

<pre><code class="language-no-highlight">Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000000e8 0x00000000000000e8  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000000003c 0x000000000000003c  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000402000 0x0000000000402000
                 0x000000000000000d 0x0000000000000020  RW     0x1000</code></pre>

<p>Начнём с поля Offset. Здесь снова речь о позиции в файле. Первый сегмент начинается с позиции <code>0x0</code> и по сути делает так, чтобы весь исполняемый файл был покрыт сегментами. Обратите внимание, что в секциях поле Offset тоже изменилось и теперь оно соответствует сегментам. В самом файле сегменты с секциями и сами секции не дублируются.</p>

<p>Теперь о поле VirtAddr. Именно на это поле смотрит загрузчик, когда определяет, где в памяти должен быть данный сегмент. Аналогичное поле в таблице сегментов совпадает с ним. Для сегмента <code>.bss</code> это значение сдвинуто на <code>0x10</code>. При этом, Offset сдвинут только на <code>0xd</code>, то есть, формат elf старается не хранить в себе лишние байты ради выравнивания во время исполнения.</p>

<p>Посмотрите на поле Flags, которое говорит о правах (permissions) для данных сегментов. Например, сегмент с секцией <code>.text</code> можно исполнять, но нельзя менять, а сегмент с секциями <code>.data</code> и <code>.bss</code> можно менять, но нельзя исполнять. При нарушении этого мы получим SIGSEGV.</p>

<p>Поле PhysAddr в современных ОС не используется.</p><h3 id="5.3.6">5.3.6. Задача: О Position Independent Code</h3><p>Выясните, по каком критерию выясняется, что программа является position independent, и как это влияет на адреса сегментов.</p><h3 id="5.3.7">5.3.7. Эксперименты с секциями</h3><p>Далее пойдёт обрывочная информация, так как нет полной и чёткой документации о том, как работает компоновщик, и я обнаруживал сюрпризы.</p>

<p>Попробуем изменить использовать нестандартное название секции.</p>

<p><code>main.asm</code></p>

<pre><code class="language-no-highlight">section .code
global _start
_start:
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall</code></pre>

<pre><code class="language-no-highlight">$ nasm -felf64 main.asm -o main.o
$ ld main.o -o main
$ ./main
Segmentation fault (core dumped)
$ readelf -a main
ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x401000
  Start of program headers:          64 (bytes into file)
  Start of section headers:          4328 (bytes into file)
  Flags:                             0x0
  Size of this header:               64 (bytes)
  Size of program headers:           56 (bytes)
  Number of program headers:         1
  Size of section headers:           64 (bytes)
  Number of section headers:         5
  Section header string table index: 4

Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .code             PROGBITS         0000000000401000  00001000
       000000000000000c  0000000000000000   A       0     0     1
  [ 2] .symtab           SYMTAB           0000000000000000  00001010
       0000000000000090  0000000000000018           3     2     8
  [ 3] .strtab           STRTAB           0000000000000000  000010a0
       0000000000000022  0000000000000000           0     0     1
  [ 4] .shstrtab         STRTAB           0000000000000000  000010c2
       0000000000000021  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x000000000000100c 0x000000000000100c  R      0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .code 

There is no dynamic section in this file.

There are no relocations in this file.
No processor specific unwind information to decode

Symbol table '.symtab' contains 6 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.asm
     2: 0000000000401000     0 NOTYPE  GLOBAL DEFAULT    1 _start
     3: 000000000040200c     0 NOTYPE  GLOBAL DEFAULT    1 __bss_start
     4: 000000000040200c     0 NOTYPE  GLOBAL DEFAULT    1 _edata
     5: 0000000000402010     0 NOTYPE  GLOBAL DEFAULT    1 _end

No version information found in this file.</code></pre>

<p>Наша программа получила SIGSEGV. Чтобы разобраться в причине, посмотрим на структуру исполняемого файла.</p>

<p>Компоновщик положил нашу секцию в первый сегмент, сдвинув её на <code>0x1000</code>. Размер MemSiz этого сегмента <code>0x100c</code>, то есть, его явно хватает для хранения секции <code>.code</code>. Убедимся в этом, воспользовавшись дебаггером.</p>

<pre><code class="language-no-highlight">└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
│  &gt; 0x401000        mov    $0x3c,%eax                                                                  │
│    0x401005        mov    $0x0,%edi                                                                   │
│    0x40100a        syscall                                                                            │
</code></pre>

<p>Ответ кроется в правах у сегмента: обратите внимание, что мы не можем его выполнять.</p>

<p>Поведение стандартного скрипта компоновки можно описать как "любые незнакомые секции класть в первый фиктивный сегмент".</p>

<p>(Здесь есть странное место, которое я не понял. Утверждается, что с помощью конструкции MEMORY в linker script-е можно изменить права сегмента. Однако в моём случае, хоть сегмент и получал нужный адрес, был по прежнему не executable.)</p>

<p>Эту проблему можно решить с помощью nasm-а. Дело в том, что в объектном файле секция <code>.code</code> тоже не является исполняемой.</p>

<pre><code class="language-no-highlight">$ readelf -a main.o
...
  [ 1] .code             PROGBITS         0000000000000000  00000180
       000000000000000c  0000000000000000   A       0     0     1
...</code></pre>

<p>Используем директиву <code>exec</code> в коде в объявлении секции.</p>

<pre><code class="language-no-highlight">section .code exec
global _start
_start:
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall</code></pre>

<p>Проверим права теперь.</p>

<pre><code>$ readelf -a main.o
...
  [ 1] .code             PROGBITS         0000000000000000  00000180
       000000000000000c  0000000000000000  AX       0     0     1
...
$ readelf -a main
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000400000 0x0000000000400000
                 0x00000000000000b0 0x00000000000000b0  R      0x1000
  LOAD           0x0000000000001000 0x0000000000401000 0x0000000000401000
                 0x000000000000000c 0x000000000000000c  R E    0x1000

 Section to Segment mapping:
  Segment Sections...
   00     
   01     .code 
...</code></pre>

<p>Обратите внимание: компоновщик не сделал первый сегмент исполняемым, а поместил секцию <code>.code</code> в отдельный сегмент.</p>

<pre><code class="language-no-highlight">$ ./main</code></pre>

<p>Программа успешно выполняется.</p><h3 id="5.3.8">5.3.8. Linker Scripts и секции</h3><p>Изучим linker script-ы. Начнём с изменения entry point-а и VirtAddr-а.</p>

<p><code>mymain.asm</code></p>

<pre><code class="language-no-highlight">section .code exec
global mymain
extern hismain
mymain:
    call    hismain
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall</code></pre>

<p><code>hismain.asm</code></p>

<pre><code class="language-no-highlight">section .code exec
global hismain
hismain:
    mov     rax, 0x0
    ret</code></pre>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(mymain)

SECTIONS {
    . = 0x100000;
    .code : {
        *(.code)
    }
}</code></pre>

<p><code>ENTRY(mymain)</code> говорит о том, что entry point-ом будет метка <code>mymain</code>.</p>

<p>Конструкция <code>SECTIONS</code> объединяет секции (пока что в большие секции, а не сегменты) и распологает их в определённом порядке во время исполнения программы, и в том же порядке в самом файле.</p>

<p>Первая строка <code>. = 0x100000</code> говорит о том, что следующая секция будут располагаться по адресу <code>0x100000</code>, а следующие за ней — ещё дальше.</p>

<p>Строка <code>.code : { *(.code) }</code> говорит следующее: необходимо взять со всех поданных на вход файлов (<code>*</code>) секцию <code>.code</code> и объединить их в одну секцию под названием <code>.code</code> (справа в конструкции — название выходной секции).</p>

<pre><code class="language-no-highlight">$ nasm -felf64 mymain.asm -o mymain.o
$ nasm -felf64 hismain.asm -o hismain.o
$ ld mymain.o hismain.o -o main -T script.ld
$ ./main
$ readelf -a main
...
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .code             PROGBITS         0000000000100000  00001000
       0000000000000017  0000000000000000  AX       0     0     1
  [ 2] .symtab           SYMTAB           0000000000000000  00001018
       0000000000000078  0000000000000018           3     3     8
  [ 3] .strtab           STRTAB           0000000000000000  00001090
       0000000000000027  0000000000000000           0     0     1
  [ 4] .shstrtab         STRTAB           0000000000000000  000010b7
       0000000000000021  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000001000 0x0000000000100000 0x0000000000100000
                 0x0000000000000017 0x0000000000000017  R E    0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .code 
...</code></pre>

<p>Обратите внимание на то, что у единственного сегмента VirtAddr теперь равен <code>0x100000</code>, а Offset теперь не <code>0x0</code> (то есть теперь таблицы, которые мы сейчас видим, не будут загружены в память при запуске программы (это нужно регулировать отдельно)).</p>

<p>Мы можем включать в выходной файл секции их стандартных файлов (например, файлов стандартной библиотеки).</p>

<p><code>stdlib.asm</code></p>

<pre><code class="language-no-highlight">section .code exec
global sqrt
sqrt:
    mov     rax, 0x42
    ret</code></pre>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(mymain)

SECTIONS {
    . = 0x100000;
    .stdlib : {
        stdlib.o(.code)
    }
    .code : {
        *(.code)
    }
}</code></pre>

<p>Мы образовали ещё одну секцию <code>.stdlib</code> из секции <code>.code</code> в файле <code>stdlib.o</code>. Обратите внимание, что теперь секция <code>.code</code> в файле <code>stdlib.o</code> не попадет в выходную секцию <code>.code</code>. При этом, если мы поменяем порядок объявления выходных секций <code>.stdlib</code> и <code>.code</code>, то секция <code>.code</code> в файле <code>stdlib.o</code> попадёт в выходную секцию <code>.code</code>, а секция <code>.stdlib</code> будет выброшена, так как в неё не попало ничего.</p>

<pre><code class="language-no-highlight">$ nasm -felf64 stdlib.asm -o stdlib.o
$ ld mymain.o hismain.o -o main -T script.ld
$ ./main
$ readelf -a main
...
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .stdlib           PROGBITS         0000000000100000  00001000
       0000000000000006  0000000000000000  AX       0     0     1
  [ 2] .code             PROGBITS         0000000000100006  00001006
       0000000000000017  0000000000000000  AX       0     0     1
  [ 3] .symtab           SYMTAB           0000000000000000  00001020
       00000000000000a8  0000000000000018           4     4     8
  [ 4] .strtab           STRTAB           0000000000000000  000010c8
       0000000000000037  0000000000000000           0     0     1
  [ 5] .shstrtab         STRTAB           0000000000000000  000010ff
       0000000000000029  0000000000000000           0     0     1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),
  L (link order), O (extra OS processing required), G (group), T (TLS),
  C (compressed), x (unknown), o (OS specific), E (exclude),
  D (mbind), l (large), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000001000 0x0000000000100000 0x0000000000100000
                 0x000000000000001d 0x000000000000001d  R E    0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .stdlib .code 
...</code></pre>

<p>Обратите внимание, что обе секции попали в первый сегмент. Как управлять сегментами, мы увидим чуть позже.</p><h3 id="5.3.9">5.3.9. Linker Scripts и сегменты</h3><p>Посмотрим более сложные случаи организации секций и сегментов. Здесь я снова обнаруживал странное и неочевидное поведение компоновщика.</p>

<p><code>mymain.asm</code></p>

<pre><code class="language-no-highlight">section .code exec
global mymain
extern hismain
mymain:
    call    hismain
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall

section .foo
foo:
    db      0x1, 0x2</code></pre>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(mymain)

SECTIONS {
    . = 0x100000;
    .stdlib : {
        stdlib.o(.code)
    }
    .code : {
        *(.code)
    }
    .foo : {
        *(.foo)
    }
}</code></pre>

<p>Представим, что мы хотим дополнительно иметь секцию только с правами на чтение. Оставим всё остальное, как было на прошлом шаге.</p>

<pre><code class="language-no-highlight">$ readelf -a main
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000001000 0x0000000000100000 0x0000000000100000
                 0x000000000000001f 0x000000000000001f  R E    0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .stdlib .code .foo 
...</code></pre>

<p>Наша секция <code>.foo</code> является executable так как компоновщик положил её в один сегмент с остальными! (Проверьте с помощью дебаггера, что вы действительно можете выполнять код в этой секции. Для этого, напишите в неё инструкции.)</p>

<p>Попробуем сделать секцию <code>.foo</code> writable.</p>

<pre><code class="language-no-highlight">section .code exec
global mymain
extern hismain
mymain:
    call    hismain
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall

section .foo write
foo:
    db      0x1, 0x2</code></pre>

<pre><code class="language-no-highlight">$ readelf -a main
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000001000 0x0000000000100000 0x0000000000100000
                 0x000000000000001f 0x000000000000001f  RWE    0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .stdlib .code .foo 
...</code></pre>

<p>Теперь секция с кодом тоже стала writable (что неприемлемо). То есть, компоновщик ставит в права сегмента объединение прав всех составляющих его секций.</p>

<p>Я не смог найти информацию о конструкциях, явно указывающих распределение секций по сегментам. Вместо этого мы делаем это так.</p>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(mymain)

SECTIONS {
    . = 0x100000;
    .stdlib : {
        stdlib.o(.code)
    }
    .code : {
        *(.code)
    }
    . = 0x200000;
    .foo : {
        *(.foo)
    }
}</code></pre>

<p>Мы снова явно установили значение VirtAddr на большую величину.</p>

<pre><code class="language-no-highlight">$ readelf -a main
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000001000 0x0000000000100000 0x0000000000100000
                 0x000000000000001d 0x000000000000001d  R E    0x1000
  LOAD           0x0000000000002000 0x0000000000200000 0x0000000000200000
                 0x0000000000000002 0x0000000000000002  RW     0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .stdlib .code 
   01     .foo 
...</code></pre>

<p>Теперь у нас две сегмента с правильным распределением секций в них, правильными значениями VirtAddr и правильными правами.</p>

<p>Обратите внимание на эти конструкции: <code>. = 0x100000;</code>. Мы можем этим адресам давать имена, а затем использовать эти метки в коде — компоновщик подставит их значения. Кроме того, мы можем давать имена не только адресам, которые мы написали явно, но и тем, которые вывел компоновщик — например, адресу начала секции <code>.code</code>, которая попадает второй секцией к первому сегменту.</p>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(mymain)

SECTIONS {
    . = 0x100000;
    .stdlib : {
        stdlib.o(.code)
    }
    code_begin = .;
    .code : {
        *(.code)
    }
    foo_begin = 0x200000;
    .foo : {
        *(.foo)
    }
}</code></pre>

<p>Мы создали две метки: <code>code_begin</code> хранит адрес начала секции <code>.code</code>, а <code>foo_begin</code> хранит адрес начала секции <code>.foo</code>. Мы можем использовать это как обычные метки, определённые в других модулях.</p>

<p><code>mymain.asm</code></p>

<pre><code class="language-no-highlight">section .code exec
global mymain
extern hismain
extern code_begin
extern foo_begin
mymain:
    mov     rax, code_begin
    mov     rbx, foo_begin
    call    hismain
    mov     rax, 0x3C
    mov     rdi, 0x0
    syscall

section .foo write
foo:
    db      0x1, 0x2</code></pre>

<pre><code class="language-no-highlight">└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
│B+&gt; 0x100006 &lt;mymain&gt;       movabs $0x100006,%rax                                                      │
│    0x100010 &lt;mymain+10&gt;    movabs $0x200000,%rbx                                                      │</code></pre><h3 id="5.3.10">5.3.10. Задача: Написать Linker Script</h3><p>Напишите программу и linker script к ней, которые поддерживают другие секции (<code>.data</code>, <code>.bss</code>, <code>.rodata</code>), выставляя им правильные права. При этом эти секции переименованы (например, <code>.bss</code> -&gt; <code>.uninit</code>).</p><h3 id="5.3.11">5.3.11. Задача: Языки ассемблеров других архитектур</h3><p>Проверим тезис о том, что после изучения ассемблера одной архитектуры, ассемблеры других архитектур изучаются легко и быстро (речь, конечно, идёт о прикладном уровне).</p>

<p>Вы можете компилировать код на другие архитектуры локально. Причём легко — zig с этим отлично справляется.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">int boo(int x, int y) {
    return x * y;
}

int foo(int x, int y) {
    int a = x + y;
    int b = x - y;
    return boo(a, b);
}

int main() {
    int x = 2;
    int y = 3;
    int z = foo(x, y);
}</code></pre>

<pre><code class="language-no-highlight">$ zig build-obj -target arm-linux main.c
$ arm-linux-gnueabihf-objdump -d main</code></pre>

<p>Так вы можете выполнить компиляцию на arm, а затем дизассемблировать и посмотреть инструкции. К сожалению, запуск хоть и возможен (например, с помощью эмулятора qemu), весьма непрост.</p>

<p>Изучите регистры, формат инструкций и протокол вызова функций в архитектурах arm и risc-v.</p>

<p>Альтернативно вы можете воспользоваться <a href="https://godbolt.org/" rel="noopener noreferrer nofollow">https://godbolt.org/</a></p><h3 id="5.4">5.4. Введение в Embedded Programming</h3><h3 id="5.4.1">5.4.1. О написании операционных систем</h3><p>Здесь мы научимся писать программы, выполняющиеся непосредственно на процессоре, и тривиальные операционные системы. Главным источником информации будет данный сайт: <a href="https://wiki.osdev.org" rel="noopener noreferrer nofollow">https://wiki.osdev.org</a> . Изученной нами на протяжении данного курса информации должно быть достаточно, чтобы понимать tutorial-ы с уровнем "beginner". Мы будем использовать эмулятор <code>qemu</code> для запуска и отладки нашей ОС.</p>

<p>Представим, что мы хотим запустить написанную нами на языке ассемблера и C программу непосредственно на процессоре, без поддержки существующей операционной системы. Для начала нужно понять, а что делает компьютер в самом начале, ведь, очевидно, он не съинтерпретирует диск как файловую систему, не найдет там наш elf-файл (а почему именно elf, а не PE?), не поймет, что это elf-файл, не выполнит его загрузку в процесс, не прикомпонует его к shared objects. В общем, проблем намного больше, чем может показаться на первый взгляд.</p>

<p>Итак, компьютер (не процессор) делает следующее: берёт первый сектор (512 байт) данных с диска (при этом, последние два байта должны быть <code>0x55</code> и <code>0xAA</code>), загружает их в адрес <code>0x7C00</code> и прыгает в этот адрес. Это означает, что в первом секторе диска у нас должен быть некий код, который считает файловую систему, найдёт исполняемый файл ядра и загрузит его. Уложить это в 512 байт не получится, поэтому обычно эта логика пишется в нескольких первых секторах, а первый сектор загружает их втупую (не интерпретируя, как файловую систему) и прыгает в них.</p>

<p>Есть хорошая новость: драйвер для файловой системы мы писать здесь не будем. Мы воспользуемся загрузчиком <code>grub</code> (который вы скорее всего используете для запуска своей ОС). Есть и альтернативные загрузчики, например, <code>limine</code> и <code>lilo</code>.</p>

<p>Использование grub-а довольно простое.</p>

<ol>
	<li>Мы скомпилируем ядро в обычный 32-bit elf-файл.</li>
	<li>Мы создадим директорию и положим в неё файлы так, как мы хотим, чтобы они распологались на загрузочном диске.</li>
	<li>Мы создадим конфигурационный файл для grub-а в этой директории в <code>/boot/grub</code> и запишем в нём путь до нашего elf-файла.</li>
	<li>Мы воспользуемся утилитой <code>grub-mkrescue</code>, который создаст загрузочный диск по такому же принципу, по какому мы это делали с помощью монтирования и loop devices.</li>
</ol><h3 id="5.4.2">5.4.2. Простейшее ядро, запускающееся grub-ом, и демонстрирующее VESA</h3><p>Я сразу покажу все файлы, а затем мы выполним анализ этого.</p>

<p><code>src/boot.asm</code></p>

<pre><code class="language-no-highlight">%define FLAGS 0x3
%define MAGIC 0x1BADB002
%define CHECKSUM -(MAGIC + FLAGS)

section .multiboot
    align   0x4
    dd      MAGIC
    dd      FLAGS
    dd      CHECKSUM

section .text
global _start
_start:
    lea     edi, 0xB8000
    mov     byte [edi + 0], 'H'
    mov     byte [edi + 2], 'e'
    mov     byte [edi + 4], 'l'
    mov     byte [edi + 6], 'l'
    mov     byte [edi + 8], 'o'

    cli
.1: hlt
    jmp .1</code></pre>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(_start)

SECTIONS {
	. = 0x200000;
	.text : ALIGN(0x1000) {
		*(.multiboot)
		*(.text)
	}
}</code></pre>

<p><code>grub.cfg</code></p>

<pre><code class="language-no-highlight">menuentry "Rach" {
	multiboot /boot/kernel
}</code></pre>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">BUILD_DIR=$(abspath build)

SRCS_ASM=$(wildcard src/*.asm)
OBJS_ASM=$(patsubst src/%.asm, $(BUILD_DIR)/%.o, $(SRCS_ASM))

ASFLAGS=-felf32
LDFLAGS=-T script.ld -m elf_i386

$(BUILD_DIR)/%.o: src/%.asm prepare
	nasm $(ASFLAGS) $&lt; -o $@

kernel: $(OBJS_ASM) $(OBJS_C)
	ld $(LDFLAGS) $(OBJS_ASM) $(OBJS_C) -o $(BUILD_DIR)/kernel

image: kernel
	mkdir -p isodir/boot/grub
	cp $(BUILD_DIR)/kernel isodir/boot/kernel
	cp grub.cfg isodir/boot/grub/grub.cfg
	grub-mkrescue -o $(BUILD_DIR)/kernel.iso isodir
	rm -rf isodir

qemu: image
	qemu-system-i386 -cdrom $(BUILD_DIR)/kernel.iso

prepare:
	mkdir -p $(BUILD_DIR)

clean:
	rm -rf $(BUILD_DIR)</code></pre>

<p>Для запуска этого вам необходимо поставить в систему:</p>

<ul>
	<li>grub</li>
	<li>xorriso</li>
	<li>mtools</li>
	<li>qemu</li>
	<li>zig</li>
</ul>

<p>Начнём с файла <code>src/boot.asm</code></p>

<p>Данный файл начинается с секции, которая хранит только последовательность чисел, по которой grub увидит этот файл. (Зачем это нужно, ведь полученный диск является обычным диском, partition-ы которого имеют обычные файловые системы (можете потом это проверить), и grub может просто найти наш elf-файл по заданному в конфигурационном файле пути? Полагаю, чтобы grub мог загружать ядро и из неизвестной ему файловой системы.)</p>

<p>В самой программе я записываю простым способом строку в адрес <code>0xB8000</code> с шагом в <code>2</code> байта. Это выглядит как что-то бессмысленное, но это не так. По умолчанию BIOS устанавливает монитор в специальный режим терминала (ищите по запросу VESA), при котором всё, что вы будете писать в адрес <code>0xB8000</code> будет дублироваться на мониторе. При этом, каждый чётный байт обозначает символ, а каждый нечётный байт — цвет этого символа. Я это сделал, чтобы наша ОС показала хоть какие-то признаки жизни.</p>

<p>Инструкция <code>cli</code>, грубо говоря, ставит на паузу анализ прерываний (interrupts), приходящих от оборудования. Когда какое-то оборудование хочет нам что-то сказать, оно "пингует" нас прерыванием. При этом, само прерывание не несёт в себе информации — получив его, мы просто вступаем в "диалог" с оборудованием. BIOS автоматически настраивает некие прерывания (я не знаю, перезаписывает ли их grub).</p>

<p>Инструкция <code>hlt</code> останавливает процессор. Однако, если придет прерывание от оборудования, то после его обработки, процессор продолжит своё выполнение. Поэтому мы и используем инструкцию cli. (Про jmp на hlt мне мало известно. Говорят, что процессор всё равно может возобновить работу, поэтому мы и добавляем этот прыжок.)</p>

<p>Linker script <code>script.ld</code>, полагаю, должен быть почти очевиден. Мы добавили сдвиг на <code>0x200000</code>, так как на меньших адресах grub хранит свою информацию. Аттрибут <code>ALIGN</code> выравнивает секцию на соответствующую величину.</p>

<p>Конфигурационный файл для grub-а <code>grub.cfg</code> содержит лишь путь до нашего исполняемого файла.</p>

<p>Посмотрим на файл <code>Makefile</code>. Мы добавляем компоновщику флаг <code>-m elf_i386</code>, чтобы выполнить компоновку в elf 32-bit. (По какой-то причине компоновщик у меня игнорировал OUTPUT_FORMAT в linker script-е.) После компиляции мы кладём исполняемый файл и конфигурационный файл grub-а в отдельную директорию и вызываем grub-mkrescue, который создаёт загрузочный диск. Наконец, мы запускаем виртуальную машину qemu, передав ей загрузочный диск в cd-rom.</p>

<p>Выполните <code>make qemu</code>. qemu запустится в обычном окне. Вы на долю секунды увидете текст от BIOS-а в qemu, затем появится grub, который предложит вам выбрать ОС для загрузки из списка, в котором будет только одна ОС. После загрузки ОС вы увидете текст <code>Hello</code> и мигающий курсор на первом символе (как поменять его позицию, можете почитать самостоятельно).</p><h3 id="5.4.3">5.4.3. Задача: Конфигурация grub-а с несколькими ядрами</h3><p>Установить на один установочный диск несколько ОС так, чтобы с помощью grub-а можно было выбирать, какую запустить.</p><h3 id="5.4.4">5.4.4. Отладка с gdb. Немного о Real Mode и Protected Mode</h3><p>Мы можем выполнять отладку нашей ОС с помощью gdb. Добавим дополнительный рецепт в Makefile.</p>

<pre><code class="language-no-highlight">...
debug: image
	qemu-system-i386 -cdrom $(BUILD_DIR)/kernel.iso -gdb tcp::1234 -S
...</code></pre>

<p>Теперь мы можем подключиться к Qemu по порту <code>1234</code>. Для этого добавим дополнительные команды в <code>.gdbinit</code>.</p>

<pre><code class="language-no-highlight">layout asm
layout regs
set disassembly-flavor intel
target remote localhost:1234
symbol-file build/kernel
b _start
c</code></pre>

<p>Команда <code>set disassembly-flavor intel</code> меняет синтакис кода в gdb на intel.</p>

<p>Команда <code>target remote localhost:1234</code> подключает gdb к Qemu на порту <code>1234</code>.</p>

<p>Команда <code>symbol-file build/kernel</code> говорит gdb использовать символы из данного исполняемого файла. В противном случае gdb, например, не будет знать, что <code>0x200000</code> это именно секция <code>.multiboot</code>, и где находится метка <code>_start</code>.</p>

<p>Выполните <code>make debug</code> и в отдельном терминале <code>gdb</code>. Пройдите этап с grub-ом, и Qemu остановится на метке <code>_start</code>.</p>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│eax            0x2badb002          732803074                                                           │
│ecx            0x0                 0                                                                   │
│edx            0x0                 0                                                                   │
│ebx            0x10000             65536                                                               │
│esp            0x7ff00             0x7ff00                                                             │
│ebp            0x0                 0x0                                                                 │
│esi            0x0                 0                                                                   │
│edi            0x0                 0                                                                   │
│eip            0x200010            0x200010 &lt;_start&gt;                                                   │
│eflags         0x46                [ IOPL=0 ZF PF ]                                                    │
│cs             0x10                16                                                                  │
│ss             0x18                24                                                                  │
│ds             0x18                24                                                                  │
│es             0x18                24                                                                  │
│fs             0x18                24                                                                  │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
│B+&gt; 0x200010 &lt;_start&gt;       lea    edi,ds:0xb8000                                                      │
│    0x200016 &lt;_start+6&gt;     mov    BYTE PTR [edi],0x48                                                 │
│    0x200019 &lt;_start+9&gt;     mov    BYTE PTR [edi+0x2],0x65                                             │
│    0x20001d &lt;_start+13&gt;    mov    BYTE PTR [edi+0x4],0x6c                                             │
│    0x200021 &lt;_start+17&gt;    mov    BYTE PTR [edi+0x6],0x6c                                             │
│    0x200025 &lt;_start+21&gt;    mov    BYTE PTR [edi+0x8],0x6f                                             │
│    0x200029 &lt;_start+25&gt;    cli                                                                        │
│    0x20002a &lt;_start.1&gt;     hlt                                                                        │
│    0x20002b &lt;_start.1+1&gt;   jmp    0x20002a &lt;_start.1&gt;                                                 │
│    0x20002d                add    BYTE PTR [eax],al                                                   │
│    0x20002f                add    al,dl                                                               │
│    0x200031                add    BYTE PTR [eax],dl                                                   │
│    0x200033                add    BYTE PTR [esp+ebx*1],dl                                             │
│    0x200036                jl     0x200038                                                            │
│    0x200038                or     BYTE PTR [eax],ch                                                   │
│    0x20003a                cmp    al,0x2d                                                             │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘</code></pre>

<p>Секция <code>.text</code> действительно находится в <code>0x200010</code>. Выполните инструкцию за инструкцией и посмотрите, как буквы по одной появляются на виртуальной машине.</p>

<p>Пора раскрыть информацию о сегментных регистрах. Обратите внимание на последние шесть регистров в списке (в моём случае, чтобы увидеть шестой, нужно прокрутить вниз): <code>cs</code>, <code>ss</code>, <code>ds</code>, <code>es</code>, <code>fs</code>, <code>gs</code>. Это сегментные регистры и в зависимости от состояния процессора они выполняют одну из двух ролей.</p>

<p>Сразу при запуске процессор находится <code>real mode</code> (реальном режиме). В таком режиме может исполняться только 16-bit код (то есть, мы явно не в этом режиме), а сегментные регистры используются для следующей цели. Так как мы работаем в 16-bit, у нас есть только 16-bit регистры. Это означает, что числом в регистре мы можем кодировать только число до <code>1 &lt;&lt; 16</code>.</p>

<p>Чтобы немного повысить диапазон чисел, которые можно кодировать, для каждой инструкции, использующей обычный регистр, выбрали один из шести сегментных регистров (причём, не всегда очевидным образом). Пусть в инструкции <code>MOV</code> выбран сегментный регистр <code>B</code>. Тогда <code>MOV [A], 0x1</code> выполнит перемещение в адрес <code>A + (B &lt;&lt; 4)</code>. Такой адрес записывают как <code>B:A</code>. (Совсем так же, как записывают, что результат инструкции <code>mul</code> помещается в <code>rdx:rax</code>, хотя это абсолютно разные вещи.)</p>

<p>Идея такого следующая. Обычно, когда мы выполняем какую-то подпрограмму, мы работает с небольшим отрезком памяти. Это означает, что мы можем сразу установить необходимые регистры и при выполнения этой подпрограммы их не трогать. После завершения мы сменим сегментные регистры, чтобы работать с другим отрезком памяти.</p>

<p>На практике же, в добавок к тому, что написание кода на ассемблере сложное, манипуляции с сегментами делают этот процесс ещё больнее. Обычно в обучениях написанию ОС вы будете видеть, что в них просто сразу записывают нули и больше их никогда не трогают.</p>

<p>Существует также <code>protected mode</code> (защищённый режим) работы процессора. Все ОС стараются немедленно в него перейти. (Правда, это ломает вспомогательные функции BIOS-а. Чтобы ими пользоваться, можно временно переключаться на real mode (для чего мы будем иметь чередующиеся куски кода на 16-bit и 32-bit, что также неприятно контролировать).) GRUB уже перешёл для нас в protected mode. О нём мы узнаем подробнее чуть позже.</p><h3 id="5.4.5">5.4.5. Использование языка C</h3><p>Писать программы на ассемблере очень сложно. Как и в случае с языком C, мы хотим как можно скорее перейти на более высокоуровневый язык программирования. Перейти к C на самом деле довольно просто. Однако обычным gcc пользоваться очень сложно, так как он то и дело использует оптимизации, которые непросто поддерживать: shared objects и секцию <code>.rela.dyn</code>, position independent code и секцию <code>.got</code>, stdlib, даже если есть флаг на неиспользование её, и т. д.</p>

<p>Чтобы эффективно отключить всё это, следует скомпилировать себе gcc со специальными <code>freestanding</code> настройками. Здесь указано, как это сделать: <a href="https://wiki.osdev.org/GCC_Cross-Compiler" rel="noopener noreferrer nofollow">https://wiki.osdev.org/GCC_Cross-Compiler</a> . Однако, я решил пойти немного другим путём, так как компиляция компилятора — довольно затратное действие (на слабой машине процесс компиляции будет длиться несколько часов). Мы воспользуемся компилятором <code>zig</code>, так как он отлично поддерживает freestanding-компиляцию. Позволю вам прикоснуться к прекрасному.</p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">...
SRCS_C=$(wildcard src/*.c)
OBJS_C=$(patsubst src/%.c, $(BUILD_DIR)/%.o, $(SRCS_C))
...
ZIGFLAGS=-target x86-freestanding
...
$(BUILD_DIR)/%.o: src/%.c prepare
	zig build-obj $(ZIGFLAGS) $&lt; -femit-bin=$@
...</code></pre>

<p>Мы передаём zig-у флаг <code>-target x86-freestanding</code>. Я не буду здесь это показывать, можете проверить самостоятельно, что структура исполняемого файла корректная.</p>

<p><code>kernel.c</code></p>

<pre><code class="language-cpp">void kernel_main() {
    char *ptr = (char*)0xB8000;
    char str[6] = "Hello";
    int i;
    for (i = 0; i &lt; 5; i++) {
        ptr[i * 2] = str[i];
    }
}</code></pre>

<p>Сделаем то же самое, что и в коде на языке ассемблера в прошлый раз. Здесь нам нужно подумать внимательно: а не пользуемся ли мы неправильными секциями? Мы создали локальный массив. Где он хранится? На стеке, как и адрес возврата для фукнции <code>kernel_main</code>. А где стек? Наверное, grub нам его создал, но чёткого ответа на то, где он, нет. Тогда создадим стек сами.</p>

<p>Мы поместим стек в секцию <code>.bss</code>. (Кстати, а если объявить строку как <code>const char*</code>, то в какой секции она будет?)</p>

<p><code>boot.asm</code></p>

<pre><code class="language-no-highlight">...
section .bss
    align   0x10
stack_bottom:
    resb    16384
stack_top:

section .text
extern kernel_main
global _start
_start:
    lea     esp, stack_top
    call    kernel_main

    cli
.1: hlt
    jmp .1</code></pre>

<p>Мы создали секцию <code>.bss</code>, в которой объявили последовательность, размера <code>16384</code>. (Число взято с неба. Но имейте ввиду: если вы переполните стек, понять это при отладке может быть очень непросто.) Напомню, что стек растет в сторону уменьшения адреса.</p>

<p>Далее мы устанавливаем значение регистра <code>esp</code> на вершину нашего стека и вызываем функцию, определённую на языке C.</p>

<p><code>script.ld</code></p>

<pre><code class="language-no-highlight">ENTRY(_start)

SECTIONS {
	. = 0x200000;
	.text : ALIGN(0x1000) {
		*(.multiboot)
		*(.text)
	}
	.bss : ALIGN(0x1000) {
		*(.bss)
	}
}</code></pre>

<p>Нам нужно добавить секцию <code>.bss</code>. Здесь есть очередная странность в логике работы компоновщика: секция <code>.bss</code> попадает в отдельный сегмент только из-за того, что мы добавили аттрибут <code>ALING</code>.</p>

<p>При запуске этой ОС вы снова увидете строку <code>Hello</code>.</p><h3 id="5.4.6">5.4.6. Задача: Функции вывода текста</h3><p>Реализуйте удобные функции для вывода текста на экран, в том числе, <code>printf</code> (естественно, не имеющий отношения к stream-ам).</p><h3 id="5.4.7">5.4.7. Настройка прерываний Interrupts 1</h3><p>Последнее, что мы здесь сделаем, это настроим прерывания (interrupts) и таблицу дескрипторов прерываний (interrupt descriptor table/IDT).</p>

<p>Прерывания приходят из трёх источников:</p>

<ul>
	<li>Ошибочное состояние процессора (обычно, это называют exceptions). Например, eip указывает на некорректную инструкцию, или мы выполнили деление на ноль, или мы пытаемся загрузить в сегментный регистр другой сегмент, который не соответствует правам.</li>
	<li>Прерывание от другого устройства. В этом случае устройство лишь говорит нам о желании "поговорить", а сам разговор выполняется инструкциями <code>in</code> и <code>out</code>. Писать драйверы для устройств сложно (хотя, для PS/2 клавиатуры не слишком сложно), поэтому мы это здесь делать не будем.</li>
	<li>Выполнение инструкции <code>int</code> (обычно, это называют software interrupts). Мы уже выполняли эту инструкцию, когда писали программы на Linux-е. Мы использовали эту инструкцию, как вызов функции, которая сделает то, что мы не имеем права сделать. При использовании этой инструкции на время текущие права меняются на полные, чтобы ОС могла выполнить запрошенную операцию. Это похоже на <code>setuid</code> флаг у программ, который может включить только владелец файла. При запуске таких программ на время их выполнения текущим пользователем становится их владелец.</li>
</ul>

<p>Прерывание характеризуется номером, значение которого от <code>0</code> до <code>255</code>. Также некоторые exceptions имеют код ошибки.</p>

<p>Чтобы настроить прерывания, нам необходимо иметь следующие структуры:</p>

<ul>
	<li>Массив размера <code>256</code>, состоящий из entries — указателей на функции и некоторых флагов. При возникновении прерывания с номером <code>x</code> будет "вызвана" функция по указателю в ячейке <code>x</code>.</li>
	<li>Записанные подряд размер массива в байтах минус один в 16-битном типе и адрес начала массива. Адрес этой структуры мы запишем в регистр таблицы прерывание.</li>
</ul>

<p>По-хорошему, нужно вдумчиво подходить к месту размещения этих двух структур. Но мы просто объявим их глобально в коде, из-за чего компилятор их поместит в секцию <code>.bss</code>. Обычно же таблица прерываний находится в очень маленьких адресах.</p>

<p><code>idt.h</code></p>

<pre><code class="language-cpp">struct _idt_entry_t {
    uint16_t base_low;
    uint16_t selector;
    uint8_t  always0;
    uint8_t  flags;
    uint16_t base_high;
} __attribute__((packed));
typedef struct _idt_entry_t idt_entry_t;

struct _idt_table_t {
    uint16_t limit;
    uint32_t base;
} __attribute__((packed));
typedef struct _idt_table_t idt_table_t;

#define N_IDT_ENTRY 256
idt_entry_t idt_entries[N_IDT_ENTRY];
idt_table_t idt_table;

void idt_flush(idt_table_t*);
void handler0();
void handler13();

void idt_set_entry(uint8_t id, uint32_t base, uint16_t selector, uint8_t flags) {
    idt_entries[id].base_low    = base &amp; 0xFFFF;
    idt_entries[id].base_high   = (base &gt;&gt; 16) &amp; 0xFFFF;

    idt_entries[id].selector    = selector;
    idt_entries[id].always0     = 0;
    idt_entries[id].flags       = flags;
}

void idt_init() {
    idt_table.limit = sizeof(idt_entry_t) * N_IDT_ENTRY - 1;
    idt_table.base = (uint32_t)&amp;idt_entries;

    memset(&amp;idt_entries, 0, sizeof(idt_entry_t) * N_IDT_ENTRY);
    idt_set_entry(0, (uint32_t)handler0, 0x10, 0x8E);
    idt_set_entry(13, (uint32_t)handler13, 0x10, 0x8E);
    idt_flush(&amp;idt_table);
}</code></pre>

<p>Итак, первыми объявляются две вышеупомянутые структуры <code>idt_entry_t</code> и <code>idt_table_t</code> и их объекты на стеке: массив <code>idt_entries</code> и одиночный объект <code>idt_table</code>. Обратите внимание, что указатель на функцию в структуре <code>idt_entry_t</code> разделён на два отрезка, которые названы <code>base_low</code> и  <code>base_high</code>. О том, что это за флаги записаны в entries, можете не задумываться.</p>

<p>А вот о поле selector можно задуматься. Это номер сегмента (или селектора), который будет автоматически выбран при возникновении прерывания. Это необходимо для временного повышения прав.</p>

<p>Ещё до установки прерываний нам необходимо настроить глобальную таблицу дескрипторов (global descriptor table/GDT). Однако, grub уже сделал это за нас. Посмотрите ещё раз на сегментные регистры в дебаггере: grub использует в качестве сегмента кода <code>0x10</code>, в качестве сегмента данных <code>0x18</code>. Мы не будем настраивать свою GDT, а воспользуемся трудами grub-а. Нам необходимо в качестве селектора передать сегмент кода <code>0x10</code>.</p>

<p>Сегменты задают уровни прав (на самом деле, когда-то они задавали и сегменты памяти, к которым мы можем обращаться, но так теперь их использовать сложно). Когда мы выполняем код пользовательской программы, должен быть выбран сегмент с низкими правами (которые, в том числе, не позволяют выбрать сегмент с полными правами). При обработке прерывания автоматически будет выбираться тот сегмент, который записан в поле selector в нашей структуре.</p>

<p>На самом деле, речь о user mode может быть достаточно длинной, так как там, помимо сегментов с правами, есть ещё страницы и процессы (tasks). Мы не будем здесь это затрагивать и ограничимся прерываниями.</p>

<p>Функции <code>handlerX</code> — это функции-обработчики, которые будут вызываться при возникновении прерываний. Мы вынуждены реализовать их на языке ассемблера, так как возвращаться из них нужно не так, как из обычных функций. Функция <code>idt_flush</code> также требует использования инструкций, которые нельзя получить на языке C. Я решил для демонстрации реализовать обработчики только для прерываний с номерами <code>0</code> и <code>13</code>.</p>

<p>Здесь используется функция <code>memset</code>. Напишите её самостоятельно.</p><h3 id="5.4.8">5.4.8. Настройка прерываний Interrupts 2, исключения Exceptions</h3><p><code>idt.asm</code></p>

<pre><code class="language-no-highlight">global idt_flush
idt_flush:
    mov     eax, [esp + 4]
    lidt    [eax]
    ret</code></pre>

<p>Функция для установки регистра для IDT проста: она вызывает инструкцию <code>lidt</code>, передав ей адрес структуры.</p>

<p>Нам осталось определить обработчики. При возникновении прерывания процессор кладет на стек значения регистров <code>eip</code>, <code>cs</code>, <code>eflags</code>, <code>esp</code>, <code>ss</code>, которые были в момент возникновения прерывания, и адрес возврата. Затем, если это был exception, но на стек код ошибки, если у этого номера он есть (например, у номера <code>13</code>). Интересно отметить, что если прерывание с тем же номером вызвать инструкцией <code>int</code>, то код ошибки положен не будет. Понять в обработчике, есть ли код ошибки, придётся самостоятельно (программирование на x86 — это боль).</p>

<p>При возвращении из обработчика необходимо убрать всё, что было положено на стек. Для этого используют инструкцию <code>iret</code>.</p>

<p><code>idt.asm</code></p>

<pre><code class="language-no-highlight">...
extern handler_c

global handler0
handler0:
    cli
    push    dword 0
    push    dword 0
    call    handler_c
    sti
    add     esp, 0x8
    iret

global handler13
handler13:
    cli
    push    dword 13
    call    handler_c
    sti
    add     esp, 0x8
    iret</code></pre>

<p>Мы хотим иметь общий обработчик на C, который будет знать номер прерывания и код ошибки. Для этого в <code>handler0</code> мы кладём бессмысленный код ошибки. Из-за того, как передаются аргументы в функции, мы сможем использовать эти числа в функции на C. Обработку прерывания по-хорошему нужно проводить с выключенными прерываниями, так как мы можем временно переводить процессор в "промежуточные" состояния. Но здесь мы такого не делаем.</p>

<p>Напомню, что код ошибки кладётся только при возникновении exception-а. Я позже его намеренно вызову. Если же вы выполните инструкцию <code>int 10</code>, то ваш стек съедет.</p>

<p><code>idt.h</code></p>

<pre><code class="language-cpp">...
void handler_c(int id, int error_code) {
    printf("Interrupt: %d %d\n", id, error_code);
}</code></pre>

<p>А вот и обработчик на языке C, который просто выводит информацию. Вы ведь написали написали функции для вывода? (Подставьте здесь свои.)</p>

<p><code>kernel.c</code></p>

<pre><code class="language-cpp">...
#include "idt.h"

void kernel_main() {
    idt_init();
}</code></pre>

<p>Здесь мы просто вызвали функцию, настраивающую ITD.</p>

<p><code>boot.asm</code></p>

<pre><code class="language-no-highlight">...
_start:
    lea     esp, stack_top
    call    kernel_main
    int     0x0
    mov     ax, 0x8
    mov     ss, ax

    cli
.1: hlt
    jmp .1</code></pre>

<p>Теперь демонстрация прерываний. Выполните <code>make qemu</code>.</p>

<p>После выполнения инструкции <code>int 0x0</code>, вы увидете строку <code>Interrupt: 0, 0</code>. Затем выполнения этой функции возобновиться. Далее я пытаюсь сменить сегмент на <code>0x8</code>, но я не имею на это права. При выполнении инструкции <code>mov ss, ax</code> будет выведено <code>Interrupt 13, 8</code>, так как именно это прерывание General Protection Fault вызывается в этом случае. Здесь <code>8</code> — это код ошибки, который, похоже, говорит о том, что мы попытались выбрать сегмент <code>0x8</code>.</p>

<p>Далее происходит интересная вещь — после завершения выполнения обработчика будет предпринята ещё одна попытка выполнения инструкции <code>mov ss, ax</code>. При этом, регистра <code>ax</code> станет равным нулю, но на этот сегмент мы тоже не можем переключаться. Поэтому далее мы будем бесконечно получать <code>Interrupt 13, 0</code>.</p>

<p>Почему после обработки exception-а выполнения продолжается с той же инструкции? На самом деле, при выполнении пользовательских программ много что може потребовать вмешательства прерываний. Иногда при обращении к памяти происходит Page Fault (посмотрите номер этого прерывания). Это означает, что куска памяти, к которому вы обратились, сейчас нет в оперативной памяти. В этом случае обработчик прерывания находит место в оперативной памяти, копирует туда память программы, после чего снова выполняется инструкция обращения к памяти, которая на этот раз не вызывает Page Fault. При этом пользовательская программа никак не может узнать об этом Page Fault-е.</p><h3 id="5.4.9">5.4.9. Задача: Обработчики прерываний</h3><p>Добавьте обработчики для всех прерываний. Обычно для этого используют макросы.</p><h3 id="5.4.10">5.4.10. Задача: Простейшие ядра на других архитектурах</h3><p>Выполните "Bare Bones" для архитектур arm и risc-v на <a href="https://wiki.osdev.org" rel="noopener noreferrer nofollow">https://wiki.osdev.org</a> , включая запуск в qemu.</p>

<p>Попробуйте отдавать предпочтение компилятору zig, вместо gcc.</p>
      </main>
    </div>
  </div>
</body>

</html>
