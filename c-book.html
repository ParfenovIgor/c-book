<!DOCTYPE html>

<html>
<head>
  <meta http-equiv="Content-Type" content="text/html">    
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  <title>C - Язык Программирования</title>
  <style>      :root{
         --nav-width: 26em;
         --nav-margin-l: 1em;
      }
      body{
        font-family: system-ui, -apple-system, Roboto, "Segoe UI", sans-serif;
        margin: 0;
        line-height: 1.5;
      }
      header {
        padding: 0 1em;
      }
      #contents {
        max-width: 60em;
        margin: auto;
        padding: 0 1em;
      }
      #navigation {
        padding: 0 1em;
      }
      table ul {
        list-style-type: none;
        padding: 0em;
      }
      table li {
        padding-bottom: 1em;
        line-height:1.2em;
      }
      table, th, td {
        border-collapse: collapse;
        border: 1px solid grey;
      }
      th, td {
        padding: 0.5em;
      }
      th[scope=row] {
          text-align: left;
          font-weight: normal;
      }

      @media screen and (min-width: 1025px) {
        header {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
        header h1 {
          margin: auto;
          max-width: 30em;
        }
        #navigation {
          overflow: auto;
          width: var(--nav-width);
          height: 100vh;
          position: fixed;
          top:0;
          left:0;
          bottom:0;
          padding: unset;
          margin-left: var(--nav-margin-l);
        }
        #navigation nav ul {
          padding-left: 1em;
        }
        #contents-wrapper {
          margin-left: calc(var(--nav-width) + var(--nav-margin-l));
        }
      }

      a:hover,a:focus {
        background: #fff2a8;
      }
      dt {
        font-weight: bold;
      }
      .sgr-1m {
        font-weight: bold;
      }
      .sgr-2m {
        color: #575757;
      }
      .sgr-31_1m {
        color: #b40000;
      }
      .sgr-32_1m {
        color: green;
      }
      .sgr-36_1m {
        color: #005C7A;
      }
      .file {
        font-weight: bold;
        border: unset;
      }
      code {
        background: #f8f8f8;
        border: 1px dotted silver;
        padding-left: 0.3em;
        padding-right: 0.3em;
      }
      pre > code {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      samp {
        background: #fafafa;
      }
      pre > samp {
        display: block;
        overflow: auto;
        padding: 0.5em;
        border: 1px solid #eee;
        line-height: normal;
      }
      kbd {
        font-weight: normal;
      }
      .table-wrapper {
        width: 100%;
        overflow-x: auto;
      }

      .tok-kw {
          color: #333;
          font-weight: bold;
      }
      .tok-str {
          color: #d14;
      }
      .tok-builtin {
          color: #005C7A;
      }
      .tok-comment {
          color: #545454;
          font-style: italic;
      }
      .tok-fn {
          color: #900;
          font-weight: bold;
      }
      .tok-null {
          color: #005C5C;
      }
      .tok-number {
          color: #005C5C;
      }
      .tok-type {
          color: #458;
          font-weight: bold;
      }

      figure {
        margin: auto 0;
      }
      figure pre {
        margin-top: 0;
      }

      figcaption {
        padding-left: 0.5em;
        font-size: small;
        border-top-left-radius: 5px;
        border-top-right-radius: 5px;
      }
      figcaption.zig-cap {
        background: #fcdba5;
      }
      figcaption.c-cap {
        background: #a8b9cc;
        color: #000;
      }
      figcaption.peg-cap {
        background: #fcdba5;
      }
      figcaption.javascript-cap {
        background: #365d95;
        color: #fff;
      }
      figcaption.shell-cap {
        background: #ccc;
        color: #000;
      }

      aside {
        border-left: 0.25em solid #f7a41d;
        padding: 0 1em 0 1em;
      }

      h1 a, h2 a, h3 a, h4 a, h5 a {
        text-decoration: none;
        color: #333;
      }

      a.hdr {
        visibility: hidden;
      }
      h1:hover > a.hdr, h2:hover > a.hdr, h3:hover > a.hdr, h4:hover > a.hdr, h5:hover > a.hdr {
        visibility: visible;
      }

      th pre code {
          background: none;
      }

      @media (prefers-color-scheme: dark) {
        body{
            background:#121212;
            color: #ccc;
        }
        a {
            color: #88f;
        }
        a:hover,a:focus {
            color: #000;
        }
        table, th, td {
            border-color: grey;
        }
        .sgr-2m {
            color: grey;
        }
        .sgr-31_1m {
            color: red;
        }
        .sgr-32_1m {
            color: #00B800;
        }
        .sgr-36_1m {
            color: #0086b3;
        }
        code {
          background: #222;
          border-color: #444;
        }
        pre > code {
            color: #ccc;
            background: #222;
            border: unset;
        }
        samp {
          background: #000;
          color: #ccc;
        }
        pre > samp {
          border: unset;
        }
        .tok-kw {
            color: #eee;
        }
        .tok-str {
            color: #2e5;
        }
        .tok-builtin {
            color: #ff894c;
        }
        .tok-comment {
            color: #aa7;
        }
        .tok-fn {
            color: #B1A0F8;
        }
        .tok-null {
            color: #ff8080;
        }
        .tok-number {
            color: #ff8080;
        }
        .tok-type {
            color: #68f;
        }
        h1 a, h2 a, h3 a, h4 a, h5 a {
            color: #aaa;
        }
        figcaption.zig-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.peg-cap {
            background-color: #b27306;
            color: #000;
        }
        figcaption.shell-cap {
          background: #2a2a2a;
          color: #fff;
        }
      }
</style>
  <script type="text/javascript"
    src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  </script>
</head>


<body>
  <header><h1>C - Язык Программирования</h1></header>

  <div id="main-wrapper">
    <div id="navigation">        
      <nav aria-labelledby="table-of-contents">
        <h2 id="table-of-contents">Содержание</h2>
        <ul>

<li><a href="#1">1. Введение</a><ul><li><a href="#1.1">1.1. Об этом курсе</a><ul><li><a href="#1.1.1">1.1.1</a></li></ul></li><li><a href="#1.2">1.2. О чём нужно знать</a><ul><li><a href="#1.2.1">1.2.1</a></li><li><a href="#1.2.2">1.2.2</a></li></ul></li></ul></li><li><a href="#2">2. Вид сверху на C</a><ul><li><a href="#2.1">2.1. Введение</a><ul><li><a href="#2.1.1">2.1.1</a></li><li><a href="#2.1.2">2.1.2</a></li><li><a href="#2.1.3">2.1.3</a></li><li><a href="#2.1.4">2.1.4</a></li><li><a href="#2.1.5">2.1.5</a></li><li><a href="#2.1.6">2.1.6</a></li><li><a href="#2.1.7">2.1.7</a></li><li><a href="#2.1.8">2.1.8</a></li></ul></li><li><a href="#2.2">2.2. Контроль потока</a><ul><li><a href="#2.2.1">2.2.1</a></li><li><a href="#2.2.2">2.2.2</a></li><li><a href="#2.2.3">2.2.3</a></li><li><a href="#2.2.4">2.2.4</a></li><li><a href="#2.2.5">2.2.5</a></li><li><a href="#2.2.6">2.2.6</a></li><li><a href="#2.2.7">2.2.7</a></li><li><a href="#2.2.8">2.2.8</a></li><li><a href="#2.2.9">2.2.9</a></li><li><a href="#2.2.10">2.2.10</a></li></ul></li><li><a href="#2.3">2.3. Функции</a><ul><li><a href="#2.3.1">2.3.1</a></li><li><a href="#2.3.2">2.3.2</a></li><li><a href="#2.3.3">2.3.3</a></li><li><a href="#2.3.4">2.3.4</a></li><li><a href="#2.3.5">2.3.5</a></li><li><a href="#2.3.6">2.3.6</a></li><li><a href="#2.3.7">2.3.7</a></li></ul></li><li><a href="#2.4">2.4. Указатели</a><ul><li><a href="#2.4.1">2.4.1</a></li><li><a href="#2.4.2">2.4.2</a></li><li><a href="#2.4.3">2.4.3</a></li><li><a href="#2.4.4">2.4.4</a></li><li><a href="#2.4.5">2.4.5</a></li><li><a href="#2.4.6">2.4.6</a></li><li><a href="#2.4.7">2.4.7</a></li><li><a href="#2.4.8">2.4.8</a></li><li><a href="#2.4.9">2.4.9</a></li><li><a href="#2.4.10">2.4.10</a></li><li><a href="#2.4.11">2.4.11</a></li></ul></li><li><a href="#2.5">2.5. Строки</a><ul><li><a href="#2.5.1">2.5.1</a></li><li><a href="#2.5.2">2.5.2</a></li><li><a href="#2.5.3">2.5.3</a></li><li><a href="#2.5.4">2.5.4</a></li><li><a href="#2.5.5">2.5.5</a></li><li><a href="#2.5.6">2.5.6</a></li><li><a href="#2.5.7">2.5.7</a></li><li><a href="#2.5.8">2.5.8</a></li></ul></li><li><a href="#2.6">2.6. Структуры</a><ul><li><a href="#2.6.1">2.6.1</a></li><li><a href="#2.6.2">2.6.2</a></li><li><a href="#2.6.3">2.6.3</a></li><li><a href="#2.6.4">2.6.4</a></li><li><a href="#2.6.5">2.6.5</a></li><li><a href="#2.6.6">2.6.6</a></li><li><a href="#2.6.7">2.6.7</a></li><li><a href="#2.6.8">2.6.8</a></li></ul></li><li><a href="#2.7">2.7. Функции высшего порядка, макросы, шаблоны</a><ul><li><a href="#2.7.1">2.7.1</a></li><li><a href="#2.7.2">2.7.2</a></li><li><a href="#2.7.3">2.7.3</a></li><li><a href="#2.7.4">2.7.4</a></li><li><a href="#2.7.5">2.7.5</a></li><li><a href="#2.7.6">2.7.6</a></li><li><a href="#2.7.7">2.7.7</a></li></ul></li></ul></li><li><a href="#3">3. Компиляция, gcc</a><ul><li><a href="#3.1">3.1. Фазы компиляции</a><ul><li><a href="#3.1.1">3.1.1</a></li><li><a href="#3.1.2">3.1.2</a></li><li><a href="#3.1.3">3.1.3</a></li><li><a href="#3.1.4">3.1.4</a></li><li><a href="#3.1.5">3.1.5</a></li><li><a href="#3.1.6">3.1.6</a></li></ul></li><li><a href="#3.2">3.2. Многомодульные программы</a><ul><li><a href="#3.2.1">3.2.1</a></li><li><a href="#3.2.2">3.2.2</a></li><li><a href="#3.2.3">3.2.3</a></li><li><a href="#3.2.4">3.2.4</a></li><li><a href="#3.2.5">3.2.5</a></li><li><a href="#3.2.6">3.2.6</a></li></ul></li><li><a href="#3.3">3.3. GNU make</a><ul><li><a href="#3.3.1">3.3.1</a></li><li><a href="#3.3.2">3.3.2</a></li><li><a href="#3.3.3">3.3.3</a></li><li><a href="#3.3.4">3.3.4</a></li><li><a href="#3.3.5">3.3.5</a></li><li><a href="#3.3.6">3.3.6</a></li><li><a href="#3.3.7">3.3.7</a></li><li><a href="#3.3.8">3.3.8</a></li><li><a href="#3.3.9">3.3.9</a></li></ul></li></ul></li><li><a href="#4">4. Unix</a><ul><li><a href="#4.1">4.1. Shell</a><ul><li><a href="#4.1.1">4.1.1</a></li><li><a href="#4.1.2">4.1.2</a></li><li><a href="#4.1.3">4.1.3</a></li><li><a href="#4.1.4">4.1.4</a></li><li><a href="#4.1.5">4.1.5</a></li><li><a href="#4.1.6">4.1.6</a></li><li><a href="#4.1.7">4.1.7</a></li><li><a href="#4.1.8">4.1.8</a></li><li><a href="#4.1.9">4.1.9</a></li><li><a href="#4.1.10">4.1.10</a></li></ul></li><li><a href="#4.2">4.2. Системные вызовы</a><ul><li><a href="#4.2.1">4.2.1</a></li><li><a href="#4.2.2">4.2.2</a></li><li><a href="#4.2.3">4.2.3</a></li><li><a href="#4.2.4">4.2.4</a></li><li><a href="#4.2.5">4.2.5</a></li><li><a href="#4.2.6">4.2.6</a></li><li><a href="#4.2.7">4.2.7</a></li><li><a href="#4.2.8">4.2.8</a></li><li><a href="#4.2.9">4.2.9</a></li><li><a href="#4.2.10">4.2.10</a></li><li><a href="#4.2.11">4.2.11</a></li></ul></li><li><a href="#4.3">4.3. Файловая система</a><ul><li><a href="#4.3.1">4.3.1</a></li><li><a href="#4.3.2">4.3.2</a></li><li><a href="#4.3.3">4.3.3</a></li><li><a href="#4.3.4">4.3.4</a></li><li><a href="#4.3.5">4.3.5</a></li><li><a href="#4.3.6">4.3.6</a></li><li><a href="#4.3.7">4.3.7</a></li><li><a href="#4.3.8">4.3.8</a></li></ul></li></ul></li><li><a href="#5">5. Assembly</a><ul><li><a href="#5.1">5.1. Регистры, базовые инструкции</a><ul><li><a href="#5.1.1">5.1.1</a></li><li><a href="#5.1.2">5.1.2</a></li><li><a href="#5.1.3">5.1.3</a></li><li><a href="#5.1.4">5.1.4</a></li><li><a href="#5.1.5">5.1.5</a></li><li><a href="#5.1.6">5.1.6</a></li><li><a href="#5.1.7">5.1.7</a></li><li><a href="#5.1.8">5.1.8</a></li><li><a href="#5.1.9">5.1.9</a></li><li><a href="#5.1.10">5.1.10</a></li><li><a href="#5.1.11">5.1.11</a></li><li><a href="#5.1.12">5.1.12</a></li><li><a href="#5.1.13">5.1.13</a></li><li><a href="#5.1.14">5.1.14</a></li></ul></li></ul></li>
        </ul>
      </nav>
    </div>

    <div id="contents-wrapper">
      <main id="contents">

<h2 id="1">1. Введение</h2><h3 id="1.1">1.1. Об этом курсе</h3><h3 id="1.1.1">1.1.1</h3><p>Здравствуй, уважаемый читатель. Добро пожаловать на курс по языку программирования C. Однако, скорее всего, если ты ещё не погружен в эту тему, этот курс окажется намного глубже, чем ты сейчас ожидаешь. Здесь мы не ограничимся только такими вещами, как типы данных, ветвления, функции и указатели, а лишь начнём с этого.</p>

<p>Попробуем подумать над такой идеей — а зачем нужен язык C? При поверхностном взгляде на него кажется, что у него нет таких сторон, с которых его бы не обходил какой-либо другой язык. Когда мы должны его использовать? Ответ — когда мы не можем развернуть среду для других языков. Язык C очень независимый. Полностью регулировать зависимости програм, написанных на нём, очень просто. То же самое касается и структуры результирующих программ. А это означает, что изучать язык C без понимания о том, как управлять процессом компиляции, не имеет смысла.</p>

<p>Немного о том, как следует работать с этим курсом. Если вы уже можете компилировать и запускать программы на C на какой-либо системе — можете сразу переходить к модулю <em>Вид сверху на C</em>, минуя пункт 1.2. Даже если вы уже знаете заявленный там контент, всё равно есть смысл пролистать текст, так как в нём есть полезные идеи. После завершения изучения этого модуля читайте пункт 1.2, который расскажет о том, как получить необходимую для нашей работы среду, и переходите к остальным модулям.</p>

<p>Мне было лень писать большое количество текста, поэтому информация в тексте очень концентрированная. Убедитесь, что вы понимаете каждую идею, которую я даю в тексте. То же самое касается и заданий — обычно это не просто вопросы к тексту параграфа, а задачи, требующие изучения и обдумывания какой-либо идеи. Иногда в качестве заданий будут даваться проекты, которые дают большую свободу действий.</p><h3 id="1.2">1.2. О чём нужно знать</h3><h3 id="1.2.1">1.2.1</h3><h3>Компилятор для С</h3>

<p>На протяжении первого модуля допустимо использовать любые компиляторы и любые IDE, а также online компиляторы, например, <a href="https://godbolt.org/" rel="noopener noreferrer nofollow">godbolt</a> (обратите внимание на количество доступных компиляторов там).</p>

<p>Для удобства мы будем работать с операционной системой <code>Linux</code>, так как она имеет более простой и сильный <code>shell</code>, более простое и понятное внутреннее устройство, которое мы также будем изучать, и более удобные необходимые нам инструменты.</p>

<p>Важно определить и понять, какие компиляторы мы будем использовать. Хоть и с верхней стороны язык C в них идентичен, с нижней стороны они могут сильно отличаться. Я выбрал компилятор <code>gcc</code>. Это стандартный компилятор в системах <code>Linux</code>, и в большинстве дистрибутивов он установлен изначально.</p>

<p>На <code>Windows</code> имеется компилятор <code>mingw</code>, который заявлен, как порт gcc на Windows. Его можно установить, например, вместе с <code>IDE</code> <code>Codeblocks</code>, а затем добавить исполняемый файл в переменную PATH.</p>

<p>Идея курса в "сквозном" изучении компилятора gcc, поэтому разрешается пользоваться IDE только в течении первого модуля. Далее мы будем запускать gcc только с помощью терминала. До начала второго модуля убедитесь, что gcc доступен в терминале.</p>

<p>Существуют альтернативные компиляторы, которые имеет смысл изучить, но которые не будут покрыты данным курсом.</p>

<ul>
	<li><code>MSVC</code>. О данном компиляторе мне известно мало. Он предназначен только для Windows, и с его установкой могут быть проблемы.</li>
	<li><code>Clang</code>. Данный компилятор имеет другой "путь" компиляции, в процессе которого используется язык <code>llvm</code>. Предназначен для обеих ОС.</li>
	<li><code>Zig</code>. Помимо того, что zig является отдельным языком, его компилятор является хорошей альтернативой другим компиляторам языка C.</li>
</ul><h3 id="1.2.2">1.2.2</h3><h3>Система</h3>

<p>В случае, если ваша основная операционная система — Windows, прочитайте этот раздел.</p>

<p>Все дистрибутивы Linux без проблем позволяют поставить на один диск (HDD/SSD) несколько ОС Linux. В таком случае при запуске компьютера будет загружаться сначала <code>загрузчик</code> (обычно, <code>grub</code>), который будет спрашивать у вас, какую ОС на этот раз загрузить. Однако установка к Linux-у на диск ОС Windows, насколько мне известно, является нестабильным способом, так как Windows иногда затирает загрузчик Linux-а.</p>

<p>Возможные способы:</p>

<ul>
	<li>Если у вас имеется дополнительный диск (HDD/SSD), можете поставить на него вторую ОС. При такой установке Windows не будет трогать другой диск (а в некоторых вариантах установки даже и не сможет его видеть). Так как вы ставите Linux к уже рабочей Windows, либо выберите дистрибутив с хорошим GUI (например, <code>Ubuntu</code>), либо попросите помощи, чтобы случайно не затереть не тот диск.</li>
	<li>Если на вашем компьютере есть хотя бы 8 Gb <code>RAM</code> (оперативной памяти), вы можете поставить виртуальную машину. Я рекомендую программу <code>VirtualBox</code>. В ней выделите виртуальной машине примерно половину своей оперативной памяти, не менее двух процессорных ядер и не менее 30 Gb дисковой памяти (если вы знаете свой дистрибутив, этот размер может быть намного меньше). Лучше поставьте легковесный <code>DE</code> (desktop environment), например, XFCE.</li>
	<li><code>WSL</code>, однако я им никогда не пользовался и ничего о нём не знаю.</li>
</ul>

<p>Что не рекомендуется:</p>

<ul>
	<li>Ставить Linux на один диск с Windows (но может, кто-то сможет убедить меня в обратном)</li>
	<li>Использовать Cygwin. У этого способа виртуализации большие проблемы с пакетами.</li>
	<li>Использовать не аппаратную виртуализацию (например, <code>QEMU</code> имеет аппаратную виртуализацию только на Linux).</li>
</ul>

<p>Возможные проблемы с <code>VirtualBox</code>:</p>

<ul>
	<li>Зависания машины намертво. Это происходит из-за того, как VirtualBox эмулирует диск. Вы можете заметить, что на гостевой ОС заканчивается Swap, а на хостовой ОС потребление диска возрастает до 100%. К сожалению, это не лечится.</li>
	<li>Ошибки запуска виртуальной ОС после неудачного завершения работы (например, вхождения в гибернацию). Оставьте файл диска (его расширение — <code>.vdi</code>), а остальное удалите. Создайте новую машину и добавьте в неё этот файл диска.</li>
	<li>Медленная работа. Это означает, что VirtualBox перешел в программную виртуализацию (в этом случае внизу-справа показывается иконка черепахи, вместо иконки чипа). Это может произойти из-за того, что вы поставили <code>Hyper-V</code> и он занял гипервизор процессора. Удалите Hyper-V.</li>
</ul><h2 id="2">2. Вид сверху на C</h2><h3 id="2.1">2.1. Введение</h3><h3 id="2.1.1">2.1.1</h3><p>Рассмотрим простейшую однофайловую программу на C:</p>

<pre><code class="language-cpp">int main() {
    return 0;
}</code></pre>

<p>Здесь определена функция под названием <code>main</code>. <code>int main()</code> — это сигнатура функции. По ней мы видим, что функция не принимает аргументов, так как круглые скобки ничего не содержат, и возвращает тип <code>int</code> — целое число. В фигурных скобках содержится тело функции, которое содержит лишь один <em>statement </em> <code>return 0</code>, который завершает выполнение функции, возвращая значение <code>0</code>. Пока можно сильно не задумываться обо всем вышенаписанном, мы вернемся к функциям с большими подробностями позже.</p><h3 id="2.1.2">2.1.2</h3><p>Сложно анализировать выполнение программы не имея возможности ввода и вывода. Научимся выводить. Первой функцией для вывода будет <code>int puts(const char *str)</code>. Давайте изучим её сигнатуру.</p>

<p>Во-первых, функция принимает один аргумент типа <code>const char *str</code>. Пока не будем расшифровывать этот сложный тип, и поверим, что это строка, известная на этапе компиляции (то есть, мы не сможем её сформировать интерактивно). Очевидно эта строка будет напечатана. Позже мы узнаем, что такое потоки <em>streams</em>, пока будем считать, что вывод идет в консоль.</p>

<p>Во-вторых, функция возвращает тип <code>int</code>, и, если мы посмотрим в документацию <em>cppreference</em>, мы увидим, что то, что она возвращает, описано с большой свободой.</p>

<blockquote>
<p>On success, returns a non-negative value.</p>

<p>On failure, returns <a href="https://en.cppreference.com/w/c/io" rel="noopener noreferrer nofollow" title="c/io">EOF</a> and sets the <em>error</em> indicator (see <a href="https://en.cppreference.com/w/c/io/ferror" rel="noopener noreferrer nofollow" title="c/io/ferror">ferror()</a>) on <code>stream</code>.</p>
</blockquote>

<p>В свою очередь: </p>

<blockquote>
<table>
	<tbody>
		<tr>
			<td>
			<p>EOF</p>
			</td>
			<td>integer constant expression of type int and negative value</td>
		</tr>
	</tbody>
</table>
</blockquote>

<p>Такую картину мы будем видеть во многих функциях. Можно посмотреть и <code>ferror()</code>, но нам это пока неинтересно.</p>

<p>Давайте, наконец, напечатаем что-либо.</p>

<pre><code class="language-cpp">int main() {
    puts("Hello");
    puts("Test");
    return 0;
}</code></pre>

<p>Обратите внимание: в этой программе я не написал <code>#include &lt;stdio.h&gt;</code>, несмотря на то, что так обычно делают. Дело в том, что мы пока не понимаем, что такое <code>#include</code>, но он и не нужен. Вы получите предупреждение о том, что <code>puts</code>не был объявлен, но исполняемый файл вы все равно получите.</p>

<p>При запуске этой программы будет выполнена функция <code>main</code>, в которой будет вызвана функция <code>puts("Hello")</code>, в результате чего будет выполнена печать строки <em>Hello</em> и перевод строки, а затем будет вызвана функция <code>puts("Test")</code>, в результате чего будет выполнена печать строки <em>Test</em> и перевод строки.</p><h3 id="2.1.3">2.1.3</h3><p>Научимся работать с локальными переменными, а заодно и выводить числа. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a;
    int b = 2 + 3;
    b = a + 8;
    printf("%d %s %d\n", a, "Hello", b + 7);
    return 0;
}</code></pre>

<p>В первой строке тела функции <code>main</code>мы объявляем <em>declare</em> переменную типа <code>int</code> с именем <code>a</code>. Мы не присваиваем <em>define</em> её. Её значение на этом моменте будет неопределенно. Какое значение получит переменная <code>a</code> мы узнаем позже.</p>

<p>Во второй строке мы объявляем <em>declare</em> и сразу определяем <em>define</em> переменную типа <code>int</code> с именем <code>b</code>. Мы присваиваем ей значение <code>5</code>.</p>

<p>В третьей строке мы переопределяем значение переменной <code>b</code>. Так как в вычислении её значения используется неопределенная переменная <code>a</code>, теперь значение переменной <code>b</code> тоже не определено.</p>

<p>В четвертой строке вы используем новую, намного более сложную функцию — <code>printf</code>. Это функция с неопределенным количеством аргументов (vararg функция, эллипсис). Первый её аргумент — это строка, задающая формат. Он имеет достаточно богатые возможности, и мы будем ими пользоваться по мере необходимости. Пока остановимся на том, что подстроки <code>%d</code> будут заменены на число в следующем по счету аргументе, подстроки <code>%s</code> будут заменены на строку в следующем по счету аргументе (первый <code>%d</code> заменится на аргумент <code>a</code>, <code>%s</code> заменится на аргумент <code>"Hello"</code>, второй <code>%d</code> заменится на аргумент <code>b + 7</code>), а <code>\n</code> обозначает символ перехода строки line feed (другие подобные символы мы увидим позже).</p>

<p>Определить вывод этой программы наперед не получится, так как значения переменных зависят от компилятора. В будущем мы часто будем с этим сталкиваться.</p><h3 id="2.1.4">2.1.4</h3><p>Рассмотрим базовые типы данных, которые нам в ближайшее время могут пригодиться.</p>

<ul>
	<li><code>int</code> — целые числа, на хранение котах выделяется <code>4</code> байта</li>
	<li><code>short</code> — целые числа, на хранение которых выделяется <code>2</code> байта</li>
	<li><code>char</code> — целые числа, на хранение которых выделяется <code>1</code> байт</li>
	<li><code>long long</code> — целые числа, на хранение которых выделяется <code>8</code> байт</li>
	<li><code>long</code> — целые числа, на хранение которых выделяется ?? байт</li>
</ul>

<p>Помимо этих типов, на понадобится <code>const char*</code>.</p>

<p>Интересная ситуация с логическим типом <code>_Bool</code> — он был введен не сразу, и в многих программах вводили тип с названием <code>bool</code> самостоятельно с помощью препроцессора, поэтому и было выбрано такое странное название. Логический тип имеет лишь два значения: <code>true</code> и <code>false</code>. (На самом деле, размер этого типа <code>1</code> байт, и <code>false</code> соответствует числу <code>0</code>, в то время как <code>true</code> всем остальным.)</p>

<p>Размер типа <code>long</code> в свою очередь зависит от системы. На <em>Windows</em> он равен 4, а на <em>Linux</em> он равен 8. В целом, встроенные типы на описывают нормально свою размерность, как в языках <em>Rust</em> и <em>Zig</em>, и это бывает проблемой.</p>

<p>Про указатели мы поговорим позже.</p>

<p>С помощью оператора <code>sizeof(x)</code> можно узнать размер типа в байтах, причем в качестве аргумента можно использовать как тип, так и переменную или значение.</p>

<pre><code class="language-cpp">int main() {
    printf("int: %d\n", sizeof(int));
    printf("short: %d\n", sizeof(short));
    printf("char: %d\n", sizeof(char));
    printf("long long: %d\n", sizeof(long long));
    printf("long: %d\n", sizeof(long));
    printf("const char*: %d\n", sizeof(const char*));
    
    const char *str = "Hello";
    printf("const char*: %d\n", sizeof(str));
    return 0;
}</code></pre><h3 id="2.1.5">2.1.5</h3><p>Изучим несколько базовых операторов.</p>

<ol>
	<li><code>+</code> — оператор сложения, складывает два числа. <code>2 + 3</code> равно <code>5</code>.</li>
	<li><code><span style="color: #000000;">-</span></code> — оператор вычитания, вычитает второе число из первого. <code>5 - 3</code> равно <code><span style="color: #000000;">2</span></code>.</li>
	<li><code><span style="color: #000000;">*</span></code> — оператор умножения, умножает два числа. <code>2 * 3</code> равно <code><span style="color: #000000;">6</span></code>.</li>
	<li><code><span style="color: #000000;">/</span></code> — оператор деления, делит второе число на первое с округлением вниз. <code><span style="color: #000000;">5 / 2</span></code> равно <code><span style="color: #000000;">2</span></code>. <code><span style="color: #000000;">6 / 2</span></code> равно <code><span style="color: #000000;">3</span></code>.</li>
	<li><code>%</code> — оператор остатка от деления, делит второе число на первое и даёт остаток от деления. <code><span style="color: #000000;">5 % 2</span></code> равно <code>1</code>. <code><span style="color: #000000;">6 % 2</span></code> равно <code>0</code>.</li>
</ol>

<p>Если второй аргумент у операторов <code>/</code> и <code>%</code> будет равен <code>0</code>, то программа завершится с ошибкой. Какие при этом механизмы происходят, мы узнаем позже.</p>

<p>Также у этих операторов есть странная особенность: на самом деле они округляют не вниз, а к нулю, что может быть неприятным сюрпризом, если в ваших промежуточных вычислениях будут получаться отрицательные числа. Например <code>-5 / 2</code> равно <code>-1</code> и <code>-5 % 3</code> равно <code>-2</code>.</p>

<p>Имейте ввиду, что числа в C ограничены, и при их переполнении вы не получите никаких предупреждений или ошибок. (Когда такое происходит, процессор ставит флаг переполнения, но компилятор C для скорости даже не смотрит на него.) Например, <code>2000000000 + 2000000000</code> равно <code>-294967296</code>.</p>

<p>Помимо арифметических операторов существуют логические операторы для создания сложных условий.</p>

<ol>
	<li><code>&amp;&amp;</code> или <code>and</code> — оператор И, который возвращает <code>1</code>, если оба аргумента не равны нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>||</code> или <code>or</code> — оператор ИЛИ, который возвращает <code>1</code>, если хотя бы один аргумент не равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>!</code> — унарный оператор НЕ, который возвращает <code>1</code>, если аргумент равен нулю, и возвращает <code>0</code> в противном случае.</li>
	<li><code>==</code> — оператор равенства, который возвращает <code>1</code>, если аргументы равны, и возвращает <code>0</code> в противном случае.</li>
</ol>

<pre><code class="language-cpp">int main() {
    printf("%d ", 3 + 4);
    printf("%d ", 17 % 7);
    printf("%d ", 3 &amp;&amp; 0);
    printf("%d ", 3 || 0);
    printf("%d ", !4);
    printf("%d ", 5 == 5);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>7 3 0 1 0 1 </code></p><h3 id="2.1.6">2.1.6</h3><p>Напишите программу, которая выведет следующий текст:</p>

<pre><code>123
abracadabra
2 + 5 = 7
ababba</code></pre><h3 id="2.1.7">2.1.7</h3><p>Напомним, что в C не сразу был введен логический тип данных <code>_Bool</code>. Однако при этом также есть возможность получить "тип" <code>bool</code>, добавив файл <code>#include &lt;stdbool.h&gt;</code>. (На самом деле, это не совсем тип.)</p>

<p>Как думаете, зачем этот файл был добавлен?</p><h3 id="2.1.8">2.1.8</h3><p>Пока эту задачу можно пропустить, и вернуться к ней намного позднее.</p>

<p>Я немного наврал, когда сказал, что размер типа <code>int</code> — 4 байта. Это не так при компиляции в разрядности ниже, чем 32. Однако современные компиляторы не имеют возможности компилировать в такие разрядности, поэтому это не является проблемой. Можно попробовать найти древний компилятор (например, Open Watcom), который может компилировать в разрядность 16, и проверить <code>sizeof(int)</code> в таком режиме.</p><h3 id="2.2">2.2. Контроль потока</h3><h3 id="2.2.1">2.2.1</h3><p>Начнём с введения нескольких терминов. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a = 5 + 8;
    puts("123");
    int b = puts("456");
    return 0;
}</code></pre>

<p>Тело функции <code>main</code> состоит из четырех действий: объявление переменной <code>a</code>, вызов функции <code>puts("123")</code>, объявление переменной <code>b</code>, возвращение значения <code>0</code>. Каждое из этих действий называется <em>statement</em>.</p>

<p>Посмотрим на первый statement: <code>int a = 5 + 8</code>. Часть <code>5 + 8</code> называется <em>expression</em>. Часть этого expression-а <code>5</code> тоже является expression-ом. На третьем statement-е вызов функции <code>puts("456")</code> также является expression-ом (в то время, как другой вызов этой же функции был statement-ом).</p>

<p>Есть проблема в терминологии: оба этих слова не имеют перевода на русский язык, и обычно их обоих называют просто <em>выражение</em>. Позже, когда мы будем более подробно изучать синтаксис, мы увидим смысл такого разделения.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>statement</td>
			<td>expression</td>
		</tr>
		<tr>
			<td>Исполняются сверху вниз</td>
			<td>Порядок исполнения не определен</td>
		</tr>
		<tr>
			<td>Не имеют конечного значения</td>
			<td>Имеют конечное значение (а потому и тип)</td>
		</tr>
		<tr>
			<td>Имеют side effect</td>
			<td>По хорошему, не должны иметь side effect</td>
		</tr>
	</tbody>
</table>

<p><em>Side effect</em> означает, что исполнение фрагмента кода приведет к изменению чего либо за его пределами (изменятся внешние переменные; что-то запишется в память, доступную из внешних переменных; выполнится системный вызов и т.д.).</p><h3 id="2.2.2">2.2.2</h3><p>Control Flow (контроль потока) — это набор statement-ов в языке, которые определяют последовательность выполнения statement-ов.</p>

<p>Пока мы видели следующие типы statement-ов:</p>

<ul>
	<li>Declaration (объявление): <code>int a</code>. Объявление также может быть с определением/присваиванием (по сути, это то же самое, но термин определение в других языках может налагать ограничения):<span style="color: #000000;"> <code>int a = 5</code></span>.</li>
	<li>Assignment/Definition (присваивание/определение): <code>a = 5 + 2</code>.</li>
	<li>Function Call (вызов функции): <code>puts("123")</code>.</li>
	<li>Function Return (возврат из функции): <code>return 2 + puts("456")</code>.</li>
</ul>

<p>Конечно, хочется иметь вариативность в порядке исполнения statement-ов. Делать это можно с помощью ветвлений и циклов, которые являются control flow statements.</p>

<p>Посмотрим на <code>if</code>:</p>

<pre><code class="language-cpp">int main() {
    int a = 4;
    if (a - 4) {
        puts("1");
    }
    else if (a) puts("2");
    else {
        puts("3");
    }
    return 0;
}</code></pre>

<p>Данный <code>if</code> statement состоит из трех ветвей. Эти ветви надо читать так:</p>

<ol>
	<li>Если <code>a - 4</code> не <code>0</code>, то выполнить <code>puts("1")</code> и завершить выполнение <code>if</code></li>
	<li>Если <code>a</code> не <code>0</code>, то выполнить <code>puts("2")</code> и завершить выполнение <code>if</code></li>
	<li>Выполнить <code>puts("3")</code></li>
</ol>

<p>Обратите внимание на следующие вещи:</p>

<ul>
	<li>Можно как обрамлять блок в <code>if</code> в фигурные скобки, так и не делать этого.</li>
	<li>В качестве условия в <code>if</code> должен быть expression, а его тип неважен. Проверка идет лишь на то, что он не <code>0</code>. А в языке C по сути любой тип данных — число.</li>
	<li>Веток <code>else if</code> и <code>else</code> может не быть. Количество веток <code>else if</code> не ограниченно.</li>
</ul>

<p>В результате выполнения этой программы будет напечатано единственное число <code>2</code>.</p><h3 id="2.2.3">2.2.3</h3><p>Вскоре нам потребуется начать решать input/output задачи для проверки знаний. Для этого нужно разобраться, как считывать данные. Для этого используется функция <code>scanf</code>. Посмотрим решение задачи A + B.</p>

<p>Напишите программу, которая считывает два целых числа <span class="math-tex">\(a\)</span> и <span class="math-tex">\(b\)</span> (<span class="math-tex">\(-100 \le a, b \le 100\)</span>), и выводит их сумму.</p>

<pre><code class="language-cpp">int main() {
    int a, b;
    scanf("%d%d", &amp;a, &amp;b);
    printf("%d\n", a + b);
    return 0;
}</code></pre>

<p>Функция <code>scanf</code> имеет первым аргументом формат, по которому сопоставляются данные во входном потоке, а следующими аргументами <em>адреса</em>, по которым необходимо эти данные положить. <code>scanf</code> сам считает произвольное количество пробельных символов (пробел, табуляция, следующая строка, возврат каретки и т.д.) между идущими в формате подряд <code>%d</code>. (Принцип, по которому он это делает, мне не очень понятен, но это и не нужно.)</p>

<p>Пока мы не знаем, что такое адреса, но позже мы подробно их изучим. C не имеет возможности передать в функцию локальную переменную так, чтобы функция изменила её. Вместо этого мы передаем адрес локальной переменной, который мы берем оператором <code>&amp;</code> (амперсанд). Интересно, что функция, получая информацию о местоположении локальной переменной, может работать не только с этой переменной, но и с тем что находится рядом с ней. (Она не получает этим <em>права</em> — права у неё от передачи аргументов не меняются. Она получает информацию, где искать данные.) Но об этом мы поговорим подробно потом.</p>

<p>Нетрудно догадаться, как считывать строки, но там есть неочевидные моменты. Мы поговорим о строках отдельно. Пример некорректной программы, которая может, как выполниться успешно, так и завершиться с ошибкой. Ничего страшного, если вы пока не знаете, что такое массивы, и, соответственно, не понимаете программу.</p>

<pre><code class="language-cpp">int main() {
    char str[10];
    scanf("%s", str);
    return 0;
}</code></pre>

<p>А эта программа гарантированно завершится с ошибкой, так как попытается считать данные в константу. Как функционирует такое ограничение, мы также позже узнаем.</p>

<pre><code class="language-cpp">int main() {
    const char *str = "Hello";
    scanf("%s", str);
    return 0;
}</code></pre><h3 id="2.2.4">2.2.4</h3><p>Улитка ползет по столбу высотой <span class="math-tex">\(h\)</span> единиц и хочет забраться на самый его верх. Днем улитка поднимается на <span class="math-tex">\(a\)</span> единиц, а ночью соскальзывает вниз на <span class="math-tex">\(b\)</span> единиц. На какой день улитка заберется на столб?</p>

<h4>Формат ввода</h4>

<p>Единственная строка входных данных содержит три целых числа: <span class="math-tex">\(a\)</span>, <span class="math-tex">\(b\)</span> и <span class="math-tex">\(h\)</span> (<span class="math-tex">\(1 \le b &lt; a \le h \le 10^9\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — номер дня, на который улитка достигнет верха столба.</p><h3 id="2.2.5">2.2.5</h3><p>В C присутствуют циклы <code>while</code>, <code>do while</code> и <code>for</code>. Выходить их циклов можно с помощью операторов <code>break</code> и <code>continue</code>. К сожалению, нет возможности выйти из нескольких циклов, кроме как с помощью оператора перехода к метке <code>goto</code>.</p>

<p>Цикл <code>while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    while (i &lt; 10) {
        printf("%d", i);
        i++;
    }
    return 0;
}</code></pre>

<p>Читать это надо так. Если<code>i &lt; 10</code>, выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу, а затем прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    do {
        printf("%d", i);
        i++;
    } while (i &lt; 10);
    return 0;
}</code></pre>

<p>Читать это надо так. Выполнить тело цикла, в котором необходимо вывести значение <code>i</code> и увеличить его на единицу. Затем, если<code>i &lt; 10</code>, прыгнуть в начало цикла. В противном случае, прервать выполнение цикла.</p>

<p>Вывод этой программы: <code>0123456789</code></p>

<p>Цикл <code>do while</code> отличается от цикла <code>while</code> тем, что он в любом случае сделает хотя бы одну итерацию.</p><h3 id="2.2.6">2.2.6</h3><p> Цикл <code>for</code> выглядит так:</p>

<pre><code class="language-cpp">int main() {
    int i;
    for (i = 0; i &lt; 10; i++) {
        printf("%d", i);
    }
    i = 0;
    for (; i &lt; 10; printf("%d", i) &amp;&amp; i++);
    return 0;
}</code></pre>

<p>Читать первый цикл <code>for</code> надо так. Сначала выполнить <code>i = 0</code>. Затем выполнить тело цикла, в котором необходимо вывести значение <code>i</code>, а затем выполнить <code>i++</code>. Затем, если <code>i &lt; 10</code>, прыгнуть в начало цикл (не выполняя <code>i = 0</code>). В противном случае, прервать выполнение цикла.</p>

<p>Данный цикл на первый взгляд может выглядеть странным и запутанным, но на самом деле он удобен.</p>

<p>Часто вы будете видеть, что в первом "блоке" цикла <code>for </code>(там, где у нас написано <code>i = 0</code>) выполняют объявление переменной (например <code>int i = 0</code>). Однако, это работает не со всеми стандартами языка C. В некоторых стандартах это может считаться ошибкой.</p>

<p>Посмотрим на второй цикл <code>for</code>. Мы видим, что некоторые блоки могут быть пустыми. Все блоки должны являться expressions. Причина этого ясна для второго блока, ведь он проверяет условие, а значит его содержимое должно иметь значение. Но неужели <code>i = 0</code> и <code>i++</code> это тоже expressions, которые имеют какое-то значение? Да. <code>i = 0</code> возвращает значение своего правого аргумента, а <code>i++</code> возвращает значение <code>i</code> до увеличения. (Чуть позже мы изучим все эти операторы подробнее, но вы уже можете почитать про них.)</p>

<p>Оператор <code>&amp;&amp;</code> — это оператор И. Он выполняет левый аргумент, и, если он не <code>0</code>, выполняет правый аргумент и возвращает его, а иначе, возвращает <code>0</code>. Попробуйте теперь самостоятельно понять логику работы второго цикла.</p>

<p>Вывод этой программы: <code>01234567890123456789</code></p><h3 id="2.2.7">2.2.7</h3><p> Немного изменим второй цикл из программы на предыдущем шаге.</p>

<pre><code class="language-cpp">int main() {
    int i = 0;
    for (; i &lt; 10; i++ &amp;&amp; printf("%d", i));
    return 0;
}</code></pre>

<p>Какой будет вывод у этой программы и почему?</p><h3 id="2.2.8">2.2.8</h3><p>С помощью оператора <code>break</code> мы выходим из одного внутреннего цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) break;
        }
    }
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code>001012012301234</code></p>

<p>С помощью оператора <code>continue</code> мы переходим к следующей итерации внутреннего цикла, не выполняя оставшуюся часть тела цикла. Выглядит это так:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            if (j == i) continue;
            printf("%d", j);
        }
    }
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code>12340234013401240123</code></p>

<p>С помощью оператора <code>goto</code> мы переходим к <em>метке</em>. Метка может быть объявлена в любом месте между statement-ов, и выглядит как идентификатор с двоеточием. С помощью оператора <code>goto</code> можно, например, выйти из двойного цикла:</p>

<pre><code class="language-cpp">int main() {
    int i, j;
    for (i = 0; i &lt; 5; i++) {
        for (j = 0; j &lt; 5; j++) {
            printf("%d", j);
            if (j == i) goto end;
        }
    }
    end:
    return 0;
}</code></pre>

<p>В результате выполнения этой программы будет выведено <code><span style="color: #000000;">0</span></code></p>

<p>Бывает, что необходимо по выполнению условия выйти из блока кода. Увы, сделать это так не получится:</p>

<pre><code class="language-cpp">int main() {
    {
        int i;
        if (i) break;
    }
    return 0;
}</code></pre>

<p>Обычно, для этой цели используют цикл или оператор <code>goto</code>. (В языке программирования Zig это организовано получше.)</p>

<p>Старайтесь не использовать оператор <code>goto</code> там, где он может серьезно усложнить читаемость программы, с чем он отлично справляется. Обычно в языке C он используется для того, чтобы выйти из вложенного цикла, и для того, чтобы перейти к очистке в конце функции, если она что-то динамически создала, но в процессе её работы произошла ошибка, из-за которой она должна прерваться и вернуть ошибку. Выглядит это примерно так:</p>

<pre><code class="language-cpp">FOOSTATUS foo() {
    void *data = malloc(SIZE);
    int status = FOO_SUCCESS;
    if (!init_foo(data)) {
        status = FOO_ERROR_INIT;
        goto end
    }
    if (!process_foo(data)) {
        status = FOO_ERROR_PROCESS;
        goto end
    }
    end:
    free(data);
    return status;
}</code></pre><h3 id="2.2.9">2.2.9</h3><p>Для более удобной организации ветвлений используются <code>switch case</code> statement-ы.</p>

<pre><code class="language-cpp">int main() {
    int x = 2;
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 3: printf("3 "); break;
    }
    switch (x) {
        case 1: printf("1 "); break;
        case 2: printf("2 ");
        case 3: printf("3 "); break;
        case 4: printf("4 ");
    }
    switch (x) {
        case 1: printf("1 "); break;
        default: printf("- ");
    }
    printf("\n");
}</code></pre>

<p>Здесь написаны четыре <code>switch case</code> statement-а. В своем теле они имеют ветви, каждая из которых состоит из ключевого слова <code>case</code>, выражения, при котором эта ветвь срабатывает, символа двоеточия и блока кода.</p>

<p>При выполнении <code>switch case</code> statement-а выполняется первая ветвь, выражение после слова <code>case</code> у которой равно выражению после слова <code>switch</code>. У первого <code>switch</code> это вторая ветвь, которая содержит блок <code>printf("%d "); break;</code>. (Ключевое слово <code>break</code> тоже часть блока.) У второго <code>switch</code> такой ветви нет, поэтому ничего не будет исполнено.</p>

<p>Как только срабатывает одна из ветвей, выполняются все следующие ветви вплоть до последней (что по моему мнению является довольно странной логикой), либо до встречи ключевого слова <code>break</code>. Так, у третьего <code>switch</code> будет выполнен блок второй ветви <code>printf("2 ");</code>, а затем продолжится выполнение блока третьей ветви, и, так как он завершается словом <code>break</code>, блок четвертой ветви не будет выполнен.</p>

<p>Четвертый <code>switch</code> statement имеет ветвь, которая начинается с ключевого слова <code>default</code>. Блок данной ветви будет выполнен в любом случае, если не было выполнено ни одного блока выше.</p>

<p>Вывод этой программы: <code>2 2 3 - </code></p><h3 id="2.2.10">2.2.10</h3><p>Успешный брокер Василий смотрит курс акций за последние <span class="math-tex">\(n\)</span> дней. Цена акции в день <span class="math-tex">\(i\)</span> равна <span class="math-tex">\(a_i\)</span>. Василий хочет найти два дня <span class="math-tex">\(p &lt; q\)</span>, такие, что <span class="math-tex">\(a_q - a_p\)</span> максимально возможное, ведь именно покупка акций в день <span class="math-tex">\(p\)</span>, а продажа в день <span class="math-tex">\(q\)</span> принесла бы ему максимальную прибыль, будь у него более развитые экстрасенсорные способности.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — наибольшая разность <span class="math-tex">\(a_q - a_p\)</span>.</p><h3 id="2.3">2.3. Функции</h3><h3 id="2.3.1">2.3.1</h3><p>Мы уже объявляли функции. <code>int main() {}</code> — это объявление функции, которая ничего не принимает. При использовании стандартного <em>linker-скрипта</em> (что это такое, мы узнаем позже) наличие этой функции обязательно.</p>

<p>Cигнатура функции — это список типов аргументов, которые функция принимает, и тип того, что функция возвращает. По умолчанию, функция <code>main</code> возвращает <code>int</code>, и значение <code>0</code> означает успешное выполнение. Это значение называется <em>кодом возврата</em> программы, и в <em>sh</em> можно его посмотреть у запущенной в последний раз программы с помощью переменной <code>$?</code>: <code>echo $?</code>.</p>

<p>Попробуем написать свои функции:</p>

<pre><code class="language-cpp">int foo(int a) {
    return a + 2;
}

int main() {
    int a = 5;
    int b = foo(a);
    foo(a);
    printf("%d %d\n", a, b);
    return 0;
}</code></pre>

<p>Функция <code>foo</code> принимает один аргумент типа <code>int</code> и возвращает его значение, увеличенное на <code>2</code>. В результате выполнения этой программы будет выведено <code>5 7</code></p>

<p>Обратите внимание, что вызов функции может быть как expression-ом, как в первом случае, так и statement-ом, как во втором случае.</p>

<p>Функции используются для организации кода и улучшения читаемости.</p>

<p>Функции можно определять в отдельных файлах, но в C (и Assembly) это делается не так просто, как в остальных языках. Мы поговорим об этом отдельно.</p>

<p>В функции <code>foo</code> можно вызвать функцию <code>foo</code>. Это называется <em>рекурсией</em>. Например, функция вычисления наибольшего общего делителя (greatest common divisor) может быть написана так:</p>

<pre><code class="language-cpp">int gcd(int a, int b) {
    if (a == 0)
        return 0;
    else
        return gcd(b % a, a);
}</code></pre>

<p>Естественно, можно допустить ошибку, при которой вызов функции будет происходить бесконечно. В таком случае, так как на хранение данных о предыдущих (и все ещё идущих) вызовах функции тратится память на стеке, стек вскоре закончится, и возникнет ошибка исполнения.</p>

<p>Функции могут ничего не возвращать. Для этого вместо типа возврата указывается <code>void</code>. В таком случае, нельзя использовать функцию, как expression.</p><h3 id="2.3.2">2.3.2</h3><p>Принято, что функция <code>main</code> принимает два аргумента, и её полная сигнатура на самом деле выглядит так: <code>int main(int argc, char **argv)</code>. Второй аргумент — список строк, длина которого неизвестна, а первый аргумент — длина этого списка. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>Что за список строк имеется ввиду? Это список аргументов программы. Когда мы запускаем программу в терминале, мы передаем их так: <code>./program ababba babba</code>. При таком запуске вывод программы будет такой:</p>

<pre><code>program
ababba
babba</code></pre>

<p>Первый аргумент всегда должен быть названием исполняемого файла. Мы можем нарушить это правило, если сделаем системный вызов <code>exec</code> самостоятельно, и некоторые программы в таком случае могут отказаться работать. (Что такое системные вызовы мы изучим позже.)</p>

<p>Благодаря особенностям <em>ABI</em> (что это такое, мы узнаем позже) мы можем написать в сигнатуру не все аргументы. Однако мы не можем написать большее количество аргументов, иначе они попадут на данные функции, которая нас вызвала, и мы начнем оперировать ими. (<code>main</code> — не первая функция при стандартном linker-скрипте.) Обратите внимание: компилятор никак не помешает нам этого сделать.</p>

<pre><code class="language-cpp">int main(int a, int b, int c, int d) {
    printf("%d %d %d %d\n", a, b, c, d);
    d = 5;
    return 0;
}
</code></pre>

<p>Если использовать 64-битный компилятор, то размер адресов (любых) будет 8 байт (то есть два <code>int</code>-а). Тогда переменные <code>b</code> и <code>c</code> лягут на аргумент <code>argv</code>, а переменная <code>d</code> на вызвавшую функцию. (Если бы функция <code>main</code> была первой, а мы могли бы сделать это, написав свой linker-скрипт, то мы могли бы ткнуться за пределы стека и получить ошибку исполнения.)</p><h3 id="2.3.3">2.3.3</h3><p>Функции "видят" другие функции, объявленные выше. Но если мы хотим написать две вызывающие друг друга функции, то с помощью только определений функций сделать этого, возможно, не удастся. Такой код в C++ некорректен, но в C корректен (возможно, не во всех компиляторах):</p>

<pre><code class="language-cpp">void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Решить эту проблему можно с помощью объявления функции, или, <em>прототипа</em> функции. Выглядит он так:</p>

<pre><code class="language-cpp">void boo(int n);

void foo(int n) {
    boo(1);
}

void boo(int n) {
    foo(2);
}</code></pre>

<p>Прототип функции объявляет лишь сигнатуру. Названия аргументов в нем не важны, и, если мы заменим первую строку на <code>void boo(int);</code>, то это будет по прежнему корректно.</p>

<p>Прототип функции должен соответствовать определению функции. Если прототип здесь будет <code>void boo(long long n);</code>, то это вызовет ошибку компиляции.</p>

<p>Очень важно, что если прототип функции, и её определение будут в разных модулях, то компилятор не сможет заметить несоответствия сигнатур функций. В таком случае во время выполнения программы при вызове функции стек "съедет", и произойдет stack corruption. (Более подробно этот механизм мы изучим позже.)</p><h3 id="2.3.4">2.3.4</h3><p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int, int)</code></li>
	<li><code>int max(int, int)</code></li>
	<li><code>int abs(int)</code> — абсолютное значение (модуль)</li>
	<li><code>int lcm(int, int)</code> — наименьшее общее кратное (least common multiplier)</li>
	<li><code>int powmod(int a, int n, int m)</code> — возведение числа <code>a</code> в степень <code>n</code> по модулю <code>m</code></li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(5, 8) == 5);
    assert(min(11, 4) == 4);
    assert(max(5, 8) == 8);
    assert(max(11, 4) == 4);
    assert(abs(43) == 43);
    assert(abs(-41) == 41);
    assert(lcm(14, 21) == 42);
    assert(lcm(1128960, 567000) == 254016000);
    assert(powmod(3, 4, 7) == 4);
    assert(powmod(43259, 64234, 784) == 505);
    return 0;
}</code></pre>

<p>Функция <code>assert</code> завершает выполнение программы с кодом возврата <code>3</code>, если её аргумент равен нулю (то есть, условие провалено). Возможно, для его использования потребуется добавить <code>#include &lt;assert.h&gt;</code>.</p><h3 id="2.3.5">2.3.5</h3><p>Функции <code>printf</code> и <code>scanf </code>— это функции с переменным количеством аргументов (variadic functions, vararg, ellipsis). Синтаксис C позволяет создавать такие функции, но по понятным (когда придет время) причинам, сам C такие функции поддерживать не может. Проблема в том, что при вызове функции на стек кладутся аргументы и адрес возврата, но ничего более. Поэтому по стеку нельзя понять, сколько аргументов было передано в функцию, и какие их типы или, хотя бы, размерности. Это может вызвать различные corruptions.</p>

<p>Пример функции, вычисляющей сумму аргументов:</p>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

int sum(int n, ...) {
    va_list lst;
    va_start(lst, n);
    
    int sum = 0;
    int i;
    for (i = 0; i &lt; n; i++) {
        sum += va_arg(lst, int);
    }
    
    va_end(lst);
    return sum;
}

int main() {
    printf("%d\n", sum(5, 2, 6, 4, 3, 7));
    return 0;
}</code></pre>

<p>Обратим внимание на следующее:</p>

<ul>
	<li>Нам необходим <code>#include &lt;stdarg.h&gt;</code> для того, чтобы иметь макросы <code>va_list</code>, <code>va_start</code>, <code>va_arg</code>, <code>va_end</code>. (Что такое макросы, мы узнаем позже. Пока считайте, что это функции.)</li>
	<li>Первый аргумент <code>n</code> — это длина массива. Напомню, что функция никак не может знать форму того, что ей передано. Количество аргументов надо указать. Обратите внимание, что если подать в функцию не <code>n</code> следующих аргументов, то она никак это не проверит — это приведет к corruption.</li>
	<li>Чтобы пробежать по аргументам, мы пользуемся переменной типа va_list. Это переменную мы передаем всем функциям, связанным с аргументами. По сути, это не более, чем итератор.</li>
	<li>(Второй аргумент макроса <code>va_start</code> оказался мне неизвестен. Документация утверждает, что это аргумент, после которого начнут перебираться "переменные" аргументы, однако простой тест показал, что это не так.)</li>
	<li>Второй аргумент макроса <code>va_arg</code> это тип (обратите внимание: если бы это была функция, он не могла бы принимать тип), следующего аргумента (а также, его размер).</li>
</ul>

<p>В результате выполнения этой программы будет выведено 22.</p>

<p>Функции с переменными аргументами следует использовать ограниченно и с большой осторожностью.</p><h3 id="2.3.6">2.3.6</h3><p>Реализуйте следующие функции:</p>

<ol>
	<li><code>int min(int n, ...)</code></li>
	<li><code>int gcd(int n, ...)</code></li>
	<li><code>int dot_product(int n, ...)</code> — скалярное произведение двух векторов. Например, произведение векторов <code>(1, 4)</code> и <code>(2, -3)</code> должно вычисляться с помощью такого вызова функции: <code>dot_product(2, 1, 4, 2, -3)</code>.</li>
</ol>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(min(2, 5, 8) == 5);
    assert(min(3, 11, 4, 8) == 4);
    assert(gcd(2, 12, 21) == 3);
    assert(gcd(3, 42, 91, 35) == 7);
    assert(dot_product(2, 1, 4, 2, -3) == -10);
    assert(dot_product(3, 1, 2, 3, 6, 5, 4) == 28);
    return 0;
}</code></pre><h3 id="2.3.7">2.3.7</h3><p>Рассмотрим такую функцию <code>set_args</code>, которая записывает значение второго аргумента по всем остальным аргументам-адресам.</p>

<p>Пока необязательно понимать манипуляции с адресами, но кое-что проясню:</p>

<ul>
	<li><code>int*</code> — это адрес типа <code>int</code>. То есть <code>va_arg(lst, int*)</code> достает следующий адрес.</li>
	<li><code>*a = b</code> выполняет запись значения <code>b</code> в адрес <code>a</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdarg.h&gt;

void set_args(int n, int val, ...) {
    va_list lst;
    va_start(lst, val);
    
    int i;
    for (i = 0; i &lt; n; i++) {
        *va_arg(lst, int*) = val;
    }
    
    va_end(lst);
}

int main() {
    int a, b, c;
    set_args(3, 31, &amp;a, &amp;b, &amp;c);
    printf("%d %d %d\n", a, b, c);
    return 0;
}</code></pre>

<p>Представьте, что пользователь может вводить данные и передавать их в <code>set_args</code> без каких либо проверок. Какую атаку можно здесь произвести (потенциально нехорошее действие)?</p><h3 id="2.4">2.4. Указатели</h3><h3 id="2.4.1">2.4.1</h3><p>Переходим к самой интересной части языка C — указателям/адресам (pointers).</p>

<p>Указатель — это число, обозначающее ячейку в оперативной памяти. Любая локальная переменная имеет адрес, так как ей нужно где-то находиться. То же относится и к аргументам функций. (На самом деле иногда данные находятся в регистрах, но компилятор здесь будет подстраиваться под наши желания.)</p>

<p>Для взятия адреса используется унарный (с одним аргументом) оператор <code>&amp;</code>, который мы уже видели, когда использовали функцию <code>scanf</code>.</p>

<p>Тип указателя обозначается символом <code>*</code> (asterisk). Например, указатель на <code>int</code> выглядит так: <code>int*</code>. При этом синтаксис объявления указателей неочевидный и часто вызывает ошибки.</p>

<ul>
	<li>Так мы объявляем два указателя: <code>int *a, *b;</code></li>
	<li>Так мы объявляем два указателя: <code>int* a, *b;</code></li>
	<li>Так мы объявляем указатель и число: <code>int* a, b;</code></li>
</ul>

<p>Чтобы переместить данные по указателю (то есть положить их в ячейку оперативной памяти с тем же номером, что и значение указателя), используется такая запись: <code>*a = b</code>, где <code>a</code> это указатель, а <code>b</code> это данные.</p>

<p>Рассмотрим программу:</p>

<pre><code class="language-cpp">void set(int *a, int val) {
    *a = val;
}

int main() {
    int a;
    set(&amp;a, 5);
    printf("%d\n", a);
    return 0;
}</code></pre>

<p>Данная программа демонстрирует то, что я показывал выше. Функция <code>set</code> принимает аргумент типа <code>int*</code> (можно было также написать <code>int* a</code>). В функции <code>set</code> используется перемещение (этот термин не имеет отношения к тому, что с данными что-то происходит: они остаются в том же состоянии) по указателю <code>*a = val</code>. При вызове функции <code>set</code> в качестве аргумента передается адрес локальной переменной, который добывается оператором <code>&amp;</code>.</p>

<p>Вывод этой программы: <code>5</code></p><h3 id="2.4.2">2.4.2</h3><p>В языке C присутствуют массивы, но работают они довольно странно и неочевидно. Рассмотрим программу:</p>

<pre><code class="language-cpp">int main() {
    int a[10];
    a[4] = 32;
    printf("%d %d\n", a[4], sizeof(a));
    return 0;
}</code></pre>

<p>Первая строка тела функции <code>main</code> объявляет массив размера <code>10</code>. Массив — это занумерованная последовательность объектов одинакового типа. Размер массива должен быть константой, то есть известным до компиляции (<code>4 + 6</code>, например, тоже является константой).</p>

<p>На второй строке мы присваиваем четвертому элементу массива значение <code>32</code>. Массивы нумеруются с нуля. Последний индекс массива в данном случае равен <code>9</code>.</p>

<p>На третьей строке мы выводим четвертый элемент и размер массива. Вывод этой программы: <code>32 40</code>. Обратите внимание: в качестве размера массива выводится не количество его элементов, а именно занимаемая им память в байтах (напомним, что размер типа <code>int</code> равен <code>4</code> байта).</p>

<p>Что произойдет, если мы выйдем за пределы массива, сделав, например <code>a[10] = 32</code>? В конкретно этом случае, на самом деле, ничего. Точнее, присвоение произойдет, но то, что оно происходит за пределами массива, никак не будет проверено. Массив, как и все локальные переменные, а также адреса возврата функций, лежит на стеке, а в этом месте стека ничего важного не будет. Однако, в некоторых случаях, можно все-таки, перезаписать что-либо важное. Эта особенность делает программирование на C коварным, так как можно создать "отложенные ошибки": пока некорректный код работает, так как ничего не затирает, а с другими исходными данными уже будет затирать.</p>

<p>Можно создавать многомерные массивы:</p>

<pre><code class="language-cpp">int main() {
    int a[4][5];
    a[2][3] = 5;
    a[0][5] = 3;
    printf("%d %d\n", a[2][3], a[1][0]);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>5 3 80</code></p>

<p>Здесь мы создали двумерный массив размера <code>4x5</code>. Оперативная память адресуется линейно, и данный двумерный массив расположен в ней следующим образом: <code>a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[2][5], ...</code>. Именно поэтому, так как C не обращает внимания на выходы за границы, присваивание некорректного индекса <code>a[0][5]</code> приводит к присваиванию индекса <code>a[1][0]</code>.</p>

<p>Обратите внимания на то, что размер массива равен <code>80</code>, или <code>20</code> <code>int</code>-ов. Этот факт нам пригодится позже.</p><h3 id="2.4.3">2.4.3</h3><p>Массивы практически являются указателями. Можно перевести массив в указатель. Рассмотрим программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int a[10];
    int *b = a;
    *(b + 4) = 32;
    printf("%d %d %d\n", b[4], sizeof(a), sizeof(b));
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>32 40 4</code> или <code>32 40 8</code>, в зависимости от разрядности вашего компилятора.</p>

<p>Если вы добавляете к указателю типа <code>T*</code> число <code>x</code>, то на самом деле к указателю добавиться число <code>x * sizeof(T)</code>.</p>

<p><code>*(b + 4)</code> сначала добавляет к  <code>b</code> значение <code>4 * sizeof(int)</code>, а затем <em>разыменовывает</em> (берет значение в этой ячейке памяти) его. Комичный факт, что <code>b[4] == *(b + 4) == *(4 + b) == 4[b]</code>.</p>

<p>Обратите внимание: вы можете делать операции с указателями так же, как и с массивами. Но есть одна разница: <code>sizeof</code> для указателя возвращает размер указателя, а не всего массива. Более того, имея только указатель, узнать размер массива невозможно. То есть, тип указатель, в отличии от типа массив, не знает размер.</p>

<p>Массивы нельзя передавать в функции. Поэтому, чтобы знать в функции размер массива, приходится передавать и размер:</p>

<pre><code class="language-cpp">int sum(int n, int *a) {
    int x = 0, i;
    for (i = 0; i &lt; n; i++) {
        x += a[i];
    }
    return x;
}

int main() {
    int a[5] = {2, 5, 1, 4, 3};
    int n = sizeof(a) / sizeof(a[0]);
    printf("%d\n", sum(n, a));
    return 0;
}</code></pre>

<p>Обратите внимание на синтаксис присваивания значений элементам массива <code>int a[5] = {2, 5, 1, 4, 3};</code>, и на то, как можно узнать количество элементов локального массива, разделив его размер на размер одного из его элементов (часто даже создают такой макрос).</p><h3 id="2.4.4">2.4.4</h3><p>Реализуйте функцию <code>void sort(int n, int *a)</code>, которая сортирует массив <code>a</code> размера <code>n</code>.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const int n = 10;
    int a[n] = {6, 1, 8, 2, 10, 7, 4, 5, 9, 3};
    int b[n] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    sort(n, a);
    assert(memcmp(a, b, n * sizeof(int)) == 0);
    return 0;
}</code></pre><h3 id="2.4.5">2.4.5</h3><p>Массивы можно создавать динамически. В C нет операторов для этого, но есть стандартные функции <code>malloc</code> и <code>free</code>.</p>

<p>Функция <code>void *malloc(size_t size)</code> создает массив размера <code>size</code> байт и возвращает указатель типа <code>void</code> на его начало. <code>size_t</code> здесь это <code>unsigned int</code>, то есть, беззнаковое (только положительное) целое число. Все численные типы имеют соответствующий <code>unsigned</code> тип.</p>

<p><code>void*</code> указатель обозначает указатель на "что-то", и мы должны будем определить, на что он указывает, самостоятельно. Кроме того, добавление числа <code>x</code> к <code>void*</code> указателю добавит к нему именно <code>x</code>, поэтому этот тип часто используется для создания структур данных.</p>

<p>В отличии от локальных массивов, динамические массивы выделяются не на стеке. Возможные их положения зависят от операционной системы. Как можно делать динамические выделения памяти, и как работает <code>malloc</code>, мы узнаем позже.</p>

<p>Функция <code>void free(void *ptr)</code> освобождает массив, на начало которого указывает <code>ptr</code>. Это значение должно быть ранее получено от <code>malloc</code>. В случае, если такое значение ранее не было получено от <code>malloc</code>, и, соответственно, такого массива не существует, будет ошибка исполнения.</p>

<pre><code class="language-cpp">int main() {
    int *a = (int*)malloc(10 * sizeof(int));
    a[5] = 23;
    printf("%d\n", a[5]);
    free(a);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>23</code></p>

<p>На первой строке мы выделили массив int-ов, состоящий из 10 элементов (не забывает домножать на размер элемента). Чтобы не было предупреждений от компилятора, необходимо перевести тип указателя из <code>void*</code> в <code>int*</code> с помощью <code>(int*)</code>. (При этом  при переводе типа с любого указателя на любой указатель значение не изменится. Для других базовых типов это не всегда так.) Далее мы можем оперировать массивом, как любым другим. На четвертой строке мы освобождаем массив.</p>

<p>Что будет, если выйти за границы динамического массива? Обычно место, в котором выделился ваш массив, это куча — большой отрезок, на операции с которым у вашей программы есть права, а у других программ нет, и в котором выделяются куски на каждый ваш вызов функции <code>malloc</code>. Если вы попытаетесь выполнить операцию за пределами массива, но попадёте в ваш отрезок кучи, то операция будет успешной. При этом эта точка может принадлежать другому массиву, который используется в вашей программе.</p>

<p>Это ещё одна коварность языка C: вы промазали по массиву, но операция выполнилась успешно, и вы повредили память, которая позже будет использоваться. В таком случае, если вы попробуете использовать <em>дебаггер</em> для определения проблемы, он покажет тот, скорее всего корректный, код, память которого была затерта, а не тот код, который затер память.</p>

<p>Если же вы попадете не в ваш отрезок кучи, то программа просто завершится из-за сигнала <em>SIGSEGV</em>.</p>

<p>Что произойдет, если вы не освободите память? На самом деле, ничего, и нет никакой проблемы не освобождать память в однопроходной программе. Вся выделенная память все равно освободится при завершении программы. Однако, если ваша программа работает длительное время, часто создавая и удаляя объекты, необходимо освобождать память, чтобы она не закончилась. Вызов функции <code>malloc</code> может вернуть <code>0</code>, что означает отказ в выделении памяти, скорее всего, по причине превышения лимита.</p><h3 id="2.4.6">2.4.6</h3><p>Найдите все возможные ошибки и утечки памяти в следующем коде:</p>

<pre><code class="language-cpp">int* foo(int x) {
    int *a = malloc(N * sizeof(int));
    if (x &lt; 0) return 0;
    int i;
    for (i = 0; i &lt; N; i++) {
        a[i] = x;
    }
    return a;
}

void boo() {
    int *a = malloc(N * sizeof(int));
    int *b = a;
    int *c = malloc(N * sizeof(int));
    a = c;
    c = b;
    b = a;
    c = b;
    free(a);
    free(b);
}

int flghm_count(int mode, int *result) {
    int status;
    int *buffer;
    status = flghm_init(buffer);
    if (!status) return -1;
    status = flghm_fill(buffer, result);
    if (!status) return -2;
    status = flghm_free(buffer);
    if (!status) return -3;
    return 0;
}
</code></pre><h3 id="2.4.7">2.4.7</h3><p>Изучим алгоритм сортировки слиянием (Merge Sort).</p>

<pre><code class="language-cpp">void merge_sort(int *a, int l, int r) {
    if (r - l == 1) return;
    int m = (l + r) / 2;
    merge_sort(a, l, m);
    merge_sort(a, m, r);
    ...
}</code></pre>

<p>Данный алгоритм является рекурсивным. Он принимает сам массив и границы подотрезка, который данному рекурсивному вызову следует отсортировать. Если длина подотрезка равна <code>1</code>, то он уже отсортирован. Если это не так, то разделим подотрезок на два меньших подотрезка и вызовем <code>merge_sort</code> от каждого из них. В результате мы получим два отсортированных подотрезка. Их необходимо <em>слить</em> в один, после чего сортировка будет завершена.</p>

<p>Здесь я использовал полуинтервалы, то есть индекс <code>r</code> не входит в подотрезок, который необходимо отсортировать. При такой реализации нет необходимости добавлять <code>+1</code> и <code>-1</code> к различным индексам границ.</p>

<p>Реализуйте алгоритм слияния. Он должен по двум отсортированным подотрезкам <code>[l, m)</code> и <code>[m, r)</code> получить один отсортированный подотрезок <code>[l, r)</code>. Здесь <code>[]</code> означают границы включительно, а <code>()</code> — не включительно.</p>

<p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Отсортируйте заданную последовательность.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 10^3\)</span>)</p>

<p>Вторая строка входных данных <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 10^6\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(b_1, b_2, \ldots, b_n\)</span> (<span class="math-tex">\(b_1 \le b_2 \le \ldots \le b_n\)</span>) — отсортированную последовательность <span class="math-tex">\(a\)</span>.</p><h3 id="2.4.8">2.4.8</h3><p>Помимо многомерных массивов можно пользоваться также многомерными указателями. Однако, как и в одномерном случае, указатели не знают форму массива. Поэтому, например, двумерный массив размера <code>n*m</code> в помощью указателей представляется как массив размера <code>n</code>, состоящий из указателей на массивы размера <code>m</code> (на самом деле, размеры этих массивов могут различаться). Динамическое выделение двумерного массива выглядит так:</p>

<pre><code class="language-cpp">int main() {
    const int n, m;
    int **a = malloc(n * sizeof(int*));
    int i;
    for (i = 0; i &lt; n; i++) {
        a[i] = malloc(m * sizeof(int));
    }
    
    a[2][3] = 12;
    printf("%d\n", a[2][3]);
    
    for (i = 0; i &lt; n; i++) {
        free(a[i]);
    }
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Обратите внимание на следующее:</p>

<ul>
	<li>Я использовал на этот раз идентификаторы <code>n</code> и <code>m</code> в качестве размера массива. Так как размер массива должен быть известен на момент компиляции, я должен объявить их как константы. Значения констант нельзя менять.</li>
	<li>Выделение памяти для массива происходит в два этапа: сначала я создаю массив указателей (поэтому домножение идет на <code>sizeof(int)</code>) размера <code>n</code>, а затем для каждого указателя создаю массив <code>int</code>-ов размера <code>m</code>. Тоже самое касается освобождения памяти.</li>
	<li>Итоговый размер массива не <code>n * m * sizeof(int)</code>, а <code>n * sizeof(int*) + n * m * sizeof(int)</code>.</li>
</ul>

<p>В отличии от локального массива, здесь отдельные ряды не идут друг за другом, а расположены так, как это сделал <code>malloc</code>. Мы можем расположить ряды массива подряд самостоятельно, но тогда нам нужно будет использовать не оператор индексации <code>[]</code>, а свою функцию.</p>

<pre><code class="language-cpp">int offset(int i, int j, int m) {
    return i * m + j;
}

int main() {
    const int n, m;
    int *a = malloc(n * m * sizeof(int));
    
    a[offset(2, 3, m)] = 12;
    printf("%d\n", a[offset(2, 3, m)]);
    
    free(a);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>12</code></p>

<p>Попробуйте самостоятельно разобраться с тем, как здесь организован массив.</p><h3 id="2.4.9">2.4.9</h3><p>Задан граф, состоящий из <span class="math-tex">\(n\)</span> вершин и <span class="math-tex">\(m\)</span> ребер. <span class="math-tex">\(i\)</span>-е ребро задается парой вершин <span class="math-tex">\((v_i, u_i)\)</span> — вершины, которые это ребро соединяет. Найдите количество компонент связности данного графа.</p>

<p>Компоненты связности — это разбиение множества вершин графа на попарно непересекающиеся подмножества такие, что для любых двух вершин в одном множестве (в одной компоненте связности) существует путь между ними, а для любых двух вершин в разных множествах не существует пути между ними.</p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит два целых числа <span class="math-tex">\(n\)</span> и <span class="math-tex">\(m\)</span> (<span class="math-tex">\(1 \le n, m \le 10^3\)</span>)</p>

<p>Следующие <span class="math-tex">\(m\)</span> строк входных данных содержат по два целых числа <span class="math-tex">\(v_i\)</span> и <span class="math-tex">\(u_i\)</span> (<span class="math-tex">\(1 \le v_i, u_i \le n\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное число — количество компонент связности в заданном графе.</p><h3 id="2.4.10">2.4.10</h3><p>Интересно, и не очень красиво, обстоят дела с указателями-константами. Рассмотрим примеры: </p>

<pre><code class="language-cpp">int main() {
    const int *n;
    int m;
    n = &amp;m;
    
    return 0;
}</code></pre>

<p> <code>const int*</code> объявляет указатель, у которого нельзя менять содержимое. Мы изменить сам указатель (то есть, адрес, на который он указывает), но не можем изменить его содержимое <code>*n = 2</code>.</p>

<pre><code class="language-cpp">int main() {
    int *const n;
    *n = 2;
    
    return 0;
}</code></pre>

<p>Здесь обратная ситуация: <code>int *const</code> позволяет менять содержимое указателя, но не позволяет изменить сам указатель <code>n += 10</code>.</p>

<p>Рассмотрим немного комичный пример:</p>

<pre><code class="language-cpp">int main() {
    const int * *const *n;
    
    n += 2;
    // *n = 2;
    **n += 2;
    // ***n += 2;
    
    return 0;
}</code></pre>

<p>Закомментированные строки нарушают правила константности и вызывают ошибку компиляции.</p><h3 id="2.4.11">2.4.11</h3><p>Мы теперь можем понять смысл типа "строки" — <code>const char*</code>. Это указатель на символ (и, соответственно, следующие символы), содержимое которого (то есть, ни первый символ, ни другие) нельзя менять.</p>

<p>Посмотрим на сигнатуру функции <code>int execv(const char *path, char *const argv[]);</code> (подробнее по <a href="https://linux.die.net/man/3/execv" rel="noopener noreferrer nofollow">ссылке</a>). Что вы можете сказать про её второй аргумент, и как это влияет на использование функции? Попробуйте вызвать эту функцию (необязательно делать что-то осмысленное, главное добиться успешной компиляции).</p><h3 id="2.5">2.5. Строки</h3><h3 id="2.5.1">2.5.1</h3><p>Представим, что мы печатаем строку, с помощью <code>scanf("%s", str);</code>. <code>str</code> — это не более, чем указатель. Как функция <code>scanf</code> понимает, где кончается строка? Она понимает это с помощью численно равного нулю символа <code>\0</code>, которым строка заканчивается. Когда мы объявляем строку, как <code>const char *str = "aba";</code>, то её длина будет составлять <code>4</code>, и последним символом в ней будет <code>\0</code>.</p>

<p>Что же будет, если мы целенаправленно избавимся от нулевого символа в конце строки? Сделать это мы можем так:</p>

<pre><code class="language-cpp">int main() {
    char a[3];
    a[0] = 'a';
    a[1] = 'b';
    a[2] = 'c';
    printf("%s\n", a);
    return 0;
}</code></pre>

<p>Вывод этой программы будет начинаться с символов <code>abc</code>. То, что пойдет далее, зависит от компилятора и его режима. Здесь происходит довольно простая и очевидная вещь: функция <code>scanf</code> печатает символ за символом, пока не наткнется на нулевой символ где-то дальше за строкой в памяти. В зависимости от того, где расположена строка, это также может вызвать ошибку исполнения, если нулевого символа не найдется вплоть до конца доступной программе памяти.</p>

<p>Из-за такой особенности работа со строками в языке C довольно неприятна. Необходимо всегда помнить о лишнем символе.</p>

<p>Рассмотрим первую стандартную функцию для работы со строками: <code>size_t strlen( const char* str );</code>. С помощью этой функции мы определяем длину строки (не включая нулевой символ). Написать эту функцию очень просто, вот её реализация:</p>

<pre><code class="language-cpp">size_t strlen( const char* str ) {
    const char *x = str;
    while (*x != '\0') {
        x++;
    }
    return x - str;
}</code></pre>

<p>Чтобы проверить эту реализацию, функцию необходимо будет переименовать, либо убрать <code>glibc</code>.</p>

<p>Для использования стандартных функций для работы со строками часто необходимо добавить <code>#include &lt;string.h&gt;</code>.</p><h3 id="2.5.2">2.5.2</h3><p>При выполнении данной программы происходит ошибка исполнения, хотя строка не является константой, и компиляция проходит успешно. (Возможно, наблюдается не на всех компиляторах.) Почему? </p>

<pre><code class="language-cpp">int main() {
    char *a = "abacaba";
    a[3] = 'b';
    
    return 0;
}</code></pre><h3 id="2.5.3">2.5.3</h3><p>Функция <code>int sprintf( char* buffer, const char* format, ... );<span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span><span style=""> </span></code> работает, как функция <code>printf</code>, но она принимает своим первых аргументом строку <code>buffer</code>, в которую и происходит печать. При этом содержимое строки <code>buffer</code>  никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    char str[100];
    sprintf(str, "%d %d", 32, 85);
    printf("%s\n", str);
}</code></pre>

<p>Вывод этой программы: <code>32 85</code></p>

<p>Функция <code>char *strcpy( char *dest, const char *src );</code> выполняет копирование строки из второго аргумента в первый (поэтому тип первого аргумента лишен <code>const</code>). Копирование выполняется до обнаружения нулевого символа в <code>src</code>. При этом содержимое строки <code>dest</code> никак не проверяется на переполнение.</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>abacaba</code></p>

<p>Обратите внимание, что функция <code>strcpy</code> закладывает нулевой символ в конец строки <code>dest</code>. Не забывайте оставлять под него место.</p>

<p>Часто необходимо ограничить длины копируемой строки. Вместо добавления <code>if</code>-а можно использовать стандартную функцию <code>char *strncpy( char *dest, const char *src, size_t count );</code>, которая копирует не более <code>count</code> символов, <strong>включая нулевой символ</strong> (то есть, может оставить строку без нуля на конце).</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[4];
    strncpy(b, a, 3);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>aba</code></p>

<p>Вообще, "n" версии есть у почти каждой строковой функции. Посмотрите функцию <code>strnlen</code>.</p><h3 id="2.5.4">2.5.4</h3><p>Функция <code>int strcmp( const char* lhs, const char* rhs );</code> сравнивает две строки <em>лексикографически</em>.</p>

<blockquote>
<h3>Return value</h3>

<p>Negative value if lhs appears before rhs in lexicographical order.</p>

<p>Zero if lhs and rhs compare equal.</p>

<p>Positive value if lhs appears after rhs in lexicographical order.</p>
</blockquote>

<p>Обратите внимание, что упоминается лишь знак возвращаемого значения. Само же значение не задокументировано.</p>

<p>Так мы проверяем две строки на равенство:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "aba";
    const char *b = "baba";
    const char *c = "aba";
    printf("%d\n", strcmp(a, b));
    printf("%d\n", strcmp(b, a));
    printf("%d\n", strcmp(a, c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>-1 1 0 </code></p>

<p>Перевести строку в число можно с помощью функции <code>int atoi( const char* str );</code>.(В случае некорректной строки она возвращает <code>0</code>.)</p>

<pre><code class="language-cpp">int main() {
    printf("%d\n", atoi("5328"));    
    return 0;
}</code></pre>

<p>Часто необходимо проводить копирование в динамическую строку (вообще, часто приходится работать и с динамическими строками). Вместо такого:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    int n = strlen(a);
    char *b = (char*)malloc((n + 1) * sizeof(char));
    strcpy(b, a);
    printf("%s\n", b);
    return 0;
}</code></pre>

<p>, можно использовать функцию <code>char * strdup( const char *str1 );</code>, которая делает то же самое: <code>char *b = strdup(a);</code>.</p><h3 id="2.5.5">2.5.5</h3><p>Реализуется функции <code>strcpy</code>, <code>strncpy</code>, <code>strcmp</code> и <code>strncmp</code> так, как ранее была реализована функция <code>strlen</code>. Добавьте в начало из названия символ <code>_</code>, чтобы не было конфликтов имен.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    const char *a = "abacaba";
    char b[10];
    _strcpy(b, a);
    assert(strcmp(b, "abacaba") == 0);
    b[3] = '\0';
    _strncpy(b, a, 3);
    assert(strcmp(b, "aba") == 0);
    assert(_strcmp("aba", "aba") == 0);
    assert(_strcmp("aba", "abc") &lt; 0);
    assert(_strcmp("abc", "aba") &gt; 0);
    assert(_strncmp("aba", "abc", 2) == 0);
    assert(_strncmp("aba", "abc", 3) &lt; 0);
    return 0;
}</code></pre><h3 id="2.5.6">2.5.6</h3><p>Следующая функция  <code>char* strtok( char* str, const char* delim );</code> более сложная в использовании. Эта функция используется для разбиения строки <code>str</code> на токены. Аргумент <code>delim</code> хранит символы-разделители токенов. Рассмотрим программу:</p>

<pre><code class="language-cpp">#define NULL 0

int main() {
    char str[] = "ab;cde,fghi";
    
    char *a = strtok(str, ",;");
    printf("%d ", strlen(str));
    printf("%d ", strlen(a));
    
    char *b = strtok(NULL, ",;");
    printf("%d ", strlen(b));
    
    char *c = strtok(NULL, ",;");
    printf("%d ", strlen(c));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>2 2 3 4</code></p>

<p>Пусть разделителями будут символы <code>,</code> и <code>;</code>. Сначала выполним такой вызов функции: <code>strtok(str, ",;");</code>. В результате этого вызова вместо первого разделителя в изначальной строке <code>;</code> будет поставлен нулевой символ, будет возвращен указатель на первый символ, не являющийся разделителем (а наша строка не начинается с разделителей, поэтому будет возвращен <code>str</code>) , а внутри функции <code>strtok</code> будет неким образом создана запись о том, какой последний символ был обработан.</p>

<p>Затем выполним вызов <code>strtok(NULL, ",;");</code>. В результате этого вызова повторятся те же действия, но не с аргумента (который теперь просто <code>0</code>), а с последнего обработанного символа (видимо, с того, который стал нулевым, но это уже нам неизвестно). Сначала пропустятся следующие два разделителя <code>;</code> до первого, не разделительного символа <code>c</code>. Затем будет найден следующий разделительный символ <code>,</code> и заменен на нулевой символ. И наконец, будет возвращён указатель на символ <code>c</code>.</p>

<p>Строка <code>#define NULL 0</code> заменяет все вхождения идентификаторов <code>NULL</code> в нижестоящем коде на <code>0</code> до компиляции программы. Но об этом мы поговорим позже.</p><h3 id="2.5.7">2.5.7</h3><p>Напишите функцию <code>int strsum(const char *str);</code>, которая принимает строку, состоящую из последовательности целых чисел и пробелов, и возвращает сумму чисел в этой строке.</p>

<p>Подставьте следующую функцию <code>main</code>:</p>

<pre><code class="language-cpp">int main() {
    assert(strsum("123") == 123);
    assert(strsum("-6") == -6);
    assert(strsum("  2  2    3 ") == 7);
    assert(strsum("  -6  24    -7 ") == 11);
    return 0;
}</code></pre><h3 id="2.5.8">2.5.8</h3><p>Для выполнения таких же операций с массивами любого типа используются <code>mem***</code> функции. Естественно, функции <code>memlen</code> нет, так как только строки завершаются нулём. Не забывайте о том, что размер массива принимается в байтах, поэтому нужно домножать количество элементов на размер одного элемента.</p>

<p>Функция <code>void *memset(void *buf, int ch, size_t count)</code> устанавливает <code>len</code> байт массива <code>buf</code> равными младшему байту числа <code>ch</code> (старшие байты при этом игнорируются).</p>

<pre><code class="language-cpp">int main() {
    int a[4];
    memset(a, 0x1234, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", a[i]);
    }
    printf("%d", 0x34343434);
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>875836468 875836468 875836468 875836468 875836468</code></p>

<p>Функция <code>void *memcpy(void *dest, const void *source, size_t count)</code> копирует <code>count</code> байт массива <code>source</code> в массив <code>dest</code>.</p>

<pre><code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4];
    memcpy(b, a, 4 * sizeof(int));
    int i;
    for (i = 0; i &lt; 4; i++) {
        printf("%d ", b[i]);
    }
    
    return 0;
}</code></pre>

<p>Вывод этой программы будет состоять из четырёх чисел, первый три из которых: <code>1 2 3</code></p>

<p>Функция <code>int memcmp(const void *buf1, const void *buf2, size_t count)</code> сравнивает первые <code>count</code> элементов массивов <code>buf1</code> и <code>buf2</code> лексикографически так же, как и функция <code>strcmp</code>.</p>

<pre><code class="language-cpp">int main() {
    int a[4] = {1, 2, 3, 4};
    int b[4] = {1, 2, 3, 5};
    printf("%d ", memcmp(a, b, 3 * sizeof(int)));
    printf("%d ", memcmp(a, b, 4 * sizeof(int)));
    
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>0 -1</code></p>

<p>Следует отдавать предпочтение <code>mem***</code> функциям, так как они используют специальные ассемблерные инструкции (которые мы ещё увидим), и потому более быстрые. (Хотя <code>str***</code> функции в то же время тоже имеют некоторые хитрые оптимизации, связанные с итерированием не по одному символу, а по машинному слову. Но это не так сильно влияет.)</p><h3 id="2.6">2.6. Структуры</h3><h3 id="2.6.1">2.6.1</h3><p>Один байт состоит из восьми бит. Бит принимает одно из двух значений: <code>0</code> или <code>1</code>. Поэтому один байт может принимать <span class="math-tex">\(2^8 = 256\)</span> различных значений.</p>

<p>Рассмотрим, как переводить числа из двоичной в десятичную систему счисления. Мы будем указывать менее значимые цифры справа. (Хотя это и не важно, и часто для удобства менее значимые цифры размещают слева.)</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>0</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>1</code></td>
			<td><code>1</code></td>
		</tr>
		<tr>
			<td><code>10</code></td>
			<td><code>2</code></td>
		</tr>
		<tr>
			<td><code>11</code></td>
			<td><code>3</code></td>
		</tr>
		<tr>
			<td><code>100</code></td>
			<td><code>4</code></td>
		</tr>
		<tr>
			<td><code>101</code></td>
			<td><code>5</code></td>
		</tr>
		<tr>
			<td><code>110</code></td>
			<td><code>6</code></td>
		</tr>
		<tr>
			<td><code>111</code></td>
			<td><code>7</code></td>
		</tr>
		<tr>
			<td><code>1000</code></td>
			<td><code>8</code></td>
		</tr>
	</tbody>
</table>

<p>В общем случае, если <span class="math-tex">\(i\)</span>-й бит числа в двоичной записи равен <span class="math-tex">\(a_i\)</span>, в десятичной записи оно будет равно <span class="math-tex">\(a_0 \cdot 1 + a_1 \cdot 2 + a_2 \cdot 4 + a_3 \cdot 8 + \ldots = \sum{a_i \cdot 2^i}\)</span></p>

<p>Целочисленные типы данных бывают знаковыми (signed) и беззнаковыми (unsigned). Беззнаковые типы принимают значение от <span class="math-tex">\(0\)</span> (когда все биты нулевые) до <span class="math-tex">\(2^{size} - 1\)</span> (когда все биты единицы), где <span class="math-tex">\(size\)</span> — это размер типа данных в битах. Так, максимальное значение типа <code>unsigned int</code> равно <span class="math-tex">\(2^{32} - 1 = 4294967295\)</span>.</p>

<p>Знаковые типы принимают значение от <span class="math-tex">\(-2^{size - 1}\)</span> до <span class="math-tex">\(2^{size - 1} - 1\)</span>. Как кодируются отрицательные числа покажем на примере типа <code>char</code>.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td>Двоичная система счисления</td>
			<td>Десятичная система счисления</td>
		</tr>
		<tr>
			<td><code>00000000</code></td>
			<td><code>0</code></td>
		</tr>
		<tr>
			<td><code>11111111</code></td>
			<td><code>-1</code></td>
		</tr>
		<tr>
			<td><code>11111110</code></td>
			<td><code>-2</code></td>
		</tr>
		<tr>
			<td><code>11111101</code></td>
			<td><code>-3</code></td>
		</tr>
		<tr>
			<td><code>11111100</code></td>
			<td><code>-4</code></td>
		</tr>
	</tbody>
</table>

<p>Переводить число из <code>n</code>-й системы счисления в десятичную можно с помощью формулы <span class="math-tex">\(\sum{a_i \cdot n^i}\)</span>. Чтобы писать в коде числа в двоичном, восмеричном и шестнадцатиричном формате, следует перед ними написать <code>0b</code>, <code>0</code> и <code>0x</code> соответственно. Формат <code>%d</code>выполнит печать в десятичном формате, но <code>printf</code> также имеет форматы и для других систем счисления.</p>

<pre><code class="language-cpp">int main() {
    printf("%d %d %d\n", 0b1010, 013, 0xC);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>10 11 12</code></p><h3 id="2.6.2">2.6.2</h3><p>Для манипуляций с битами чисел используются битовые операторы. Они взаимодействуют на каждую позицию чисел-аргументов независимо и действуют аналогично одноименным логическим операторам.</p>

<ul>
	<li><code>&amp;</code> — оператор И. Например, <code>0b10110 &amp; 0b11010 = 0b10010</code>.</li>
	<li><code>|</code> — оператор ИЛИ. Например, <code>0b10101 | 0xb11001 = 0x11101</code>.</li>
	<li><code>^</code> — оператор исключающее ИЛИ. Например, <code>0x1001 ^ 0x1100 = 0x0101</code>.</li>
	<li><code>~</code> — унарный оператор НЕ. Например, для типа <code>char</code>, <code>~0b1010 = 0b11110101</code>. (Обратите внимание на зависимость от размера типа данных.)</li>
	<li><code>&lt;&lt;</code> — оператор сдвига числа налево (в сторону увеличения числа). Например, <code>0b1001 &lt;&lt; 2 = 0b100100</code>. Сдвиг не циклический. Если никакие единичные биты не пропадают, то <code>a &lt;&lt; b</code><span class="math-tex">\(= a \cdot 2 ^ b\)</span>.</li>
	<li><code>&gt;&gt;</code> — оператор сдвига числа направо (в сторону уменьшения числа). Например, <code>0b1001 &gt;&gt; 2 = 0b10</code>. Сдвиг не циклический. <code>a &gt;&gt; b</code><span class="math-tex">\(= \lfloor \frac{a}{2^b} \rfloor\)</span>.</li>
</ul>

<p>Проверить наличие <code>i</code>-го бита в числе можно так: <code>if (a &amp; (1 &lt;&lt; i))</code>.</p>

<p>Битовые операторы имеют неочевидные приоритеты. Например, если вы хотите проверить, что <code>i</code>-й бит отсутствует, то такая проверка <code>if (a &amp; (1 &lt;&lt; i) == 0)</code> некорректна, так как оператор сравнения выполнится до оператора битового И.</p>

<p>Если вы проверяете наличие <code>i</code>-го бита в числе типа <code>long long</code>, то следует делать сдвиг так: <code>1ll &lt;&lt; i</code>. Суффикс <code>ll</code> делает число <code>1</code> типа <code>long long</code>. Если же не приписать этот суффикс и проверить, например, <code>40</code>-й бит, то сначала выполнится сдвиг числа <code>1</code> типа <code>int</code> на <code>40</code> позиций, в результате чего получится ноль, который затем будет переведен в тип <code>long long</code>.</p>

<p>Подобные суффиксы есть и у других типов. Дробные числа, записанные так — <code>4.3</code> — имеют тип <code>double</code>, а не <code>float</code>, что не позволит написать, например, так: <code>const float a = 4.3;</code>(возможно, не во всех компиляторах). Числа типа <code>float</code> следует завершать символом <code>f</code>.</p><h3 id="2.6.3">2.6.3</h3><p>Дана последовательность целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> длины <span class="math-tex">\(n\)</span>. Найдите минимальный размер такого множества чисел <span class="math-tex">\(b_1, b_2, \ldots, b_m\)</span>, что <span class="math-tex">\(a_{b_1} | a_{b_2} | \ldots | a_{b_m} = a_1 | a_2 | \ldots | a_n\)</span></p>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(n\)</span> (<span class="math-tex">\(1 \le n \le 20\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(n\)</span> целых чисел <span class="math-tex">\(a_1, a_2, \ldots, a_n\)</span> (<span class="math-tex">\(1 \le a_i \le 2^{30} - 1\)</span>)</p>

<h4>Формат вывода</h4>

<p>Выведите единственное целое число <span class="math-tex">\(m\)</span> — минимальный размер подходящего множества.</p><h3 id="2.6.4">2.6.4</h3><p>Рассмотрим перевод дробного числа из двоичной записи в десятичную. Здесь используется та же формула, но теперь она распространяется и на отрицательные индексы.<span class="math-tex">\(0b10.1011 = 1 \cdot 2^1 + 0 \cdot 2^0 + 1 \cdot 2^{-1} + 0 \cdot 2^{-2} + 1 \cdot 2^{-3} + 1 \cdot 2^{-4} = 2 + 0 + 0.5 + 0 + 0.125 + 0.0625 = 2.6875\)</span></p>

<p>Рассмотрим структуру стандартного типа данных с плавающей точкой: <code>float</code>. Он состоит из <code>32</code>-х бит:</p>

<ul>
	<li>1 бит — знак, как у целых чисел</li>
	<li>2-9 биты — порядок (exponent)</li>
	<li>10-32 биты — мантисса (fraction)</li>
</ul>

<p>Порядок кодируется таким же образом, как и целое беззнаковое число. Обозначим его как <span class="math-tex">\(A\)</span>. Мантисса кодирует дробное число, меньшее единицы: первый бит кодирует <span class="math-tex">\(\frac{1}{2}\)</span>, второй бит кодирует <span class="math-tex">\(\frac{1}{4}\)</span> и так далее. Обозначим его как <span class="math-tex">\(B\)</span>. Тогда значение числа равно <span class="math-tex">\(2^{A - 127} \cdot (1 + B)\)</span></p>

<p>Посмотрим на такое значение типа <code>float</code>: <code>0 01111100 01000000000000000000000</code></p>

<ul>
	<li>Первый бит равен <code>0</code>, поэтому число неотрицательное.</li>
	<li>В порядке стоит число <span class="math-tex">\(A = 0 \cdot 2^7 + 1 \cdot 2^6 + 1 \cdot 2^5 + 1 \cdot 2^4 + 1 \cdot 2^3 + 1 \cdot 2^2 + 0 \cdot 2^1 + 0 \cdot 2^0 = 124\)</span></li>
	<li>В мантиссе стоит число <span class="math-tex">\(B = 0 \cdot \frac{1}{2^1} + 1 \cdot \frac{1}{2^2} + 0 \cdot \frac{1}{2^3} + 0 \cdot \frac{1}{2^4} + \ldots = 0.25\)</span></li>
	<li>Итого данное число равно <span class="math-tex">\(2^{124 - 127} \cdot (1 + 0.25) = 0.15625\)</span></li>
</ul>

<p>Есть отдельные два случая:</p>

<ul>
	<li>Если <span class="math-tex">\(A = 0\)</span>, то формула выглядит так: <span class="math-tex">\(2^{A - 127} \cdot B\)</span></li>
	<li>Если <span class="math-tex">\(A = 255\)</span>, то это особое число, соответствующее, например, бесконечности или <code>nan</code> (not a number), которые возникают при некоторых некорректных математических операциях. Чтобы проверить число на <code>nan</code> следует сравнить его с собой: <code>if (x != x) { "x is nan" }</code>.</li>
</ul>

<p>Чтобы использовать тип <code>float</code> в функциях <code>printf</code> и <code>scanf</code>, следует использовать формат <code>%f</code>.</p>

<p>Существуют и другие типы чисел с плавающей точкой:</p>

<ul>
	<li><code>double</code> — 8 байт</li>
	<li><code>long double</code> — не определено (обычно 10 байт)</li>
</ul><h3 id="2.6.5">2.6.5</h3><p>Ранее я рассказывал об отдельном способе кодирования числа типа <code>float</code>, когда его показатель равен нулю. Зачем это необходимо?</p><h3 id="2.6.6">2.6.6</h3><p>Перечисления (enumerations) — это способ задать числам идентификатор, привязав их при этом к контексту. Рассмотрим программу:</p>

<pre><code class="language-cpp">enum E {
    A,
    B,
    C = 10,
    D,
    E
};

int main() {
    enum E e = A;
    printf("%d %d %d %d %d %d\n", A, B, C, D, E, e);
    return 0;
}</code></pre>

<p>Мы объявляем перечисление с помощью ключевого слова <code>enum</code>, затем мы даем ему название <code>E</code> и в фигурных скобках перечисляем значение. Сами значения в перечислении используются так же, как и переменные типа число-константа <code>const int</code>. Эти значения мы можем вывести без ограничений, как и если бы это были константы. Посмотрите на логику присваивания значений им. Мы можем также объявлять объекты или инстансы (instances) перечисления, указывая их тип как <code>enum E</code>. Этот тип это всего лишь число.</p>

<p>Вывод этой программы: <code>0 1 10 11 12 0</code></p>

<p>Здесь может возникнуть вопрос: а где же привязка к контексту (названию перечисления), ведь их содержимое ведет себя как глобальные переменные? Этой привязки нет, что является недостатком перечислений в языке C. Тем не менее, в C++ были введены классы перечислений (enum classes), которые решают этот недостаток.</p>

<p>Перейдем к структурам (structures). Они необходимы для объединения группы переменных для того, чтобы манипулировать ими одновременно. В отличии от массивов, типы переменных в структурах разные, и их количество сильно ограничено.</p>

<pre><code class="language-cpp">struct S {
    int a;
    long long b;
};

int main() {
    struct S s1;
    s1.a = 4;
    s1.b = 7;
    printf("%d %d ", s1.a, s1.b);
    
    struct S *s2 = (struct S*)malloc(sizeof(struct S));
    (*s2).a = 12;
    s2-&gt;b = 17;
    printf("%d %d\n", s2-&gt;a, s2-&gt;b);
    free(s2);
    
    return 0;
}</code></pre>

<p>Мы объявляем структуру с помощью ключевого слова <code>struct</code>, следом за которым указываем название структуры и её содержимое в фигурных скобках. Объект или инстанс структуры объявляются с указыванием типа <code>struct S</code> и названия структуры: <code>struct S s1;</code>. Как только мы объявили этот объект, у нас появились сразу две связанные переменные, к которым мы обращаемся через идентификатор <code>struct</code>.  Хоть структуры и является сложным типом, их можно передавать в функции и возвращать из них. К полям (field) структуры мы обращаемся через символ <code>.</code>.</p>

<p>Можно объявлять объекты структуры динамически. Тогда, чтобы получить доступ к полям структуры, необходимо выполнить разыменование. Так как это распространенное действие (вы даже чаще будете взаимодействовать именно с указателями на структуры), для него есть свой синтаксис <code>-&gt;</code>.</p><h3 id="2.6.7">2.6.7</h3><p>Есть последовательность чисел, которая изначально состоит из единственного числа <span class="math-tex">\(0\)</span>, указатель, который изначально указывает на первую позицию последовательности, и счетчик <span class="math-tex">\(x\)</span>, изначально равный <span class="math-tex">\(1\)</span>.</p>

<p>Необходимо обработать <span class="math-tex">\(q\)</span> запросов четырех типов:</p>

<ol>
	<li>Сдвинуть указатель налево. Перед этим действием указатель находится не на первой позиции.</li>
	<li>Сдвинуть указатель направо. Перед этим действием указатель находится не на последней позиции.</li>
	<li>Вставить элемент <span class="math-tex">\(x\)</span> после указателя, а затем увеличить значение <span class="math-tex">\(x\)</span> на единицу.</li>
	<li>Удалить элемент, на который указывает указатель, сдвинув его на предыдущий элемент. Перед этим действием указатель находится не на первой позиции.</li>
</ol>

<h4>Формат ввода</h4>

<p>Первая строка входных данных содержит одно целое число <span class="math-tex">\(q\)</span> (<span class="math-tex">\(1 \le q \le 1000\)</span>)</p>

<p>Вторая строка входных данных содержит <span class="math-tex">\(q\)</span> целых чисел <span class="math-tex">\(k_1, k_2, \ldots, k_q\)</span> (<span class="math-tex">\(1 \le k_i \le 4\)</span>) — запросы, которые необходимо обработать. Гарантируется, что запросы удовлетворяют ограничениям, указанным в условии.</p>

<h4>Формат вывода</h4>

<p>Выведите последовательность чисел после выполнения всех запросов.</p><h3 id="2.6.8">2.6.8</h3><p>Один из способов изменить битовую запись числа типа <code>float</code> напрямую следующий:</p>

<pre><code class="language-cpp">int main() {
    float a;
    int *b = (int*)(&amp;a);
    *b = 0x3FFFFFFF;
    printf("%f\n", a);
    return 0;
}</code></pre>

<p>(Попробуйте самостоятельно выяснить, какое число будет выведено.)</p>

<p>В C++ подобные манипуляции можно делать с помощью оператора <code>reinterpret_cast</code>. В C также можно сделать это с помощью объединений <code>union</code>.</p>

<p>Объединение реализует сумму типов (sum types), то есть её содержимое является одним из нескольких типов. Однако, в силу простоты языка C и того, как в нем объединения реализованы:</p>

<ul>
	<li>Узнать, какой тип храниться в конкретном объекте объединения, без дополнительной информации невозможно.</li>
	<li>Само обращение к объединению является лишь приведением одного и того же адреса в тип, который мы запрашиваем.</li>
</ul>

<p>Таким образом, объединения отличаются от просто приведения типа тем, что выбор типов ограничен, и у них есть псевдонимы.</p>

<pre><code class="language-cpp">union U {
    float a;
    int b;
};

int main() {
    union U u;
    u.b = 0x3FFFFFFF;
    printf("%f\n", u.a);
    return 0;
}</code></pre>

<p>Можно типам данных давать псевдонимы. Например, если мы напишем <code>typedef int i32;</code>, то мы сможем, написав <code>i32</code> создать переменную типа <code>int</code>: <code>i32 a = 3;</code>.</p>

<p>К перечислениям, структурам и объединения можно применять такой синтаксис:</p>

<pre><code class="language-cpp">typedef int i32;

typedef struct {
    i32 a;
} S;

int main() {
    S s;
    s.a = 7;
    return 0;
}</code></pre>

<p>При таком объявлении структуры мы не должны писать ключевое слово <code>struct</code> в типе.</p><h3 id="2.7">2.7. Функции высшего порядка, макросы, шаблоны</h3><h3 id="2.7.1">2.7.1</h3><p>В C можно передавать в функции указатели на другие функции, чтобы строить функции высших порядков.</p>

<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

int apply(int x, int(*f)(int)) {
    return f(x);
}

int main() {
    printf("%d\n", apply(5, square));
    return 0;
}</code></pre>

<p>Функция <code>square</code> возвращает квадрат аргумента и интереса не представляет. Посмотрим на второй аргумент функции <code>apply</code>. Тип этого аргумента — <code>int(*)(int)</code> — указатель на функцию, которая принимает один аргумент типа <code>int</code>, и возвращает тип <code>int</code>. <code>f</code> — это название аргумента. Функция <code>apply</code> применяет свой второй аргумент к первому аргументу.</p>

<p>Указатели на функции можно объявлять и как обычные локальные переменные.</p>

<pre><code class="language-cpp">int square(int x) {
    return x * x;
}

int main() {
    int(*foo)(int) = square;
    printf("%d\n", foo(5));
    return 0;
}</code></pre>

<p>Выводы обеих программ — <code>25</code></p>

<p>Указатели на функции обычно используются для двух целей:</p>

<ul>
	<li>Создание функций высшего порядка</li>
	<li>Создание наследования</li>
</ul><h3 id="2.7.2">2.7.2</h3><p>В языке C нет синтаксиса для создания вложенных функций (объявления функции в теле другой функции). Как можно добиться похожего функционала?</p><h3 id="2.7.3">2.7.3</h3><p>До компиляции программы выполняется её препроцессирование, которое заключается в выполнении всех строк, которые начинаются с символа <code>#</code>. Помимо включения файлов с помощью <code>#include</code>, препроцессор даёт возможность писать макросы. Макросы могут напоминать функции, но у них есть и различия.</p>

<pre><code class="language-cpp">#define FOO 5
#define DOUBLE1(x) (x * 2)
#define DOUBLE2(x) ((x) * 2)

int main() {
    printf("%d ", FOO);
    printf("%d ", DOUBLE1(4 + 1));
    printf("%d\n", DOUBLE2(4 + 1));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>5 6 10</code></p>

<p><code>#define</code> выполняет подстановку своего третьего аргумента заместо второго в каждом его вхождении в программу. Например, все вхождения <code>FOO</code> заменятся на <code>5</code>. Макросы могут иметь аргументы, которые будут также подставлены без каких либо изменений.</p>

<p>Здесь сразу обратите внимание на второе число в выводе и попробуйте самостоятельно понять, почему в результате получилось оно.</p>

<p>Чтобы это понять, раскроем макрос вручную: <code>DOUBLE1(4 + 1) -&gt; {x = "4 + 1"} -&gt; (4 + 1 * 2) = 6</code>. Это одна из главных проблем использования макросов — необходимость продумывать, как будет выполнено раскрытие. Конкретно эта проблема решается заключение аргумента макроса в скобки, чтобы сначала выполнить вычисление аргумента. Однако, не всегда решение подобных проблем простое и вообще возможное.</p>

<p>Чем макрос может быть хорош по сравнению с функцией? Он может позволить создавать подобие функции для обобщенного типа (то есть, без уточнения типа). Например, обычно с помощью макроса реализовывают функции <code>min</code> и <code>max</code>.</p>

<pre><code class="language-cpp">#define MIN(X, Y) \
    (X &lt; Y) ? X : Y

int main() {
    printf("%d %d\n", MIN(3, 5), MIN('b', 'a'));
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>3 97</code></p>

<p>Символ <code>\</code> продолжает действие конструкции препроцессора на следующую строку. Здесь мы с помощью тернарного оператора написали подобие функции, которое на самом деле будет просто подставлять в код выражение с тернарным оператором: <code>MIN(3, 5) -&gt; {X = 3, Y = 5} -&gt; (3 &lt; 5) ? 3 : 5</code>.</p>

<p>Если требуется в макросе выполнить последовательность действий, обычно делают так:</p>

<pre><code class="language-cpp">#define PRINT(X, Y)        \
    {                      \
        printf("%d ", X);  \
        printf("%d\n", Y); \
    }

int main() {
    PRINT(4, 7)
    return 0;
}</code></pre>

<p>Вывод этой программы — <code>4 7</code></p><h3 id="2.7.4">2.7.4</h3><p>В языке C нет встроенных способов создания функций для обобщенных типов. Мы можем написать макрос, который будет объявлять функцию для заданного типа (ведь в качестве аргументов макроса можно использовать не только значение). Однако до определенного стандарта в языке C не было автоматического определения функции на основе типа. (В языке C++ для этого есть перегрузка функций. Как она работает, и почему она отсутствует в языке C, мы узнаем позже.)</p>

<p>Есть разные способы организации функции для обобщенных типов, и в разных проектах используются разные. Вот один из способов.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#define SIZE(X) \
        sizeof(X) / sizeof(X[0])
        
typedef struct {
    int x;
} S;

typedef struct {
    int x;
} T;

T foo(S s) {
    T t;
    t.x = s.x * 2;
    return t;
}

int boo(int x) {
    return x + 1;
}

#define MAP(F, A, B)                    \
B* F(B(*f)(A), A* l1, int sz) {         \
    B* l2 = (B*)malloc(sz * sizeof(B)); \
    for (int i = 0; i &lt; sz; i++) {      \
        l2[i] = f(l1[i]);               \
    }                                   \
    return l2;                          \
}

MAP(map_ii, int, int)
MAP(map_st, S, T)

int main() {
    int i;
    int lst1[4] = {1, 4, 6, 11};
    int *lst1_out = map_ii(boo, lst1, SIZE(lst1));
    for (i = 0; i &lt; SIZE(lst1); i++) {
        printf("%d ", lst1_out[i]);
    }
    printf("\n");
    
    S lst2[4] = {{1}, {3}, {5}, {9}};
    T *lst2_out = map_st(foo, lst2, SIZE(lst2));
    for (i = 0; i &lt; SIZE(lst2); i++) {
        printf("%d ", lst2_out[i].x);
    }
    printf("\n");
    
    return 0;
}</code></pre>

<p>Реализуем функцию <code>map</code> из функциональных языков, которая принимает функцию и массив элементов, после чего создает новый массив, полученный поэлементным применением функции к исходному массиву. Посмотрим на сам макрос:</p>

<pre><code class="language-cpp">#define MAP(F, A, B)                    \
B* F(B(*f)(A), A* l1, int sz) {         \
    B* l2 = (B*)malloc(sz * sizeof(B)); \
    for (int i = 0; i &lt; sz; i++) {      \
        l2[i] = f(l1[i]);               \
    }                                   \
    return l2;                          \
}</code></pre>

<p>Макрос принимает название функции <code>F</code>, которую следует объявить, и входной и выходной типы <code>A</code> и <code>B</code>. Сигнатура функции выглядит так: <code>B* F(B(*f)(A), A* l1, int sz)</code>, то есть она принимает функцию из типа <code>A</code> в тип <code>B</code> и массив типа <code>A</code> с его размером, а возвращает массив типа <code>B</code>. То есть, функция <code>map</code> параметризована двумя типами.</p>

<p>Мы создаем функцию <code>map</code> для типов <code>int</code> и <code>int</code> так: <code>MAP(map_ii, int, int)</code>. После раскрытия макроса вручную мы получим такое:</p>

<pre><code class="language-cpp">int* map_ii(int(*f)(int), int* l1, int sz) {
    int* l2 = (int*)malloc(sz * sizeof(int));
    for (int i = 0; i &lt; sz; i++) {
        l2[i] = f(l1[i]);
    }
    return l2;
}</code></pre>

<p>Обратите внимание на то, что <code>map</code> не освобождает входной массив. Следует ли это делать зависит от вашего стиля создания функций обобщенных типов.</p>

<p>Вызвать функцию <code>map</code> для типов <code>int</code> и <code>int</code> мы можем так: <code>map_ii(boo, lst1, SIZE(lst1));</code>. К сожалению, нам необходимо самостоятельно подбирать правильное название функции на основе типа. В более современном языка C есть ключевое слово <code>_Generic</code>, которое выполняет эту работу за нас.</p>

<p>Вывод этой программы:</p>

<pre><code>2 5 7 12 
2 6 10 18 
</code></pre><h3 id="2.7.5">2.7.5</h3><p>Реализуйте с помощью макроса функцию <code>zip</code>, которая принимает вторым и третьим аргументом массивы типа <code>A</code> и <code>B</code>, а первым аргументом [функцию, которая принимает два аргумента типа <code>A</code> и <code>B</code>, и возвращает тип <code>C</code>], и создает новый массив, полученный поиндексным применением функции к элементам массивов (первый к первому, второй ко второму и т.д.). Подставьте эту программу.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;assert.h&gt;

#define SIZE(X) \
        sizeof(X) / sizeof(X[0])
        
typedef struct {
    int x;
} S;

typedef struct {
    int x;
} T;

typedef struct {
    int x;
} U;

U doo(S s, T t) {
    U u;
    u.x = s.x * t.x;
    return u;
}

ZIP(zip_stu, S, T, U);

int main() {
    int i;
    S lst1[4] = {{1}, {3}, {5}, {9}};
    T lst2[4] = {{2}, {6}, {10}, {17}};
    U *lst3 = zip_stu(doo, lst1, lst2, SIZE(lst1));
    assert(lst3[0].x == 2);
    assert(lst3[1].x == 18);
    assert(lst3[2].x == 50);
    assert(lst3[3].x == 153);
    
    return 0;
}</code></pre><h3 id="2.7.6">2.7.6</h3><p>Указатели на функции дают возможность сделать подобие наследования. Мы можем написать функции-конструкторы, которые будут подставлять в объекты структур указатели на необходимые функции. Однако, функции через указатели не могут видеть содержимое структур, поэтому придется передавать объект структуры вместе с каждым вызовом её функции вручную. (На самом деле, в языке C++ указатель на объект, функция которого вызывается, всегда передается в функцию и называется <code>this</code>.)</p>

<pre><code class="language-cpp">#include &lt;stdlib.h&gt;

const float pi = 3.14f;

struct Figure;

typedef struct {
    float x;
    float (*square)(struct Figure*);
} Figure;

float circle_square(Figure *f) {
    return pi * f-&gt;x * f-&gt;x;
}

float square_square(Figure *f) {
    return f-&gt;x * f-&gt;x;
}

Figure *build_circle(float x) {
    Figure *f = (Figure*)malloc(sizeof(Figure));
    f-&gt;x = x;
    f-&gt;square = circle_square;
    return f;
}

Figure *build_square(float x) {
    Figure *f = (Figure*)malloc(sizeof(Figure));
    f-&gt;x = x;
    f-&gt;square = square_square;
    return f;
}

int main() {
    Figure *circle = build_circle(3);
    Figure *square = build_square(3);
    printf("%f %f\n", circle-&gt;square(circle), square-&gt;square(square));
    
    return 0;
}</code></pre>

<p>Функции <code>circle_square</code> и <code>square_square</code> — это соответствующие реализации функции <code>square</code> (площадь) для структур <code>circle</code> (окружность) и <code>square</code> (квадрат). Функции <code>build_circle</code> и <code>build_square</code> — это конструкторы, которые создают объект структуры и подставляют нужные реализации функций.</p>

<p>В результате этих манипуляций нам не нужно указывать вручную, какую функцию подсчета площади вызывать. На самом деле, в языке C++ выбор нужной функции организован похожим образом: объекты содержат указатели на нужные функции. Это называется виртуальными таблицами (virtual tables), и позже мы узнаем, как они устроены.</p>

<p>Тем не менее, несоответствие локальных переменных у структур в языке C решить нельзя. Если бы мы хотели ввести структуру <code>rectangle</code> (прямоугольник), которая задается двумя числами, сделать это красиво у нас не получится.</p><h3 id="2.7.7">2.7.7</h3><p>Подобно функциям для обобщенных типов можно с помощью макросов организовать структуры для обобщенных типов. Для создания объектов таких структур потребуется также генерация их конструкторов. Попробуйте реализовать это любым способом.</p><h2 id="3">3. Компиляция, gcc</h2><h3 id="3.1">3.1. Фазы компиляции</h3><h3 id="3.1.1">3.1.1</h3><p>Напомню, что мы работает с компилятором <code>gcc</code>.</p>

<p>Компиляция состоит из четырёх шагов:</p>

<ol>
	<li>Препроцессирование (preprocessing)</li>
	<li>Компиляция</li>
	<li>Ассемблирование</li>
	<li>Компоновка (linking)</li>
</ol>

<p>Мы запускаем компиляцию командой <code>gcc &lt;filename&gt;</code>, где filename — название файла с кодом. Его расширение должно быть <code>.c</code>. При таком запуске мы получим исполняемый файл с неким именем по умолчание. Имя выходного файла можно задать явно флагом <code>-o &lt;filename&gt;</code>.</p>

<ul>
	<li>Чтобы выполнить только первый этап, необходимо добавить флаг <code>-E</code>.</li>
	<li>Чтобы выполнить первый и второй этап, необходимо добавить флаг <code>-S</code>.</li>
	<li>Чтобы выполнить первый, второй и третий этапы, необходимо ввести флаг <code>-c</code>.</li>
</ul>

<p> Далее мы изучим каждый из этапов подробнее.</p>

<p>С этого момента наши программы будут состоять из нескольких файлов.</p><h3 id="3.1.2">3.1.2</h3><p> <code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Препроцессирование выполняет все строки, которые начинаются с символа <code>#</code>(и следующие за ними, если они заканчиваются символом <code>\</code>). Это могут быть инструкции <code>#include</code>, <code>#define</code>, <code>#ifdef</code> и некоторые другие.</p>

<p>Инструкция <code>#include</code> вставляет содержимое файла. Если название файла заключено в <code>""</code>, то путь файла указывается относительно текущего файла (в примере файл <code>foo.h</code> должен находиться в одной директории с файлом <code>main.c</code>). Если название файла заключено в <code>&lt;&gt;</code>, то компилятор попытается найти файл относительно стандартной глобальной директории заголовочных файлов (там, где лежат файлы <code>stdio.h</code>, <code>stdlib.h</code> и т.д.) и относительно переданных ему директорий заголовочных файлов с помощью флага <code>-I</code> (например, <code>gcc -I. main.c</code>, что означает, искать заголовочные файлы в директории <code>.</code> (то есть, в текущей)).</p>

<p>Выполните <code>gcc main.c -E</code>, чтобы выполнить препроцессирование. Вы получите такой вывод:</p>

<pre><code class="language-cpp"># 0 "main.c"
# 0 "&lt;built-in&gt;"
# 0 "&lt;command-line&gt;"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 0 "&lt;command-line&gt;" 2
# 1 "main.c"
# 1 "foo.h" 1
int foo(int x) {
    return x + 1;
}
# 2 "main.c" 2

int main() {
    printf("%d\n", foo(2));
    return 0;
}
</code></pre>

<p>Результатом препроцессирования всегда является один файл. Обратите внимание, что содержимое файла <code>foo.h</code> непосредственно вставилось в выходной файл без каких-либо изменений.</p>

<p>Рассмотрим такую программу.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#ifdef FOO
#define DOO 4
#elif BOO
#define DOO 5
#else
#define DOO 6
#endif

#define FOO 3

#ifdef FOO
#define BOO 4
#endif

int main() {
    printf("%d %d %d\n", FOO, BOO, DOO);
    return 0;
}</code></pre>

<p>В результате её препроцессирования "переменные" <code>FOO</code>, <code>BOO</code>, <code>DOO</code> заменятся на, соответственно, значения <code>3</code>, <code>4</code>, <code>6</code>. В целом, логика работы таких ветвлений очевидна. Обратим лишь внимание на то, что обрабатываются они просто сверху вниз, и поэтому в блоке, который определяет переменную <code>DOO</code>, переменные <code>FOO</code> и <code>BOO</code> ещё не определены, и переменная <code>DOO</code> получает значение <code>6</code>.</p>

<p>Если вы не определите значение какой либо переменной, то её замены в коде не произойдет. При этом, полученный код может оказаться корректным.</p>

<p>Инструкции <code>#define</code> могут принимать аргументы. Такие инструкции называются макросами, и мы их уже видели.</p><h3 id="3.1.3">3.1.3</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компиляция переписывает код в язык ассемблера (Assembly). Язык ассемблера мы изучим позже.</p>

<p>Выполните <code>gcc main.c -S</code>, чтобы выполнить компиляцию. Вы получите такой вывод (содержимое обрезано):</p>

<pre><code class="language-no-highlight">	.file	"main.c"
	.text
	.globl	foo
	.type	foo, @function
foo:
.LFB0:
	.cfi_startproc
	endbr64
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset 6, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register 6
	movl	%edi, -4(%rbp)
	movl	-4(%rbp), %eax
	addl	$1, %eax
	popq	%rbp
	.cfi_def_cfa 7, 8
	ret
	.cfi_endproc
...</code></pre>

<p>Кратко охаректеризовать язык ассемблера можно так. У нас есть порядка десяти ячеек памяти, которые называются регистрами, и доступ к этим ячейкам самый быстрый. Кроме того у нас есть оперативная память (RAM), которая представляет собой большую ленту пронумерованных ячеек. Наша программа является последовательностью инструкций в оперативной памяти, которые имеют следующий вид:</p>

<ul>
	<li>Записать в регистр <code>D</code> значение, равное сумме значений в регистрах <code>B</code> и <code>I</code>.</li>
	<li>Записать в регистр <code>E</code> значение, записанное в оперативной памяти в ячейке под номером, который записан в регистре <code>A</code>.</li>
	<li>Если значение в регистре <code>H</code> равно нулю, то продолжить выполнение программы с инструкции, которая находится в оперативной памяти в ячейке под номером, который записан в регистре <code>C</code>.</li>
</ul>

<p>Понятно, что с одной стороны такой язык легко выучить из-за его простоты, с другой стороны его очень тяжело читать из-за отсутствия конструкций, отвечающих за высокоуровневую организацию кода.</p><h3 id="3.1.4">3.1.4</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Ассемблирование переписывает код, написанный на языке ассемблера, в объектный файл (имеет расширение <code>.o</code> или <code>.obj</code>). Объектный файл состоит из сегментов, которые содержат инструкции, из которых состоит наша программа, а также некоторую метаинформацию.</p>

<p>Выполните <code>gcc main.c -c</code>, чтобы выполнить ассемблирование. Выходной файл не состоит из читаемого текста. Выполним сначала <code>hd main.o</code>, чтобы посмотреть содержимое, как есть (содержимое обрезано):</p>

<pre><code class="language-no-highlight">00000000  7f 45 4c 46 02 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 3e 00 01 00 00 00  00 00 00 00 00 00 00 00  |..&gt;.............|
00000020  00 00 00 00 00 00 00 00  e0 02 00 00 00 00 00 00  |................|
00000030  00 00 00 00 40 00 00 00  00 00 40 00 0e 00 0d 00  |....@.....@.....|
00000040  f3 0f 1e fa 55 48 89 e5  89 7d fc 8b 45 fc 83 c0  |....UH...}..E...|
00000050  01 5d c3 f3 0f 1e fa 55  48 89 e5 bf 02 00 00 00  |.].....UH.......|
00000060  e8 00 00 00 00 89 c6 48  8d 05 00 00 00 00 48 89  |.......H......H.|
00000070  c7 b8 00 00 00 00 e8 00  00 00 00 b8 00 00 00 00  |................|
00000080  5d c3 25 64 0a 00 00 47  43 43 3a 20 28 55 62 75  |].%d...GCC: (Ubu|
00000090  6e 74 75 20 31 31 2e 34  2e 30 2d 31 75 62 75 6e  |ntu 11.4.0-1ubun|
000000a0  74 75 31 7e 32 32 2e 30  34 29 20 31 31 2e 34 2e  |tu1~22.04) 11.4.|
000000b0  30 00 00 00 00 00 00 00  04 00 00 00 10 00 00 00  |0...............|
000000c0  05 00 00 00 47 4e 55 00  02 00 00 c0 04 00 00 00  |....GNU.........|
...</code></pre>

<p>Это мало что нам говорит. Для анализа объектных файлов есть специальные программы.</p>

<p><code>readelf</code> покажет нам структуру файла и содержимое некоторых секций (sections). Выполните <code>readelf main.o -a</code>.</p>

<pre><code class="language-no-highlight">ELF Header:
  Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF64
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
...
Section Headers:
  [Nr] Name              Type             Address           Offset
       Size              EntSize          Flags  Link  Info  Align
  [ 0]                   NULL             0000000000000000  00000000
       0000000000000000  0000000000000000           0     0     0
  [ 1] .text             PROGBITS         0000000000000000  00000040
       0000000000000042  0000000000000000  AX       0     0     1
  [ 2] .rela.text        RELA             0000000000000000  000001f0
       0000000000000048  0000000000000018   I      11     1     8
  [ 3] .data             PROGBITS         0000000000000000  00000082
       0000000000000000  0000000000000000  WA       0     0     1
...
Relocation section '.rela.text' at offset 0x1f0 contains 3 entries:
  Offset          Info           Type           Sym. Value    Sym. Name + Addend
000000000021  000400000004 R_X86_64_PLT32    0000000000000000 foo - 4
00000000002a  000300000002 R_X86_64_PC32     0000000000000000 .rodata - 4
000000000037  000600000004 R_X86_64_PLT32    0000000000000000 printf - 4
...
Symbol table '.symtab' contains 7 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS main.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 .text
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 .rodata
     4: 0000000000000000    19 FUNC    GLOBAL DEFAULT    1 foo
     5: 0000000000000013    47 FUNC    GLOBAL DEFAULT    1 main
     6: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
...</code></pre>

<p>Мы изучим это содержимое позже.</p>

<p><code>objdump</code> покажет нам машинный код на языке ассемблера. Выполните <code>objdump main.o -d</code>.</p>

<pre><code class="language-no-highlight">
main.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 &lt; foo&gt;:
   0:	f3 0f 1e fa          	endbr64 
   4:	55                   	push   %rbp
   5:	48 89 e5             	mov    %rsp,%rbp
   8:	89 7d fc             	mov    %edi,-0x4(%rbp)
   b:	8b 45 fc             	mov    -0x4(%rbp),%eax
   e:	83 c0 01             	add    $0x1,%eax
  11:	5d                   	pop    %rbp
  12:	c3                   	ret    

0000000000000013 &lt; main&gt;:
  13:	f3 0f 1e fa          	endbr64 
  17:	55                   	push   %rbp
  18:	48 89 e5             	mov    %rsp,%rbp
  1b:	bf 02 00 00 00       	mov    $0x2,%edi
  20:	e8 00 00 00 00       	call   25 &lt;main+0x12&gt;
  25:	89 c6                	mov    %eax,%esi
  27:	48 8d 05 00 00 00 00 	lea    0x0(%rip),%rax        # 2e &lt;main+0x1b&gt;
  2e:	48 89 c7             	mov    %rax,%rdi
  31:	b8 00 00 00 00       	mov    $0x0,%eax
  36:	e8 00 00 00 00       	call   3b &lt;main+0x28&gt;
  3b:	b8 00 00 00 00       	mov    $0x0,%eax
  40:	5d                   	pop    %rbp
  41:	c3                   	ret</code></pre>

<p>Здесь объявлены две функции. В <code>&lt;&gt;</code> скобках показаны названия функций. Сравните их содержимое с результатом выполнения команды <code>gcc main.c -S</code>.</p><h3 id="3.1.5">3.1.5</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p> <code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p>Компоновка объединяет несколько объектных файлов, подставляет реализации функций, формирует сегменты (segments) из секций в объектных файлах. В результате мы получаем исполняемый файл (но можно получить и, например, shared object), который на ОС Linux не имеет расширения, а его формат называется <code>elf</code>; на ОС Windows имеет расширение <code>.exe</code>, а его формат называется <code>PE</code> (Portable Executable).</p>

<p>Выполните <code>gcc main.c</code>, чтобы выполнить компоновку. Выходной файл не состоит из читаемого текста. Рассматривать его мы не будем. Вместо этого выполним <code>readelf a.out -a</code>. (По умолчанию, выходной исполняемый файл называется <code>a.out</code>. Вы можете задать название явно с помощью флага <code>-o</code>: <code>gcc main.c -o program</code>.)</p>

<pre><code class="language-no-highlight">...
  Type:                              DYN (Position-Independent Executable file)
  Machine:                           Advanced Micro Devices X86-64
  Version:                           0x1
  Entry point address:               0x1060
...
Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040
                 0x00000000000002d8 0x00000000000002d8  R      0x8
  INTERP         0x0000000000000318 0x0000000000000318 0x0000000000000318
                 0x000000000000001c 0x000000000000001c  R      0x1
      [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2]
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000628 0x0000000000000628  R      0x1000
...
 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.gnu.property .note.gnu.build-id .note.ABI-tag .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt 
   03     .init .plt .plt.got .plt.sec .text .fini 
   04     .rodata .eh_frame_hdr .eh_frame 
   05     .init_array .fini_array .dynamic .got .data .bss 
   06     .dynamic 
   07     .note.gnu.property 
   08     .note.gnu.build-id .note.ABI-tag 
   09     .note.gnu.property 
   10     .eh_frame_hdr 
   11     
   12     .init_array .fini_array .dynamic .got</code></pre>

<p>Структура исполняемого файла похожа на структуру объектного файла. Однако здесь помимо секций у нас присутствуют и сегменты (по какой то причине, program headers это section headers). Обратите внимание на таблицу внизу, которая показывает, из каких секций состоит каждый сегмент. Например, сегмент под номером <code>01</code> (в первой таблице мы видим, что это сегмент с названием <code>INTERP</code> (по какой-то причине, они не пронумерованы, нумерация идет с <code>00</code>)) состоит из одной секции <code>.interp</code>. То, как происходит это сопоставление, написано в linker script-е. <code>gcc</code> имеет стандартный linker script, но мы можем написать свой (и мы это сделаем).</p>

<p>Выполним <code>objdump a.out -d</code>.</p>

<pre><code class="language-no-highlight">...
Disassembly of section .init:

0000000000001000 &lt;_init&gt;:
    1000:	f3 0f 1e fa          	endbr64 
    1004:	48 83 ec 08          	sub    $0x8,%rsp
    1008:	48 8b 05 d9 2f 00 00 	mov    0x2fd9(%rip),%rax        # 3fe8 &lt;__gmon_start__@Base&gt;
    100f:	48 85 c0             	test   %rax,%rax
    1012:	74 02                	je     1016 &lt;_init+0x16&gt;
    1014:	ff d0                	call   *%rax
    1016:	48 83 c4 08          	add    $0x8,%rsp
    101a:	c3                   	ret
...
Disassembly of section .text:

0000000000001060 &lt;_start&gt;:
    1060:	f3 0f 1e fa          	endbr64 
    1064:	31 ed                	xor    %ebp,%ebp
    1066:	49 89 d1             	mov    %rdx,%r9
    1069:	5e                   	pop    %rsi
    106a:	48 89 e2             	mov    %rsp,%rdx
    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
    1071:	50                   	push   %rax
    1072:	54                   	push   %rsp
    1073:	45 31 c0             	xor    %r8d,%r8d
    1076:	31 c9                	xor    %ecx,%ecx
    1078:	48 8d 3d dd 00 00 00 	lea    0xdd(%rip),%rdi        # 115c &lt;main&gt;
    107f:	ff 15 53 2f 00 00    	call   *0x2f53(%rip)        # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;
    1085:	f4                   	hlt    
    1086:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
    108d:	00 00 00
...
0000000000001149 &lt; foo&gt;:
    1149:	f3 0f 1e fa          	endbr64 
    114d:	55                   	push   %rbp
    114e:	48 89 e5             	mov    %rsp,%rbp
    1151:	89 7d fc             	mov    %edi,-0x4(%rbp)
    1154:	8b 45 fc             	mov    -0x4(%rbp),%eax
    1157:	83 c0 01             	add    $0x1,%eax
    115a:	5d                   	pop    %rbp
    115b:	c3                   	ret    

000000000000115c &lt; main&gt;:
    115c:	f3 0f 1e fa          	endbr64 
    1160:	55                   	push   %rbp
    1161:	48 89 e5             	mov    %rsp,%rbp
    1164:	bf 02 00 00 00       	mov    $0x2,%edi
    1169:	e8 db ff ff ff       	call   1149 &lt;foo&gt;
    116e:	89 c6                	mov    %eax,%esi
    1170:	48 8d 05 8d 0e 00 00 	lea    0xe8d(%rip),%rax        # 2004 &lt;_IO_stdin_used+0x4&gt;
    1177:	48 89 c7             	mov    %rax,%rdi
    117a:	b8 00 00 00 00       	mov    $0x0,%eax
    117f:	e8 cc fe ff ff       	call   1050 &lt;printf@plt&gt;
    1184:	b8 00 00 00 00       	mov    $0x0,%eax
    1189:	5d                   	pop    %rbp
    118a:	c3                   	ret
...</code></pre>

<p>Количество кода резко увеличилось. Даже в секции <code>.text</code>, в которой раньше находились наши две функции, теперь присутствует множество новых функций. Все они были сгенерированы в результате выполнения linker script-а.</p>

<p>Обратите внимание на значение <code>Entry point address: 0x1060</code> в начале вывода программы <code>readelf</code>. Это адрес инструкции, с которой начнется выполнение программы. Попобуйте найти соответствующий адрес в выводе программы <code>objdump</code>. Это не функция <code>main</code>!</p><h3 id="3.1.6">3.1.6</h3><p>Вспомним строку <code>Entry point address: 0x1060</code> из вывода программы <code>readelf</code> на исполняемый файл. Здесь имеется ввиду адрес в оперативной памяти (RAM). Значит ли это, что программа этой строкой уже решила, что она будет находится именно в этом месте памяти? А что будет, если мы запустим её дважды — как удовлетворить условие для обоих процессов?</p><h3 id="3.2">3.2. Многомодульные программы</h3><h3 id="3.2.1">3.2.1</h3><p><code>main.c</code></p>

<pre><code class="language-cpp">int foo(int);

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p>В этой программе объявлена функция <code>foo</code>. Но её реализация отсутствует. Попробуем выполнить компиляцию без компоновки: <code>gcc main.c -c</code>. Компиляция завершена успешно и мы получили объектный файл <code>main.o</code>!</p>

<p>Если же мы попытаемся выполнить компоновку <code>gcc main.c</code>, то получим ошибку:</p>

<pre><code class="language-no-highlight">/usr/bin/ld: /tmp/cchwCA2L.o: in function `main':
main.c:(.text+0xe): undefined reference to `foo'
collect2: error: ld returned 1 exit status</code></pre>

<p>Задача компоновщика подставить реализации функций из других модулей, которые мы ему подали. Мы подали компоновщику единственный модуль, в котором он не нашел реализацию функции <code>foo</code>.</p>

<p>Как же выглядит функция <code>foo</code> в объектном файле, когда её реализация отсутствует? В инструкциях вызова этой функции не указывается её адрес (ведь он неизвестен). А информация о том, что этот адрес должен быть подставлен на этапе компоновки, хранится в секциях, в названии которых есть подстрока <code>rel</code> (проверьте, есть ли такие секции в вашем объектном файле).</p>

<p>Реализуем функцию <code>foo</code> в другом модуле.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}
</code></pre>

<p>Если мы попытаемся скомпилировать это в исполняемый файл, то получим ошибку   <code>undefined reference to `main' </code>. Скомпилируем в объектный файл <code>gcc foo.c -c</code>.      </p>

<p>Чтобы выполнить компоновку обоих объектных файлов, просто напишем их всех при вызове <code>gcc</code>: <code>gcc main.o foo.o</code>. Полученный исполняемый файл можно запустить.</p><h3 id="3.2.2">3.2.2</h3><p>В предыдущем примере мы, чтобы иметь возможность вызывать функцию <code>foo</code> в модуле <code>main.c</code>, объявили её: <code>int foo(int);</code>. Делать это таким способом не удобно. Для каждого <code>.c</code> файла создают заголовочный (header) <code>.h</code> файл, в котором записаны объявления функций, и который мы добавляем с помощью <code>#include</code>, чтобы получить эти объявления.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"

int main() {
    printf("%d\n", foo(2));
    return 0;
}</code></pre>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p>Скомпилировать такой проект можно так:</p>

<pre><code class="language-no-highlight">gcc main.c -c
gcc foo.c -c
gcc main.o foo.o</code></pre>

<p>, либо так: <code>gcc main.c foo.c</code></p>

<p>Обычно, внешние библиотеки распространяются только в виде заголовочных и объектных файлов; без исходного кода реализаций функций. (При этом объектные файлы могут быть объединены в архивы и/или быть shared.) При этом сами реализации функций могут быть и не на языке C (мы это сделаем позже).</p>

<p>Но как компилятор может удостовериться в том, что сигнатура функции в заголовочном файле соответствует её сигнатуре в реализации, когда компилятор видит только объектный файл? (Вам придется пока поверить мне, что общих способов узнать сигнатуру функции по объектному файлу нет.) Ответ простой — никак!</p>

<p>Изменим только файл <code>foo.c</code></p>

<pre><code class="language-cpp">void foo(int x) {
    
}</code></pre>

<p>Это успешно скомпилируется и скомпонуется, а значение, которое <code>printf</code> выведет, не имеет отношения к функции <code>foo</code>.</p><h3 id="3.2.3">3.2.3</h3><p>Разрешается объявлять функции в программе многократно, а определять их только единожды. По хорошему, реализации функций должны быть только в <code>.c</code> файлах (хотя в C++ есть способы делать это и в <code>.h</code> файлах).</p>

<p>Однако, в заголовочных файлах мы также объявляем структуры (ведь, если они используются другими модулями, они должны знать содержимое структуры). Структуры можно объявлять лишь единожды, что может вызвать проблемы.</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">#include "boo.h"

int foo(int x) {
    if (x == 0)
        return x + 1;
    else
        return x + boo(x - 1);
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">struct foo {
    int x;
};</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">#include "boo.h"

void add(struct boo *b) {
    b-&gt;f.x++;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">#include "foo.h"

struct boo {
    struct foo f;
};

void add(struct boo *b);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include "foo.h"
#include "boo.h"

int main() {
    struct foo f;
    struct boo b;
    b.f.x = 3;
    add(&amp;b);
    return 0;
}</code></pre>

<p>В этой программе в модуле <code>main.c</code> структура <code>foo</code> объявлена дважды, что приводит к ошибке. Проблема в том, что и модулю <code>main.c</code>, и модулю <code>boo.c</code> необходима эта структура. Мы не можем убрать <code>#include "foo.h"</code> из <code>boo.h</code>, так как тогда в модуле <code>boo.c</code> не будет определена эта структура.</p>

<p>Данную проблему решают с помощью header guard-а (или include guard-а). Это простая конструкция для препроцессора.</p>

<pre><code class="language-cpp">#ifndef FOO
#define FOO

struct foo {
    int x;
};

#endif</code></pre>

<p>Напомню, что препроцессинг происходит независимо для каждого модуля, поэтому содержимое этого <code>if</code>-а будет добавлено лишь по одному разу в каждый из модулей.</p>

<p>Ещё один случай, при котором пригодится header guard: структура <code>foo</code> содержит указатель на <code>boo</code>, а структура <code>boo</code> содержит указатель на <code>foo</code>. В таком случае у нас будет два header файла, которые include друг-друга. Попробуйте проверить, что произойдет в таком случае при отсутствии header guard-а.</p>

<p>Иногда, вместо такой конструкции в самое начало файла вставляют такую строку: <code>#pragma once</code>, однако она есть не во всех компиляторах.</p><h3 id="3.2.4">3.2.4</h3><p>Пусть мы хотим написать библиотеку, которая будет состоять из нескольких файлов, а соответственно, будет компилироваться в несколько объектных файлов. Хоть мы и можем написать под них общий заголовочный файл, пользователю всё равно придется добавить множество наших объектных файлов. Эту проблему можно решить, объединив наши объектные файлы в <code>.a</code> архив с помощью программы <code>ar</code>, что часто называют статической библиотекой.</p>

<p>Пусть наша библиотека выглядит так:</p>

<p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p>Скомпилируем файлы нашей библиотеки в объектные файлы, а затем создадим архив с помощью программы <code>ar</code>:</p>

<pre><code class="language-no-highlight">gcc foo.c -c
gcc boo.c -c
ar -rc libfboo.a foo.o boo.o</code></pre>

<p>Флаг <code>-r</code> означает добавить указанные файлы в архив, заместив ими файлы с теми же названиями. Флаг <code>-c</code> означает создать архив, если его нет.</p>

<p>Файл библиотеки обязан начинаться с <code>lib</code>.</p>

<p>Пусть теперь пользователь хочет воспользоваться нашей библиотекой.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Тогда для выполнения компиляции ему необходимо будет упомянуть только архив:</p>

<pre><code class="language-no-highlight">gcc main.c -L. -lfboo</code></pre>

<p><code>-L.</code> означает искать файлы статических библиотек в директории <code>.</code> (то есть, в текущей). <code>-lfboo</code> означает прикомпоновать эту библиотеку. Обратите внимание на странный формат названий: <code>libfboo.a</code> -&gt; <code>lfboo</code>.</p>

<p>IDE Visual Studio имеет свой формат для статических библиотек — <code>.lib</code>, в то время как MinGW имеет формат <code>.a</code>.</p><h3 id="3.2.5">3.2.5</h3><p>Shared object — это объектные файлы, которые прикомпоновываются к программам при их запуске. Они используются для оптимизации места на диске, так как их могут использовать различные программы, не повторяя реализации тех же функций. Часто shared objects называют динамическими библиотеками.</p>

<p>Оформим пример из предыдущего шага в виде динамической библиотеки. Скомпилируем библиотеку:</p>

<pre><code class="language-no-highlight">gcc foo.c boo.c -c
gcc -shared -o libfboo.so foo.c boo.c</code></pre>

<p>Во втором вызове <code>gcc</code> мы, с помощью флага <code>-shared</code>, создаём shared object.</p>

<p>Выполним <code>readelf libfboo.so -a</code>.</p>

<pre><code class="language-no-highlight">...
  Type:                              DYN (Shared object file)
...</code></pre>

<p>Полученный объектный файл пользователь может положить в директорию со своей программой и попросить <code>gcc</code> искать его там. Но это неправильно. Для того, чтобы библиотека была shared, она должна находиться в месте, где глобально хранятся все shared objects (в директории проекта должны быть только заголовочные файлы). Скопируем файл туда:</p>

<pre><code class="language-no-highlight">cp libfboo.so /usr/lib</code></pre>

<p>Теперь пользователь может скомпилировать свою программу:</p>

<pre><code class="language-no-highlight">gcc main.c -lfboo</code></pre>

<p>Чтобы посмотреть, какие shared objects требует исполняемый файл, введём <code>ldd a.out</code>.</p>

<pre><code class="language-no-highlight">	linux-vdso.so.1 (0x00007ffc58396000)
	libfboo.so =&gt; /lib/libfboo.so (0x00007171575e0000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x0000717157200000)
	/lib64/ld-linux-x86-64.so.2 (0x0000717157606000)</code></pre>

<p>Помимо <code>libfboo.so</code> здесь присутствует, например, <code>libc.so.6</code>.</p>

<p>Когда мы запускаем программу, загрузчик ищет shared objects:</p>

<ul>
	<li>В директориях <code>/lib*</code> и <code>/usr/lib*</code></li>
	<li>В директориях в environmental variable <code>LD_LIBRARY_PATH</code></li>
	<li>В директориях в <code>rpath</code>, который пишется в исполняемый файл в процессе компиляции с помощью флага <code>-rpath</code></li>
</ul>

<p>В ОС Windows формат динамических библиотек — <code>.dll</code>, и его использование выглядит значительно менее приятно, чем использование <code>.so</code> на Unix, так как требует использование директив компилятора. (Можете изучить пример: <a href="https://github.com/TransmissionZero/MinGW-DLL-Example" rel="noopener noreferrer nofollow">https://github.com/TransmissionZero/MinGW-DLL-Example</a>)</p><h3 id="3.2.6">3.2.6</h3><p>В современных системных языках отсутствуют заголовочные файлы. Импорт модуля в них обозначает обычно лишь добавление сигнатур функций. Есть ли реальная необходимость в заголовочных файлах?</p><h3 id="3.3">3.3. GNU make</h3><h3 id="3.3.1">3.3.1</h3><p><code>foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>foo.h</code></p>

<pre><code class="language-cpp">int foo(int x);</code></pre>

<p><code>boo.c</code></p>

<pre><code class="language-cpp">int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>boo.h</code></p>

<pre><code class="language-cpp">int boo(int x);</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include "foo.h"
#include "boo.h"

int main() {
    printf("%d\n", foo(2) + boo(2));
    return 0;
}</code></pre>

<p>Продолжим работать с той же программой. Можно сделать вывод, что процесс сборки такой программы уже нетривиальный, и мы тратим много времени на ввод повторяющегося набора команд. Чтобы решить эту проблему, мы можем написать все команды в один <code>shell</code> скрипт, и запускать его.</p>

<p><code>build.sh</code></p>

<pre><code class="language-no-highlight">rm foo.o boo.o main.o a.out
gcc foo.c -c
gcc boo.c -c
gcc main.c -c
gcc foo.o boo.o main.o</code></pre>

<p>Все команды, кроме первой, можно объединить в одну, но в целях наглядности проблемы я намеренно напишу их так.</p>

<p>Обратите внимание на первую команду: удаление всех файлов, полученных в результате компиляции. Зачем это необходимо? Если мы допустим ошибку компиляции в одном из модулей, то соответствующий объектный файл не сформируется. Однако старый не будет удален, и скрипт продолжит выполняться. В результате мы получим либо ошибку компоновки, либо скомпонованную программу, один из модулей в которой устаревший.</p>

<p>Обратите внимание на такую проблему. Пусть мы изменили реализацию функции <code>foo</code> (но не её сигнатуру). Конечно, модуль <code>foo</code> следует перекомпилировать. Но нет смысла в перекомпиляции других модулей, ведь они никак не изменились.</p>

<p>Обратите внимание на строки 2-4 скрипта — их выполнение является независимым, и мы можем их выполнить одновременно. Сделать это с помощью <code>shell</code> скрипта непросто.</p>

<p>Пусть у нас программа является составной. Например, у нас есть компилятор и его стандартная библиотека. Скорее всего компилятору понадобиться стандартная библиотека, но в то же время, если мы хотим собрать стандартную библиотеку, нам не требуется собирать компилятор.</p>

<p>Итак, мы сформировали несколько проблем, которые решает программа <code>make</code>:</p>

<ol>
	<li>Выполнение этапа сборки только в том случае, если её результат устарел.</li>
	<li>Автоматическое распараллеливание этапов сборки.</li>
	<li>Разделение сборки на этапы и автоматическое рекурсивное определение необходимых этапов для сборки текущего этапа.</li>
</ol><h3 id="3.3.2">3.3.2</h3><p>В большинстве дистрибутивов программа <code>make</code> отсутствует. Поставьте её. Из-за особенности её названия, более разумным будет использовать <code>GNU make</code> как ключевую строку.</p>

<p>Начнём с простого make-файла. Для наглядности будем компилировать модули <code>foo</code> и <code>boo</code> с статическую библиотеку.</p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">lib:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o
	gcc main.c -L. -lfboo</code></pre>

<p>Здесь определены два рецепта: <code>lib</code> и <code>program</code>. Чтобы выполнить их, необходимо ввести <code>make lib</code> или <code>make program</code> соответственно. Первый рецепт собирает только библиотеку (пусть, например, пользователю может пригодиться только она), а второй и библиотеку, и саму программу.</p>

<p>Важно: в make-файлах требуется использовать символы табуляции, вместо пробелов. Добавьте соответствующую настройку в ваш text editor, если требуется (VS Code, например, сам ставит табуляции в make-файлах).</p>

<p>Содержимое рецептов — это почти обычные <code>shell</code> команды. Однако они запускаются не в одной <code>shell</code>-сессии, а в разных, что иногда важно.</p>

<p>Мы можем упростить наш make-файл: рецепт сборки программы включает в себя содержимое рецепта сборки библиотеки. Мы можем в требование одного рецепта вписать название другого рецепта.</p>

<pre><code class="language-makefile">lib:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program: lib
	gcc main.c -L. -lfboo</code></pre>

<p>В этом случае, перед выполнением рецепта <code>program</code> будет выполнен рецепт <code>lib</code>. Важно отметить, что рецепт <code>lib</code> будет выполнен в любом случае и полностью, а значит, экономии ресурсов мы пока не добились.</p>

<p>Добавим рецепт на удаление временных файлов:</p>

<pre><code class="language-makefile">...
clean:
	rm libfboo.a foo.o boo.o main.o a.out</code></pre>

<p>Его не следует добавлять в зависимости другим рецептам, так как удаление всех файлов сделает необходимой полную перекомпиляцию.</p>

<p>Обратите внимание, что <code>make</code> является ленивым языком. (Можете теперь рассказывать программистам на <code>haskell</code>-е, что тоже в некотором смысле пишете на ленивом языке.)</p><h3 id="3.3.3">3.3.3</h3><p>Заменим название рецепта <code>lib</code> на <code>libfboo.a</code>.</p>

<pre><code class="language-makefile">libfboo.a:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

program: libfboo.a
	gcc main.c -L. -lfboo
...</code></pre>

<p>На самом деле, <code>lib</code> и <code>libfboo.a</code> в этом месте обозначает не просто название рецепта, а файл, который эти рецепты производят. Конечно, на прошлом шаге рецепт <code>lib</code> не производил файл <code>lib</code>, и так делать разрешено. Теперь же, когда файл в процессе выполнения рецепта производится, логика его выполнения усложняется. Рецепт выполняется только если его целевой файл отсутствует, либо один из файлов, от которых рецепт зависит, стал новее его целевого файла (это мы увидим чуть позже).</p>

<p>Выполните <code>make program</code> несколько раз. Вы увидите, что инструкции в рецепте <code>libfboo.a</code> были выполнены лишь при первой сборке, так как уже после неё файл <code>libfboo.a</code> был создан.</p>

<p>Таким образом мы впервые добились того, что перекомпиляция происходит только для обновленных модулей. Сделаем то же самое и для итогового файла <code>a.out</code>, так как он по прежнему собирается в любом случае.</p>

<pre><code class="language-makefile">libfboo.a:
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Теперь, при втором вызове <code>make program</code> вы получите сообщение: <code>make: Nothing to be done for 'program'.</code>. Обратите внимание, что инструкции в рецепте <code>program</code> исполняются, ведь файла <code>program</code> нет (можете это проверить, вставив в рецепт любые инструкции). Но рецепт <code>a.out</code> не был выполнен, так как файл <code>a.out</code> моложе всех зависимостей — единственного файла <code>libfboo.a</code>.</p>

<p>Изменим файл <code>libfboo.a</code>. Здесь есть проблема: его пересборка на <code>make libfboo.a</code> будет выполнена только в том случае, если файла <code>libfboo.a</code> нет, ведь мы не написали для этого рецепта никаких зависимостей (сейчас мы это исправим). Поэтому просто удалим <code>libfboo.a</code> и сделаем <code>make libfboo.a</code>. Теперь при вызове <code>make program</code> будет выполнена перекомпиляция <code>a.out</code>.</p>

<p>Добавим зависимости для рецепта <code>libfboo.a</code>.</p>

<pre><code class="language-makefile">libfboo.a: foo.c boo.c
	gcc foo.c -c
	gcc boo.c -c
	ar -rc libfboo.a foo.o boo.o
...</code></pre>

<p>Теперь при изменения файла <code>foo.c</code> или <code>boo.c</code> будет выполнена пересборка <code>libfboo.a</code> на команду <code>make libfboo.a</code>. Но, более того, будет выполнена пересборка <code>libfboo.a</code> и на команду <code>make program</code>. Это означает, что <code>make</code> проверяет необходимость пересборки не только в текущей точке, но и по всему дереву.</p><h3 id="3.3.4">3.3.4</h3><p>Попробуем добиться распараллеливания. Мы хотим, чтобы компиляция модулей <code>foo</code>  и <code>boo</code> велась параллельно. Сделать это легко.</p>

<pre><code class="language-makefile">foo.o: foo.c
	gcc foo.c -c

boo.o: boo.c
	gcc boo.c -c

libfboo.a: foo.o boo.o
	ar -rc libfboo.a foo.o boo.o

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Сделаем новые рецепты на компиляцию каждого их этих модулей. Пусть сборка библиотеки зависит от объектных файлов этих модулей. Теперь <code>make</code> будет распараллеливать выполнение рецептов <code>foo.o</code> и <code>boo.o</code>, так как для них обоих удовлетворены условия. Чтобы выполнить сборку с помощью двух процессов, введите <code>make program -j 2</code>.</p>

<p>Для того, чтобы удостовериться, что сборка действительно идёт параллельно, напишем такой make-файл.</p>

<pre><code class="language-makefile">foo.o: foo.c
	sleep 3
	gcc foo.c -c

boo.o: boo.c
	sleep 3
	gcc boo.c -c
...</code></pre>

<p>Обе паузы при запуске <code>sleep</code> пройдут одновременно.</p>

<p>Представьте теперь, что у вас много модулей. Писать для каждого из них такой рецепт долго и усложняет чтение make-файла. <code>make</code> имеет способ решения этого.</p>

<pre><code class="language-makefile">%.o: %.c
	gcc $&lt; -c

libfboo.a: foo.o boo.o
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Посмотрите на первый "универсальный" рецепт. Он означает следующее: для того, чтобы собрать файл с названием <code>xxx.o</code> необходим файл <code>xxx.c</code>. Чтобы иметь доступ к необходимому файлу <code>xxx.c</code> в самом скрипте, необходимо использовать оператор <code>$&lt;</code>.</p>

<p>Посмотрите на рецепт <code>libfboo.a</code>. Вместо оператора <code>$^</code>, будут подставлены все требования, то есть, <code>foo.o boo.o</code>. Если бы мы написали оператор <code>$^</code>, то было бы подставлено только первое требование: <code>foo.o</code>.</p>

<p>Существует ещё один оператор: <code>$@</code>, вместо которого подставляется файл-цель. В примере с рецептом <code>xxx.o</code> вместо оператора <code>$@</code> будет подставлено <code>xxx.o</code>.</p><h3 id="3.3.5">3.3.5</h3><p>Мы добились поставленныъ целей с помощью <code>make</code>. Тем не менее продолжим улучшать читаемость и организацию make-скриптов.</p>

<pre><code class="language-makefile">OBJS=foo.o boo.o

%.o: %.c
	gcc $&lt; -c

libfboo.a: $(OBJS)
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre>

<p>Мы можем вынести список целевых объектных файлов в отдельную переменную, и писать её, вместо файлов. (Важно: это не environmental variables, хоть и их синтаксис похож. Они не будут проталкиваться в программы, которые вы запускаете.)</p>

<p>Пойдем дальше. Если мы перенесем файлы <code>foo.c</code> и <code>boo.c</code> в отдельную директорию, то мы можем определять целевые файлы автоматически по контенту этой директории. Тогда, когда мы добавим в директорию (и, соответственно, в библиотеку) новый файл, нам не придется изменять make-файл. Перенесем <code>foo.c</code> и <code>boo.c</code> в директорию <code>lib</code>.</p>

<p>Для определения списка файлов мы можем написать что-то вроде <code>SRCS=$(shell ls lib)</code>. (Оператор <code>shell</code> запускает программу и возвращает её вывод. Присутствует не во всех программах <code>make</code>.) Вместо этого воспользуемся оператором <code>wildcard</code>.</p>

<pre><code class="language-makefile">SRCS=$(wildcard lib/*.c)</code></pre>

<p>Смысл этого оператора очевиден. В результате его выполнения, переменная <code>SRCS</code> будет равна <code>lib/foo.c lib/boo.c</code>. Для удобства вывода значений переменных можно воспользоваться оператором <code>info</code>.</p>

<pre><code class="language-makefile">$(info $(SRCS))</code></pre>

<p>Однако, нам необходимы не исходные <code>.c</code> файлы, а объектные файлы. Можно снова пошаманить со строками, а можно воспользоваться оператором <code>patsubst</code>.</p>

<pre><code class="language-makefile">OBJS=$(patsubst lib/%.c, %.o, $(SRCS))</code></pre>

<p>Смысл этого оператора тоже почти очевиден. Вы пробегаемся по каждому слову в третьем аргументе <code>$(SRCS)</code>, и преобразовываем каждое слово из формата <code>lib/xxx.c</code> в  <code>xxx.o</code>.</p>

<p>Обратите внимание, что в результате такого вызова <code>OBJS=$(patsubst %.c, %.o, $(SRCS))</code> значение <code>OBJS</code> будет <code>lib/boo.o  lib/foo.o</code>, что немного не то, что мы хотим.</p>

<p>Обратите внимание на то, что переменная <code>SRCS</code>, кроме формирования переменной <code>OBJS</code>, больше ни на что не влияет, и в рецепте <code>%.o</code> в требованиях теперь находятся несуществующие файлы (например, <code>foo.o</code> требует <code>foo.c</code>, когда его настоящее имя теперь <code>lib/foo.c</code>). Заменим требование на <code>lib/%.c</code>.</p>

<p>Наш итоговый make-файл на текущий момент:</p>

<pre><code class="language-makefile">SRCS=$(wildcard lib/*.c)
OBJS=$(patsubst lib/%.c, %.o, $(SRCS))

%.o: lib/%.c
	gcc $&lt; -c

libfboo.a: $(OBJS)
	ar -rc libfboo.a $^

a.out: libfboo.a
	gcc main.c -L. -lfboo

program: a.out
...</code></pre><h3 id="3.3.6">3.3.6</h3><p>На предыдущем шаге мы начали изменять организацию нашего проекта в лучшую сторону, когда переместили файлы библиотеки <code>lfboo</code> в отдельную директорию. Выполним теперь правильную организацию проекта полностью. К сожалению, в языке C нет стандарта организации проекта. Я покажу один из способов. Для большей наглядности в некоторых местах я добавлю больше файлов и модулей.</p>

<p>Начнем с основной программы. Её <code>.c</code> файлы будут лежать в директории <code>src</code>, а <code>.h</code> файлы будут лежать в директории <code>include</code>. Мы добавим туда ещё один модуль <code>goo</code>.</p>

<p><code>src/goo.c</code></p>

<pre><code class="language-cpp">int goo(int x) {
    return x + 4;
}</code></pre>

<p><code>include/goo.h</code></p>

<pre><code class="language-cpp">int goo(int x);</code></pre>

<p><code>src/main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;fboo/fboo.h&gt;
#include &lt;doo/doo.h&gt;
#include &lt;goo.h&gt;

int main() {
    printf("%d\n", foo(2) + boo(2) + doo(2) + goo(2));
    return 0;
}</code></pre>

<p>Создадим директорию <code>build</code>, в которую будем складировать объектные файлы и финальный исполняемый файл. В результате компиляции файла <code>xxx/src/yyy.c</code> будет получаться файл <code>build/xxx/yyy.o</code>. (Например, <code>src/main.c</code> -&gt; <code>build/main.o</code>, <code>lib/fboo/src/foo.c</code> -&gt; <code>build/fboo/foo.o</code>.)</p>

<p>Библиотеки мы будем хранить в директории <code>lib</code>. В директории каждой библиотеки также будут директории <code>src</code> и <code>include</code>. Кроме того, библиотеки будут иметь публичный заголовочный файл (в данном случае <code>lib/fboo/fboo.h</code>) в корне директории библиотеки, на который мы и будем ссылаться из основной программы.</p>

<p><code>lib/fboo/src/foo.c</code></p>

<pre><code class="language-cpp">int foo(int x) {
    return x + 1;
}</code></pre>

<p><code>lib/fboo/src/boo.c</code></p>

<pre><code class="language-cpp">#include &lt;box.h&gt;

int boo(int x) {
    return x + 2;
}</code></pre>

<p><code>lib/fboo/include/box.h</code></p>

<pre><code class="language-cpp">struct box {
    int x;
};</code></pre>

<p><code>lib/fboo/fboo.h</code></p>

<pre><code class="language-cpp">int foo(int x);
int boo(int x);</code></pre>

<p>Для удобства в директории каждой библиотеки будет свой <code>Makefile</code>.</p>

<p><code>lib/fboo/Makefile</code></p>

<pre><code class="language-makefile">SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/fboo/%.o, $(SRCS))
CFLAGS+=-Iinclude

$(BUILD_DIR)/fboo/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/fboo/libfboo.a: $(OBJS)
	ar -rc $@ $^

prepare:
	mkdir -p $(BUILD_DIR)/fboo

clean:
	rm -rf $(BUILD_DIR)/fboo</code></pre>

<p>Здесь переменная <code>$(BUILD_DIR)</code> равна абсолютному пути директории <code>build</code>, и будет нам передана "верхним" make-файлом. Для того, чтобы уже сейчас проверить этот файл, мы можем добавить <code>BUILD_DIR=../../build</code> и вызвать <code>make</code> из директории <code>lib/fboo</code>. В данном случае, если мы вызовем <code>make</code> без названия рецепта, будут выполнены все рецепты. (В общем случае это не так: там упоротые правила, которые я не знаю.) Флаг <code>-Iinclude</code> нам необходим, чтобы файлы в директории <code>lib/fboo/include</code> были видимы. С помощью рецепта <code>prepare</code> мы создаём директорию <code>build/fboo</code>, так как <code>gcc</code> не создает её самостоятельно.</p>

<p>Организуем таким же образом библиотеку <code>doo</code>.</p>

<p><code>lib/doo/src/doo.c</code></p>

<pre><code class="language-cpp">int doo(int x) {
    return x + 3;
}</code></pre>

<p><code>lib/doo/doo.h</code></p>

<pre><code class="language-cpp">int doo(int x);</code></pre>

<p><code>lib/doo/Makefile</code></p>

<pre><code class="language-makefile">SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/doo/%.o, $(SRCS))
CFLAGS+=-Iinclude

$(BUILD_DIR)/doo/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/doo/libdoo.a: $(OBJS)
	ar -rc $@ $^

prepare:
	mkdir -p $(BUILD_DIR)/doo

clean:
	rm -rf $(BUILD_DIR)/doo</code></pre>

<p>Здесь также можно абстрагировать название модуля <code>doo</code>.</p>

<p>Напишем, наконец, главный <code>Makefile</code></p>

<p><code>Makefile</code></p>

<pre><code class="language-makefile">BUILD_DIR=$(abspath build)
SRCS=$(wildcard src/*.c)
OBJS=$(patsubst src/%.c, $(BUILD_DIR)/%.o, $(SRCS))
LIBS=$(BUILD_DIR)/fboo/libfboo.a $(BUILD_DIR)/doo/libdoo.a
CFLAGS+=-Iinclude -Ilib

$(BUILD_DIR)/%.o: src/%.c prepare
	gcc $(CFLAGS) $&lt; -c -o $@

$(BUILD_DIR)/fboo/libfboo.a:
	$(MAKE) -C lib/fboo BUILD_DIR=$(BUILD_DIR)

$(BUILD_DIR)/doo/libdoo.a:
	$(MAKE) -C lib/doo BUILD_DIR=$(BUILD_DIR)

$(BUILD_DIR)/program: $(OBJS) $(LIBS)
	gcc $(OBJS) $(LIBS) -o $@

program: $(BUILD_DIR)/program

prepare:
	mkdir -p $(BUILD_DIR)

clean:
	rm -rf $(BUILD_DIR)</code></pre>

<p>Для начала, мы создаём переменную <code>BUILD_DIR</code>, в которую записываем абсолютный путь директории <code>build</code>, который мы добываем с помощью функции <code>abspath</code>. К флагам мы добавляем флаг <code>-Ilib</code>, чтобы мы могли добавлять файлы из библиотек. С помощью <code>$(MAKE) -C dir</code> мы рекурсивно вызываем <code>make</code> в директории <code>dir</code>. Для того, чтобы получить исполняемый файл <code>build/program</code> необходимо ввести <code>make program</code> (либо <code>make dir</code>, где <code>dir</code> это абсолютный путь до исполняемого файла, но так менее удобно).</p>

<p>В этом make-файле есть недостатки. Например, названия библиотек недостаточно абстрагированы. Я намеренно не стал этим усложнять пример.</p><h3 id="3.3.7">3.3.7</h3><p>Попробуйте найти недостатки в организации проекта, который показан на предыдущем шаге, и исправить их.</p><h3 id="3.3.8">3.3.8</h3><p>До сих пор мы рассматривали только зависимости от <code>.c</code> файлов. Пусть теперь мы изменили <code>.h</code> файл. В тако случае, необходима перекомпиляция всех модулей, которые его добавляют. К сожалению, нет адекватных общих способов определить это множество модулей. Исследуйте способы, как эта проблема может быть решена.</p><h3 id="3.3.9">3.3.9</h3><h3>Проект: Программа со структурой</h3>

<p>Напишите любую программу (полная свобода мысли) вместе с несколькими её библиотеками и систему сборки для неё. Используйте контент шестого шага в качестве образца.</p><h2 id="4">4. Unix</h2><h3 id="4.1">4.1. Shell</h3><h3 id="4.1.1">4.1.1</h3><p>Разберемся подробнее в том, что такое "терминал". Запустите терминал. У вас начнется сессия с командной оболочкой (shell). В зависимости от вашего дистрибутива, запускаемая оболочка может быть различной. Однако, скорее всего, в вашем дистрибутиве по умолчанию будет запущен <code>bash</code>. Существуют другие оболочки: например, древняя и более примитивная <code>sh</code>, или более продвинутая <code>zsh</code>. Начнем с <code>sh</code>. Введите <code>sh</code> в терминале, чтобы запустить его. Какие при этом происходят действия, мы узнаем немного позже.</p>

<p>Prompt (приглашение) в <code>sh</code> очень простое — <code>$</code>. Чтобы запустить локальную программу в любом shell, необходимо ввести <code>./program</code>, где program — название исполняемого файла. Чтобы запустить глобальную программу, необходимо просто ввести название её исполняемого файла. Shell будет искать этот исполняемый файл во всех директориях, которые записаны в переменной <code>PATH</code> (об этом позже).</p>

<p>Чтобы узнать текущую директорию, в которой мы находимся, можно воспользоваться программой <code>pwd</code>.</p>

<pre><code class="language-no-highlight">$ pwd
/home/igor/test</code></pre>

<p>Чтобы создать папку, можно воспользоваться программой <code>mkdir</code>.</p>

<pre><code class="language-no-highlight">$ mkdir dir</code></pre>

<p>Чтобы посмотреть все файлы в текущей директории, можно воспользоваться программой <code>ls</code>.</p>

<pre><code class="language-no-highlight">$ ls
dir</code></pre>

<p>Чтобы сменить директорию, воспользуйтесь <strong>командой</strong> <code>cd</code>.</p>

<pre><code class="language-no-highlight">$ cd dir
$ pwd
/home/igor/test/dir</code></pre>

<p>Чтобы создать файл, можно воспользоваться программой <code>touch</code>.</p>

<pre><code class="language-no-highlight">$ touch file
$ ls
file</code></pre>

<p>Чтобы редактировать файл в терминале, можно воспользоваться одним из текстовых редакторов: <code>nano</code>, <code>vim</code>, etc. (Их необходимо осваивать отдельно.)</p>

<p>Чтобы вывести содержимое файла в текстовом, можно воспользоваться программой <code>cat</code>.</p>

<pre><code class="language-no-highlight">$ cat file
A dog</code></pre>

<p>Чтобы вывести содержимое файла в hex, можно воспользоваться программой <code>hd</code>.</p>

<pre><code class="language-no-highlight">00000000  41 20 64 6f 67 0a                                 |A dog.|
00000006</code></pre>

<p>Чтобы узнать расположение исполняемого файла программы, можно воспользоваться программой <code>which</code>.</p>

<pre><code class="language-no-highlight">$ which ls
/usr/bin/ls
$ which which
/usr/bin/which
$ which cd</code></pre>

<p>Чтобы удалить файл, можно воспользоваться программой <code>rm</code>.</p>

<pre><code class="language-no-highlight">$ rm file
$ ls</code></pre>

<p>Чтобы перейти не папку наверх, необходимо аргументом к команде <code>cd</code> написать <code>..</code>.</p>

<pre><code class="language-no-highlight">$ cd ..</code></pre>

<p>Чтобы удалить папку, можно воспользоваться программой <code>rmdir</code>.</p>

<pre><code class="language-no-highlight">$ rmdir dir
$ ls</code></pre><h3 id="4.1.2">4.1.2</h3><p>Чтобы "зависнуть" на некоторое время, можно воспользоваться программой <code>sleep</code>.</p>

<pre><code class="language-no-highlight">$ sleep 5</code></pre>

<p>Можно выполнить процесс "на фоне" (background), то есть, shell не будет ждать завершения процесса, а продолжит выполнять команды. Для этого в конце команды следует написать <code>&amp;</code>.</p>

<pre><code class="language-no-highlight">$ sleep 5 &amp;
$ pwd
/home/igor/test
$ 
[1] + Done                       sleep 5</code></pre>

<p>Здесь, после ввода первой команды я сразу же ввёл вторую команду. После ввода очередной команды shell уведомляет о завершенных фоновых командах.</p>

<p>Когда у вас выполняется программа не на фоне, вы можете нажать комбинацию <code>Ctrl + Z</code>. Данная комбинация ставит процесс на паузу и помещает его наверх специального буфера. Чтобы возобновить процесс с вершины буфера, введите <strong>команду</strong> <code>fg</code> (foreground).</p>

<pre><code class="language-no-highlight">$ sleep 5
^Z[1] + Stopped                    sleep 5
$ fg
sleep 5</code></pre>

<p>Обратите внимание (при личном тесте), что между нажатием комбинации Ctrl + Z и введением команды fg, таймер продолжает идти (то есть, программа <code>sleep</code> игнорирует просьбу о паузе). Пока таймер не истёк, вы не можете вводить команды, так как команда выполняется не на фоне.</p>

<p>Чтобы возобновить программу из буфера на фоне, вместо команды <code>fg</code> введите команду <code>bg</code> (background).</p>

<pre><code class="language-no-highlight">$ sleep 5
^Z[1] + Stopped                    sleep 5
$ bg
[1] sleep 5
$ 
[1] + Done                       sleep 5</code></pre>

<p>Обратите внимание (хотя это и не так важно), что буфер имеет форму стека (то есть берётся последний пришедший).</p>

<pre><code class="language-no-highlight">$ sleep 5
^Z[1] + Stopped                    sleep 5
$ sleep 6
^Z[2] + Stopped                    sleep 6
$ bg
[2] sleep 6
$ bg
[1] sleep 5</code></pre><h3 id="4.1.3">4.1.3</h3><p>Запустим программу <code>grep</code> которая принимает как аргумент слово и ищет его в своём стандартном вводе (stdin). Как только она на очередной строке, ограниченной символом <code>\n</code> находит слово, как подстроку, она выводит всю строку.</p>

<p>Как только вы запустим программу, которая ожидает данные в стандартном вводе, мы увидем в терминале не prompt, а пустую строку. Каждая наша строка, которую мы завершаем нажатием enter-а, передаётся программе в её стандартный ввод. В свою очередь, программа может что-то выводить в свой стандартный вывод (stdout), и мы также его будем видеть.</p>

<pre><code class="language-no-highlight">$ grep a  
aaa
aaa
bbb
aba
aba</code></pre>

<p>Первую, третью и четвёртую строку ввёл я. Вторую и пятую строку вывода вывела программа grep. Всё, что мы ввели будет передаваться программе grep, пока она не закроет свой stdin, однако она его никогда не закроет. Чтобы нам закрыть его, мы должны нажать комбинацию <code>Ctrl + D</code>.</p>

<p>Мы пожем связать стандартый вывод программы с файлом. Тогда всё, что она выводит, окажется в файле. Для этого, следует к команде добавить <code>&gt; file</code>.</p>

<pre><code class="language-no-highlight">$ grep a &gt; file
aaa
bbb
aba
$ cat file
aaa
aba</code></pre>

<p>При такой команде всё, что было до этого в файле, удаляется. Чтобы вместо этого выполнить дозапись в файл, следует вместо <code>&gt;</code> написать <code>&gt;&gt;</code>.</p>

<p>Можно также связать стандартный ввод программы с файлом с помощью оператора <code>&lt;</code>. Программа <code>echo</code> выводит в стандартный вывод единственный свой аргумент.</p>

<pre><code class="language-no-highlight">$ echo aaa &gt; file
$ echo bbb &gt;&gt; file
$ echo aba &gt;&gt; file
$ grep a &lt; file
aaa
aba</code></pre>

<p>Можно запустить две программы и связать стандартный вывод одной со стандартным вводом в другой. Для этого необходимо воспользоваться оператором <code>|</code> (pipe).</p>

<pre><code class="language-no-highlight">$ cat file | grep a
aaa
aba</code></pre>

<p>Stdin и stdout — это streams. (Данное слово, как и слова thread и flow переведены на русский язык, как поток. Причём, по смыслу эти три слова совсем не близки.) Есть ещё один частоиспользуемый stream — стандартный вывод ошибок (stderr). В него обычно пишут программы при нарушении правил общения с ними.</p>

<p>В терминале мы видим и stdout и stderr от выполняемой программы, и отличить их нельзя. Попробуем перенаправить stdout у этой команды.</p>

<pre><code class="language-no-highlight">$ ls dirrr &gt; out
ls: cannot access 'dirrr': No such file or directory
$ cat out</code></pre>

<p>Не перенаправилось. Значит, эту строку ls вывел в stderr. Чтобы перенаправить его, следует воспользоваться оператором <code>2&gt;</code>.</p>

<pre><code class="language-no-highlight">$ ls dirrr 2&gt; out
$ cat out
ls: cannot access 'dirrr': No such file or directory</code></pre>

<p>Чтобы перенаправить оба потока в один файл, следует написать так.</p>

<pre><code class="language-no-highlight">$ ls &gt; out 2&gt;&amp;1</code></pre>

<p>Чтобы в программе на C выполнить вывод в stderr, можно воспользоваться функцией <code>fprintf</code>, которая первым аргументом принимет дескриптор stream-а. Дескриптор stderr-а храниться в глобальной переменной <code>stderr</code>.</p>

<pre><code class="language-cpp">fprintf(stderr, "%d\n", 42);</code></pre>

<p>Теперь мы можем понять, что когда мы в самом начале запустили <code>sh</code>, то мы начали с ним интерактивную сессию, такую же, как и с <code>grep</code> здесь. Мы можем её прервать комбинацией <code>Ctrl + D</code>.</p><h3 id="4.1.4">4.1.4</h3><p>Когда вы вводите команду <code>cat file</code>, вы запускаете программу <code>cat</code> и передаёте ей аргумент <code>file</code>. Посмотрим, как эти аргументы можно читать из программы на C.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p>На самом деле, в функцию <code>main</code> передаётся два аргумента — количество аргументов программы <code>argc</code>, и массив этих аргументов <code>argv</code>, которые являются строками. (На ещё более самом деле, в функцию main может передаваться аргумент <code>envp</code>, но он есть не на всех системах.) Благодаря том, как устроен application binary interface, мы можем просто не писать суффикс аргументов, и это не вызовет никаких проблем. Подробнее об этом мы узнаем позже.</p>

<p>Данная программа просто выводит аргументы. Потестируем её.</p>

<pre><code class="language-cpp">$ ./main
./main
$ /home/igor/test/main	
/home/igor/test/main
$ ./main a -b c
./main
a
-b
c</code></pre>

<p>Аргументы вида <code>--help</code> и <code>-h</code> называются флагами. Используются также аргументы вида <code>--output=file</code>. Сам shell никак не задаёт формат аргументов: вам необходимо обработать его самостоятельно.</p>

<p>Обратите внимание, что первым аргументом программы получают путь к своему исполняемому файлу. Когда мы будем запускать программы с помощью системного вызова <code>exec</code>, мы сможем нарушить это правило. В таком случае, некоторые программы могут отказаться работать.</p>

<p>Чтобы считать переменные среды (environmental variables), можно воспользоваться третьим аргументом <code>envp</code>.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp) {
    int i;
    for (i = 0; envp[i] != NULL; i++) {
        printf("%s\n", envp[i]);
    }
    return 0;
}</code></pre>

<p>Массив <code>envp</code>, в отличии от <code>argv</code>, является ноль-терминированным. (Напомню, что это по сути два способа хранения массивов: либо хранить отдельно длину массива, либо завершать его нулем.)</p>

<pre><code class="language-no-highlight">$ ./main
LESSOPEN=| /usr/bin/lesspipe %s
no_proxy=localhost,127.0.0.0/8,::1
USER=igor
LC_TIME=ru_RU.UTF-8
all_proxy=socks://127.0.0.1:1080/
XDG_SESSION_TYPE=x11
SHLVL=1
HOME=/home/igor
...</code></pre>

<p>Мы можем установить значение переменной в sh с помощью оператора <code>export</code>. Чтобы получить значение переменной, нужно перед её названием написать символ <code>$</code>.</p>

<pre><code class="language-no-highlight">$ export DOG=Shepherd
$ echo $DOG</code></pre>

<p>Переменные среды видны всем процессам-потомкам, то есть, в том числе тем, которые запущены в данном sh.</p>

<pre><code class="language-no-highlight">$ ./main | grep DOG
DOG=Shepherd</code></pre>

<p>Один из других способов вывести переменные среды — это воспользоваться глобальной переменной <code>environ</code>.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

extern char **environ;

int main(int argc, char **argv) {
    int i;
    for (i = 0; environ[i] != NULL; i++) {
        printf("%s\n", environ[i]);
    }
    return 0;
}</code></pre>

<p>Ключевое слово <code>extern</code> достаёт на этапе компоновки переменную <code>environ</code> из другого модуля, так как эта переменная не определена в заголовочных файлах. Переменна environ определена где-то в файлах <code>libc</code>. Конечно, использование extern-а считается плохой практикой.</p>

<p>Чтобы установить значение переменной, можно воспользоваться функцией <code>int setenv(const char *name, const char *value, int overwrite);</code>. Если overwrite равен нулю, то она записывает value в name, только если name не определено. В противном случае, записывает всегда.</p>

<p>Чтобы прочитать значение переменной, можно воспользоваться функцией <code>char *getenv(const char *name);</code>. В случае, если переменная name отсутствует, функция возвратит <code>NULL</code>.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
    printf("%s\n", getenv("HOME"));
    setenv("HOME", "/bin", 0);
    printf("%s\n", getenv("HOME"));
    setenv("HOME", "/bin", 1);
    printf("%s\n", getenv("HOME"));
    printf("%d\n", getenv("HOM"));
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ ./main
/home/igor
/home/igor
/bin
0</code></pre><h3 id="4.1.5">4.1.5</h3><p>Когда мы запускаем программу, запускается процесс, выполняющий эту программу. После завершения каждый процесс возвращает число. По хорошему, при успешном завершении процесс должен возвращать ноль, а при неуспешном — не ноль. Узнать, какое число вернул последний процесс, мы можем, напечатав значение переменной <code>$?</code>.</p>

<pre><code class="language-no-highlight">$ pwd	
/home/igor/test
$ echo $?
0
$ gcc
gcc: fatal error: no input files
compilation terminated.
$ echo $?
1
$ gcc main.c -o main
$ echo $?
0</code></pre>

<p>Когда мы пишем shell-скрипты, мы так проверяем, был ли запуск программы успешен.</p>

<p>Чтобы выполнить несколько программ друг за другом, мы можем написать их на одной строке, разделив символом <code>;</code>.</p>

<pre><code class="language-no-highlight">$ pwd ; ls
/home/igor/test
main  main.c</code></pre>

<p>Чтобы выполнять программы из списка, пока одна из них не завершится успешно (вернёт 0), мы можем написать их на одной строке, разделив оператором <code>||</code>.</p>

<pre><code class="language-no-highlight">$ pwd || ls
/home/igor/test
$ gcc || ls
gcc: fatal error: no input files
compilation terminated.
main  main.c</code></pre>

<p>В первом случае программа pwd завершилась успешно, поэтому программа ls не запускалась.</p>

<p>Во втором случае программа gcc завершилась неуспешно, поэтому программа ls запустилась.</p>

<p>Чтобы выполнять программы из списка, пока они выполняются успешно, мы можем написать их на одной строке, разделив оператором <code>&amp;&amp;</code>. (Звучит, как оператор, который часто будет пригождаться.)</p>

<pre><code class="language-no-highlight">$ pwd &amp;&amp; ls
/home/igor/test
main  main.c
$ gcc &amp;&amp; ls
gcc: fatal error: no input files
compilation terminated.</code></pre>

<p>В первом случае программа pwd завершилась успешно, поэтому программа ls запускалась.</p>

<p>Во втором случае программа gcc завершилась неуспешно, поэтому программа ls не запустилась.</p>

<p>Каждый процесс при запуске получает уникальный PID (process identifier). Когда мы запускаем процесс на фоне, в некоторых shell-ах нам выводится его PID (но не в sh). Его же мы можем прочитать из переменной <code>$!</code>. Пока мы мало что умеем делать с процессами. Мы можем завершить процесс с помощью программы <code>kill</code>.</p>

<pre><code class="language-no-highlight">$ sleep 100 &amp;
$ echo $!
18865
$ kill $!
$ 
[1] + Terminated                 sleep 100</code></pre>

<p>Нетрудно догадаться, что код возврата — это то, что мы возвращаем из функции <code>main</code>.</p>

<pre><code class="language-cpp">int main() {
    return 123;
}</code></pre>

<pre><code class="language-no-highlight">$ ./main
$ echo $?
123</code></pre><h3 id="4.1.6">4.1.6</h3><p>Напишите простую программу, работающую аналогично программе <code>grep</code>. Выберите и реализуйте 1-3 её флага. Не следует реализовывать весь её функционал, так как он очень большой. Чтобы узнать флаги, которые принимает программа, введите флаг <code>--help</code>.</p>

<pre><code class="language-no-highlight">grep --help</code></pre><h3 id="4.1.7">4.1.7</h3><p>В sh есть более сложные синтаксические конструкции. Например, так мы можем написать if-statement.</p>

<pre><code class="language-no-highlight">$ if gcc
&gt; then
&gt; echo 1
&gt; else 
&gt; echo 2
&gt; fi
gcc: fatal error: no input files
compilation terminated.
2</code></pre>

<p>Заметьте, что пока мы не завершили if-statement ключевым словом <code>fi</code>, sh выводит особый prompt, который подсказывает нам, что мы вводим сейчас вводим сложную синтаксическую конструкцию. Так как gcc вернул не ноль, выполнилась ветка else.</p>

<p>Очевидно, что можно сохранить такой скрипт в отдельном файле, и просто подать этот файл на stdin к sh.</p>

<p><code>script</code></p>

<pre><code class="language-bash">if gcc
then
    echo 1
else
    echo 2
fi</code></pre>

<pre><code class="language-no-highlight">$ sh &lt; script
gcc: fatal error: no input files
compilation terminated.
2</code></pre>

<p>Но такой способ требует, чтобы мы сами указали обработчик скрипта. В Unix есть возможность указать обработчик скрипта прямо в файле. В таком случае, мы можем просто запустить скрипт, как исполняемый файл, и загрузчик программ запустит указанный в файле обработчик скрипта и передаст ему путь к скрипту.</p>

<p><code>script</code></p>

<pre><code class="language-bash">#!/bin/sh
if gcc
then
    echo 1
else
    echo 2
fi</code></pre>

<p>На первой строке написан Shebang. Если файл начинается с текстовых символов <code>#!</code> то загрузчик программ (не shell) запустит программу, путь к которой указан следом (в данном случае, <code>/bin/sh</code>), и передаст ей вторым аргументом путь к скрипту.</p>

<pre><code class="language-no-highlight">$ chmod +x script
$ ./script
gcc: fatal error: no input files
compilation terminated.
2</code></pre>

<p>Нам необходимо разрешить запускать скрипт. Сделать это можно с помощью программы <code>chmod</code>.</p>

<p>Давайте напишем свой обработчик скриптов.</p>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    return 0;
}</code></pre>

<p><code>script</code></p>

<pre><code class="language-no-highlight">#!./main</code></pre>

<p> Укажем путь к исполняемому файлу нашего обработчика: <code>./main</code>.</p>

<pre><code class="language-no-highlight">$ ./script	
./main
./script</code></pre>

<p>Видим, что вторым аргументом указан путь к скрипту.  Теперь мы можем в нашем обработчике открыть этот файл и что-то сделать.</p><h3 id="4.1.8">4.1.8</h3><p>Мы можем посмотреть список процессов-потомков с помощью программы <code>ps</code>.</p>

<pre><code class="language-no-highlight">$ sleep 5 &amp;
$ ps              
    PID TTY          TIME CMD
  30872 pts/1    00:00:00 bash
  71987 pts/1    00:00:00 sh
  72063 pts/1    00:00:00 sleep
  72070 pts/1    00:00:00 ps</code></pre>

<p>Здесь мы видем <code>bash</code>, который был запущен у меня изначально; <code>sh</code>, который я запустил в нём; <code>ps</code>, который вывел этот текст; и <code>sleep</code>, запущенный ранее на фоне.</p>

<p>Мы можем проверить время работы процесса с помощью программы <code>time</code>.</p>

<p>Напишем вспомогательную программу.</p>

<pre><code class="language-cpp">int main() {
    int i;
    for (i = 0; i &lt; 1000000000; i++);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ time sleep 2
0.00user 0.00system 0:02.00elapsed 0%CPU (0avgtext+0avgdata 2048maxresident)k
0inputs+0outputs (0major+87minor)pagefaults 0swaps
$ time ./main
1.80user 0.00system 0:01.80elapsed 99%CPU (0avgtext+0avgdata 1152maxresident)k
0inputs+0outputs (0major+63minor)pagefaults 0swaps</code></pre>

<p>По какой-то причине, вывод в sh не отформатирован. Обратите внимание, что всё время работы программы sleep приходится на system, в то время как всё время работы программы main приходится на user. Это связано с тем, что программа sleep просит процессор не выполнять её некоторое время, в то время как main всё это время полностью использует процессор.</p>

<p>Мы можем посмотреть информацию обо всех процессах с помощью программы <code>top</code>. Данная программа является интерактивной, то есть, она меняет текст в терминале. Чтобы выйти из программы, нажмите <code>q</code>. Мы можем получить мгновенный статус с помощью флага <code>-n</code> со значением <code>1</code>. Проверим статус процесса sh. Нам понадобится флаг <code>-b</code>, чтобы top не выводил символы форматирования.</p>

<pre><code class="language-no-highlight">$ top -n 1 -b | grep sh
...
  30872 igor      20   0   11556   4776   3788 S   0,0   0,1   0:00.45 bash
...
  71987 igor      20   0    2892   1664   1664 S   0,0   0,0   0:00.00 sh
...</code></pre><h3 id="4.1.9">4.1.9</h3><p>На sh-скриптах можно решать задачи. Так мы можем решить задачу <code>A + B</code>.</p>

<pre><code class="language-bash">read a
read b
c=$(($a + $b))
echo $c</code></pre>

<p>Изучите синтаксические конструкции в sh (они простые, хоть и очень странные). В sh есть только один тип данных — строка.</p>

<p>Напишите решение любой более сложной задачи. Например, задачи про брокера Василия из главы "Контроль потока".</p><h3 id="4.1.10">4.1.10</h3><h3>Проект: Judge System</h3>

<p>Напишите локальную тестирующую систему, работающую по аналогии с <a href="https://codeforces.com/" rel="noopener noreferrer nofollow">https://codeforces.com/</a> и подобными сайтами.</p>

<ul>
	<li>В директории, отведенной под задачу должны быть:
	<ul>
		<li>Директория с тестами</li>
		<li>Директория с ответами на тесты</li>
	</ul>
	</li>
	<li>Пользователь запускает bash-скрипт, передавая ему исходный код своей программы-решения (выбор поддерживаемых языков неважен) и путь к директории задачи. bash-скрипт проходит по всем парам &lt;тест, ответ на тест&gt; и запускает решение (предварительно скомпилированное), подавая ему в stdin тест и сравнивая вывод в stdout с ответом на тест.
	<ul>
		<li>Если программа не скомпилировалась, пользователь должен получить вердикт "Compilation error"</li>
		<li>Если программа использует больше X памяти, она должна прерваться, и пользователь должен получить вердикт "Memory limit exceeded".</li>
		<li>Если программа использует больше Y времени, она должна быть прерванное, и пользователь должен получить вердикт "Time limit exceeded"</li>
		<li>Если программа вернула не <code>0</code>, пользователь должен получить вердикт "Runtime error"</li>
		<li>Если вывод программы не совпал с ответом на тест, пользователь должен получить вердикт "Wrong answer"</li>
		<li>В противном случае, пользовать должен получить вердикт "Accepted"</li>
	</ul>
	</li>
</ul>

<p>По желанию, можете изучить, что такое checkers (чекеры) и добавить их поддержку. Но это почти не усложнит логику.</p><h3 id="4.2">4.2. Системные вызовы</h3><h3 id="4.2.1">4.2.1</h3><p>Возможности наших программ сильно ограничены. Многие вещи, которые наши программы в прошлом делали, например, считывали ввод или создавали файлы, на самом деле они выполняли не самостоятельно. Программы могут лишь делать что-либо в своих сегментах (если у них есть на это права) и выполнять <em>системные вызовы</em>.</p>

<p>Во время существования программы её оперативная память сильно изолирована. Программа не может получить доступ к памяти других программ. Эта изоляция достигается за счет механизма <em>paging</em>-а. Каждый процесс имеет свою <em>page directory</em>, и, когда ОС переключает процесс, она также переключает и page directory. Подробнее об этом мы узнаем позже.</p>

<p>Системные вызовы — это примерно то же самое, что и функции. Их реализует ОС. Именно с помощью них мы и делаем такие действия, как взаимодействие с stream-ами, файлами, процессами. Самостоятельно вызвать системные вызовы из кода на C мы не можем — на нём просто нет соответствующих конструкций. Мы сможем самостоятельно вызывать их из кода на Assembly, но позже. Пока мы будем пользоваться функциями-обёртками.</p>

<p>Здесь указан список системных вызовов в ОС Linux на разных архитектурах. Набор системных вызовов во всех случаях почти одинаковый, меняется лишь порядок. <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>

<p>Обратите внимание, что все ссылки в этой таблице ведут на документацию функций-обёрток в Linux-е. Многие из них вы скорее всего уже видели.</p>

<p>Важно понять, что механизм системных вызовов предоставляет архитектура (причём, все распространённые на данный момент архитектуры), но то, какие будут системные вызовы и как они будут реализованы, определяет ОС. Сравните системные вызовы в Linux с системными вызовами в Windows: <a href="https://j00ru.vexillium.org/syscalls/nt/64/" rel="noopener noreferrer nofollow">https://j00ru.vexillium.org/syscalls/nt/64/</a></p>

<p>Начнём с простого системного вызова (СВ) <code>fork</code>. Данный СВ:</p>

<ul>
	<li>не принимает никаких аргументов,</li>
	<li>создаёт новый процесс, полностью идентичный  родительскому,</li>
	<li>возвращает родителю pid ребёнка, а ребёнку <code>0</code>.</li>
</ul>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int x = fork();
    printf("%d\n", x);
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">19025
0</code></pre>

<p>Ребёнок наследует stream-ы, и поэтому выводит в тот же терминал, что и родитель. Порядок вывода случайный. Попробуйте позапускать эту программу многократно.</p>

<p>Рассмотрим пример сложнее.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int t = 2, *v = (int*)malloc(sizeof(int));
    *v = 2;
    int x = fork();
    t++;
    (*v)++;
    printf("%d %d %d\n", x, t, *v);
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">20561 3 3
0 3 3</code></pre>

<p>Обратите внимание, что и переменная на стеке, и переменная на куче, в обоих процессах независимы. (Если бы это было не так, процесс, выполнивший вывод вторым, вывел бы <code>4</code>.) Это показывает, что и стек, и куча, копируются в новый процесс. Также это показывает, что кучи не являются общими для всех процессов. (О том, как работают кучи, и что делает <code>malloc</code>, мы узнаем позже. Обратите внимание, что системного вызова <code>malloc</code> или подобного нет.)</p><h3 id="4.2.2">4.2.2</h3><p>Данная программа принимает вторым аргументом целое число и выводит некоторое количество чисел. Выведете количество выведенных чисел, как функцию от значения аргумента.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main(int argc, char **argv) {
    int n = atoi(argv[1]);
    int i;
    while (n &gt; 0) {
        printf("%d\n", n);
        fflush(stdout);
        if (fork() == 0) {
            n -= 1;
        }
        else if(fork() == 0) {
            n -= 2;
        }
        else {
            break;
        }
    }

    return 0;
}</code></pre>

<p>Функция <code>fflush</code> необходима, если вы будете выводить в файл. Функция <code>printf</code> выполняет буферизацию (то есть, копит текст, и только затем выполняет вывод), поэтому необходимо потребовать её выполнить вывод сейчас с помощью функции <code>fflush</code>.</p><h3 id="4.2.3">4.2.3</h3><p>СВ fork создаёт полностью идентичный процесс. Однако гараздо чаще мы хотим запускать новый процесс другой программы. С помощью системного вызова <code>execve</code> мы можем "загрузить" в процесс другую программу. Изучите аргументы этой функции в документации: <a href="https://man7.org/linux/man-pages/man2/execve.2.html" rel="noopener noreferrer nofollow">https://man7.org/linux/man-pages/man2/execve.2.html</a> . Нам необходимо передать путь к исполняемому файлу, переменные запуска и переменные среды. Пока не будем сильно задумываться об этом и рассмотрим такой пример.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char *argv[] = {"/usr/bin/pwd", NULL};
    char *envp[] = {NULL};
    execve("/usr/bin/pwd", argv, envp);
    printf("Check\n");
    return 0;
}</code></pre>

<p>В моём случае вывод:</p>

<pre><code class="language-no-highlight">/home/igor/test</code></pre>

<p>В результате выполнения функции <code>execve</code> выполнение нашей программы прервалось, и вместо этого начала выполняться программа <code>pwd</code>. Проверьте, что если в первый аргумент ввести <code>pwd</code>, то функция не найдет программу и вернёт ошибку.</p>

<p>Обратите внимание, что мы передаём функции в качестве первого аргумента путь к ней. Мы здесь можем нарушить правило о том, что первым аргументом должен быть пусть к программе. На pwd это не влияет, но, например, программа <code>rustc</code> выводит такое:</p>

<pre><code class="language-no-highlight">error: unknown proxy name: 'xxx'; valid proxy names are 'rustc', 'rustdoc', 'cargo', 'rust-lldb', 'rust-gdb', 'rust-gdbgui', 'rls', 'cargo-clippy', 'clippy-driver', 'cargo-miri', 'rust-analyzer', 'rustfmt', 'cargo-fmt'</code></pre>

<p>Напишем вспомогательную программу, которая просто будет выводить аргументы и переменные среды.</p>

<p><code>test.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main(int argc, char **argv, char **envp) {
    int i;
    for (i = 0; i &lt; argc; i++) {
        printf("%s\n", argv[i]);
    }
    printf("________________\n");
    for (i = 0; envp[i] != NULL; i++) {
        printf("%s\n", envp[i]);
    }
    return 0;
}</code></pre>

<p><code>main.c</code></p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char *argv[] = {"xxx", "yyy", NULL};
    char *envp[] = {"A=a", "B=b", "C=c", NULL};
    execve("./test", argv, envp);
    printf("Check\n");
    return 0;
}</code></pre>

<p>Вывод:</p>

<pre><code class="language-no-highlight">xxx
yyy
________________
A=a
B=b
C=c</code></pre>

<p>Запущенная программа не получила переменные среды своего родителя. Нам необходимо передавать их самостоятельно. Для удобства существуют дополнительные функции-обёртки для execve. Здесь можно посмотреть их: <a href="https://www.opennet.ru/docs/RUS/linux_parallel/node8.html" rel="noopener noreferrer nofollow">https://www.opennet.ru/docs/RUS/linux_parallel/node8.html .</a> Например, чтобы передать переменные среды, можно воспользоваться <code>execvp</code>.</p>

<p>Наконец, если мы хотим начать новый процесс, но при этом продолжить выполнение старого, нам необходимо скомбинировать execve с fork-ом. Напомню, что ребёнку fork возвращает ноль, а родителю pid ребёнка, который больше нуля.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int pid = fork();
    if (pid == 0) {
        char *argv[] = {"/usr/bin/pwd", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/pwd", argv, envp);
    }
    else {
        printf("Check\n");
    }
    return 0;
}</code></pre>

<p>В таком случае будет присутствовать и вывод программы pwd, и строка <code>Check</code>.</p>

<p>При завершении родительского процесса, дочерний продолжит выполняться. (При этом, в иерархии процессов будут интересные действия, но мы их обсуждать не будем.) Однако, вы можете остановить родительский процесс до завершения дочернего с помощью системного вызова <code>wait4</code>. Это довольно сложный СВ, так как он позволяет также прочитать состояние интересующего нас процесса в специальной структуре. Я же просто здесь покажу, как подождать завершения процесса по его pid.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    int pid = fork();
    if (pid == 0) {
        char *argv[] = {"/usr/bin/sleep", "5", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/sleep", argv, envp);
    }
    else {
        wait4(pid, NULL, 0, NULL);
        printf("Check\n");
    }
    return 0;
}</code></pre>

<p>Строка <code>Check</code> будет выведена после завершения программы <code>sleep</code>.</p><h3 id="4.2.4">4.2.4</h3><p>Посмотрите на системные вызовы read и write: <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md </a>. В качестве первого аргумента они принимают некий файловый дескриптор <code>fd</code>, который является числом. В Linux работа с stream-ами реализована весьма красиво, любой stream, будь он stdin, файлом, pipe-ом, определяется единственным числом — файловым дескриптором. Посмотрим на номера файловых дескрипторов для stdin, stdout и stderr.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    printf("%d %d %d\n", STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>0 1 2</code></p>

<p>Попробуем вывести текст с помощью функции write в файловый дескриптор <code>1</code>, то есть, stdout.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    write(1, "Abacaba\n", 8);
    return 0;
}</code></pre>

<p>Вывод этой программы: <code>Abacaba</code></p>

<p>Мы можем также считать данные с помощью функции read.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    char buffer[1024];
    int cnt = read(0, buffer, 1024);
    printf("%.*s", cnt, buffer);
    return 0;
}</code></pre>

<p>Обратите внимание, что функция read не добавляет нулевой символ после считанной строки. Поэтому нам необходимо считать длину считанной строки и попросить функции printf вывести ровно столько символов, а не до первого нуля.</p>

<p>Вспомним, что ранее вы выводили текст в stderr с помощью функции fprintf, в которую мы передавали первым аргументом переменную <code>FILE *stderr</code>. Структура <code>FILE</code> является высокоуровневой абстракцией над файловыми дескрипторами, которая предоставляет дополнительную информацию. <code>FILE</code> можно получить по дескриптору с помощью функции <code>fdopen</code>. Я не буду здесь рассказывать про эти функции, так как после изучения дескрипторов читатель без проблем сможет изучить это самостоятельно. (Думаю, на этом этапе вы уже согласитесь, что C является высокоуровневым языком.)</p>

<p>Как вывести текст в файл с помощью системных вызовов? Очень просто. Нам понадобится (внезапно) системный вызов <code>open</code>. Я особо не буду рассказывать о его аргументов. Отмечу лишь, что нам необходимо наличие флага <code>O_WRONLY</code> или <code>O_RDWR</code> во втором аргументе.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fd = open("file", O_WRONLY, 0);
    printf("%d\n", fd);
    write(fd, "Abacaba\n", 8);
    return 0;
}</code></pre>

<p>Чтобы вызов функции open завершился успешно, файл "file" должен существовать. Вы можете также сами посмотреть в документации, что нужно передать в функцию, чтобы она создала файл сама.</p>

<p>В моём случае вывод этой программы: <code>3</code></p>

<p>Можно перечислить несколько флагов с помощью оператора <code>|</code>. Например, <code>O_WRONLY | O_APPEND</code>. Часто передачу флагов делают так. Чтобы такое работало, необходимо, чтобы у всех флагов множество битов не пересекалось.</p>

<p>Обратите внимание на номер дескриптора: <code>3</code>. Это означает, что, в отличии от, например, pid, номера дескрипторов не являются глобальными.</p><h3 id="4.2.5">4.2.5</h3><p>Изучите, с помощью каких системных вызовов можно манипулировать файлами (open может только создавать файлы).</p>

<p><a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md</a></p>

<p>Реализуйте любую программу, использующую эти системные вызовы.</p><h3 id="4.2.6">4.2.6</h3><p>С помощью системного вызова <code>pipe</code> мы можем получить сразу два таких дескриптора, что при записи данных в один из них, мы сможем считать эти данные из другого. Эта связка дескрипторов называется pipe (канал). Функция pipe принимает указатель на массив двух чисел и записывает в первый элемент принимающего, а во второй отправителя.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fds[2];
    pipe(fds);
    
    write(fds[1], "Hello\n", 6);

    char buffer[1024];
    read(fds[0], buffer, 1024);
    printf("%s", buffer);
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">3 4
Hello</code></pre>

<p>Использование двух полученных дескрипторов никак не отличается от использования stdin/stdout. Нам просто необходимо подставлять нужный дескриптор. Обратите внимание, что если мы поменяем местами write и read, то на вызове write наша программа зависнет в ожидании ввода, который никогда не получит.</p>

<p>Напомню, что все стандартные функции вывода выполняют вывод в stdout, то есть конкретный файловый дескриптор. Пусть мы хотим, чтобы эти функции выполняли вывод в наш pipe, а не в терминал. (Который, кстати, скорее всего тоже связан с нашей программой с помощью своего pipe-а.) С помощью системного вызова <code>dup2</code> мы можем закрыть stdout stream (не путайте с stdout-дескриптором, то есть, с числом <code>1</code>) и связать его дескриптор с отправляющей стороной pipe-а. В результате и при выводе в stdout, и при выводе в <code>fds[1]</code> будет выполнен вывод в pipe.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    dup2(fds[1], STDOUT_FILENO);
    write(STDOUT_FILENO, "Hello\n", 6);
    // write(fds[1], "Hello\n", 6);
    // printf("Hello\n");
    // fflush(stdout);

    char buffer[1024];
    int cnt = read(fds[0], buffer, 1024);
    int fd = open("file", O_WRONLY, 0);
    write(fd, buffer, cnt);

    return 0;
}</code></pre>

<p>После вызова функции <code>dup2</code> и при выводе в <code>1</code>, и при выводе в <code>fds[1]</code>, будет выполнен вывод в pipe, который мы позже сможем считать через <code>fds[0]</code>. По желанию можно закрыть дескриптор <code>fds[1]</code> с помощью функции <code>close</code>: <code>close(fds[1])</code>. В таком случае вывод в <code>fds[1]</code> станет вызывать ошибку.</p>

<p>Так как теперь дескриптор <code>1</code> связан с pipe-ом, функция printf будет выводить в него. Только так как она выполняет буферизацию (то есть, копит текст, и только затем выполняет СВ write), вам необходимо будет потребовать её выполнить write сейчас с помощью функции <code>fflush</code>.</p>

<p>Так как stdout больше не связан с терминалом (и снова его связать простым способом невозможно), мы посмотрим на результат, выполним вывод в файл.</p>

<p>До сих пор мы с помощью pipe-а отправляли данные из процесса в него же. Но такое применение довольно бессмысленное. Обычно мы хотим с помощью pipe-ов передавать данные между процессами. Когда мы выполняем fork, оба процесса наследуют общий pipe, у которого теперь два дескриптора отправителя и два принимающих дескриптора. Имейте ввиду, что когда у вас два процесса считывают данные из одного pipe, то сложность системы сильно увеличивается. Это называется состоянием гонки (race condition).</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    if (fork() != 0) {
        char buffer[1024];
        write(fds[1], "Cat\n", 4);
        read(fds[0], buffer, 1024);
    }
    else {
        char buffer[1024];
        read(fds[0], buffer, 1024);
        write(fds[1], "Dog\n", 4);
    }

    return 0;
}</code></pre>

<p>Если бы отправители и/или принимающие были связаны с разными pipe-ами, какой-то из процессов бы завис в ожидании ввода. Однако, этого не происходит.</p>

<p>При некоторых конфигурациях кода мне необходимо "потыркать" stream-ы, чтобы они немедленно передали данные. Иногда они могут это не сделать сразу, из-за чего программа зависнет. Например, у меня это происходит, если заменить <code>fork() != 0</code> на <code>fork() == 0</code>.</p>

<p>В процессах детях также можно переоткрыть pipe-ы в дескрипторы стандартных потоков с помощью dup2. Вам может это понадобиться, если вы хотите запустить в дочернем процессе другую программу с помощью execve и общаться с ней через её стандартные потоки.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;

int main() {
    int fds[2];
    pipe(fds);

    if (fork() != 0) {
        char buffer[1024];
        write(fds[1], "Cat\n", 4);
        write(fds[1], "Dog\n", 4);
        write(fds[1], "Crab\n", 5);
    }
    else {
        dup2(fds[0], STDIN_FILENO);
        char *argv[] = {"/usr/bin/grep", "a", NULL};
        char *envp[] = {NULL};
        execve("/usr/bin/grep", argv, envp);
    }

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Cat
Crab</code></pre>

<p>Здесь мы передаём дочернему процессу, выполняющему программу grep, данные в стандартный ввод через наш pipe.</p>

<p>Когда вы будете сами пробовать работать с pipe-ами, у вас часто будут проблемы с недосброшенными буферами, из-за чего ваши программы будут зависать. Я не знаю, как нормально решать эту проблему. Здесь я не использовал СВ <code>close</code>, который закрывает дескриптор, но иногда он может быть необходим.</p><h3 id="4.2.7">4.2.7</h3><p>Вы, наверное, слышали про thread (поток), который является альтернативой создания нового процесса. Чем thread отличается от процесса? Тем, насколько дочерний процесс/поток отделён от родительского. Мы видели, что новый процесс имеет свой стек (что логично, ведь блуждание по функциям меняет стек) и свою кучу. Новый поток же своей кучи не имеет. После создания нового потока, основную программу мы будем называть основным потоком.</p>

<p>Посмотрите на список СВ: <a href="https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md" rel="noopener noreferrer nofollow">https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md </a>— в нём нет СВ, имеющих какое-то отношение к потоку. Функции создания потоков в libc используют СВ <code>clone</code>, который выполняет то же самое, что и fork, но имеет возможность настройки нового процесса.</p>

<p>Я не буду объяснять большинство функций здесь. Информация о потоках здесь лишь для ознакомления.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void *thread_main() {
    printf("Thread begin\n");
    sleep(2);
    printf("Thread end\n");
    return NULL;
}

int main() {
    pthread_t thr;
    pthread_create(&amp;thr, NULL, thread_main, NULL);
    sleep(1);
    printf("Main end\n");

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Thread begin
Main end</code></pre>

<p>Мы создаём поток с помощью функции <code>pthread_create</code>. В первый аргумент функция записывает дескриптор потока, по которому мы будем этот поток упоминать. Третий аргумент — это функция, которая будет вызвана при старте потока (это сделано для удобства, так как обычно в потоках мы не запускаем другие программы с помощью execve).</p>

<p>Обратите внимание, что завершение основного потока прервало дочерний поток, и он не вывел строку <code>Thread end</code>. (Дочерние процессы продолжают выполнение и вывод.)</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

void *thread_main() {
    printf("Thread begin\n");
    sleep(2);
    printf("Thread end\n");
    return NULL;
}

int main() {
    pthread_t thr;
    pthread_create(&amp;thr, NULL, thread_main, NULL);
    sleep(1);
    pthread_join(thr, NULL);
    printf("Main end\n");

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Thread begin
Thread end
Main end</code></pre>

<p>Функция <code>pthread_join</code> останавливает текущий поток до завершения потока, дескриптор которого мы передали в первый аргумент. Это аналог функции wait4 для процессов.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;

int *x;

void *thread_main() {
    (*x)++;
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 2;
    pthread_t thr;
    pthread_create(&amp;thr, NULL, thread_main, NULL);
    pthread_join(thr, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">3</code></pre>

<p>В данном примере мы видим, что куча у обоих потоков общая.</p><h3 id="4.2.8">4.2.8</h3><p>Напишите любую программу, в которой несколько потоков объединены в цикл из pipe-ов и по кругу передают друг-другу сообщение.</p><h3 id="4.2.9">4.2.9</h3><p>Посмотрим на такую программу:</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;

int *x;

void *thread_main() {
    if (*x &gt; 0) {
        sleep(1);
        (*x)--;
    }
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 1;
    pthread_t thr1, thr2;
    pthread_create(&amp;thr1, NULL, thread_main, NULL);
    pthread_create(&amp;thr2, NULL, thread_main, NULL);
    pthread_join(thr1, NULL);
    pthread_join(thr2, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<p>Программа немного искусственная, но она покажет нам проблему. Мы создаём два потока. Каждый из них уменьшает счётчик на единицу, если он больше нуля. Однако вывод прогаммы:</p>

<pre><code class="language-no-highlight">-1</code></pre>

<p>Чтобы лучше понять, что произошло, я покажу порядок, в котором исполнялись statement-ы потоков.</p>

<pre><code>Thread 1: if (*x &gt; 0)
Thread 1: sleep(1);
Thread 2: if (*x &gt; 0)
Thread 2: sleep(1);
Thread x: (*x)--;
Thread x: return NULL;
Thread y: (*x)--;
Thread y: return NULL;</code></pre>

<p>Здесь из-за блокировки функции sleep, после которой процессор переходит к другому потоку, сначала выполнились две проверки, а только потом два уменьшения. Это называется состоянием гонки (race condition), и исправить проблему можно с помощью использования семафора (semaphore).</p>

<p>Мы воспользуемся posix semaphore-ами, функции которых имеют вид <code>sem_xxx</code>. Существует много других реализаций, но я не вижу в них смысла. Как и в случае с thread-ами, эта реализация семафоров основана на не очень дружелюбных системных вызовах <code>semxxx</code> (можете найти их в таблице СВ). Я так же покажу лишь пример использования этого.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

int *x;
sem_t sem;

void *thread_main() {
    sem_wait(&amp;sem);
    if (*x &gt; 0) {
        sleep(1);
        (*x)--;
    }
    sem_post(&amp;sem);
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 1;
    sem_init(&amp;sem, 0, 1);
    pthread_t thr1, thr2;
    pthread_create(&amp;thr1, NULL, thread_main, NULL);
    pthread_create(&amp;thr2, NULL, thread_main, NULL);
    pthread_join(thr1, NULL);
    pthread_join(thr2, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<p>Функция <code>sem_init</code> записывает дескриптор семафора в первый аргумент, а третий аргумент — это начальное значение семафора. Пусть сначала оно будет равно единице.</p>

<p>Функция <code>sem_wait</code> уменьшает значение семафора на один, но если оно сейчас равно нулю, блокирует поток до момента, когда оно станет больше нуля.</p>

<p>Функция <code>sem_post</code> увеличивает значение семафора на один.</p>

<p>Нам необходимо обрамить блок, использующий общую переменную в sem_wait и sem_post. Теперь порядок выполнения statement-ов такой:</p>

<pre><code class="language-no-highlight">Thread 1: sem_wait(&amp;sem);
Thread 1: if (*x &gt; 0)
Thread 1: sleep(1);
Thread 2: sem_wait(&amp;sem);
Thread 1: (*x)--;
Thread 1: sem_post(&amp;sem);
Thread 1: return NULL;
Thread 2: if (*x &gt; 0)
Thread 2: sem_post(&amp;sem);
Thread 2: return NULL;</code></pre>

<p>Если мы заменим третий аргумент функции sem_init на <code>2</code>, то это можно понимать, как редактирование переменной одновременно не более чем двумя потоками.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;

int *x;
sem_t sem;

void *thread_main() {
    sem_wait(&amp;sem);
    if (*x &gt; 0) {
        sleep(1);
        (*x)--;
    }
    sem_post(&amp;sem);
    return NULL;
}

int main() {
    x = (int*)malloc(sizeof(int));
    *x = 1;
    sem_init(&amp;sem, 0, 2);
    pthread_t thr1, thr2, thr3;
    pthread_create(&amp;thr1, NULL, thread_main, NULL);
    pthread_create(&amp;thr2, NULL, thread_main, NULL);
    pthread_create(&amp;thr3, NULL, thread_main, NULL);
    pthread_join(thr1, NULL);
    pthread_join(thr2, NULL);
    pthread_join(thr3, NULL);
    printf("%d\n", *x);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">-1</code></pre><h3 id="4.2.10">4.2.10</h3><p>Рассмотрим программу.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;

int main() {
    int *a = 0;
    printf("%d\n", *a);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">Segmentation fault (core dumped)</code></pre>

<p>Когда наша программа нарушает правила доступа, ей поступает сигнал <code>SIGSEGV</code>. По умолчанию при получении этого сигнала программа завершается. Мы можем сами указать, что следует сделать при получении этого сигнала. Функция <code>signal</code> принимает номер сигнала и функцию, которая будет вызвана при получении этого сигнала. Попробуем перехватит SIGSEGV.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void handler(int s) {
    printf("%d\n", s);
}

int main() {
    signal(SIGSEGV, handler);
    int *a = 0;
    printf("%d\n", *a);

    return 0;
}</code></pre>

<pre><code class="language-no-highlight">11
11
11
...</code></pre>

<p>Число <code>11</code> — это номер SIGSEGV-а. Мы не завершаем программу в нашем обработчике. После возвращения из функции handler процессор снова выполняет инструкцию, которая привела к SIGSEGV. На уровне ОС есть способы "передумать" и не выполнять инструкцию, которая приводит к ошибке. Однако у нас, как у прикладной программы, таких способов нет. Поэтому обработчик SIGSEGV-а должен завершать программу.</p>

<p>А вот и квест: программа в таком состоянии не будет слушать сигналов. Как её завершить?</p>

<p>Попробуем поиграться с разными сигналами.</p>

<pre><code class="language-cpp">#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;

void handler(int s) {
    printf("%d\n", s);
}

int main() {
    signal(SIGSEGV, handler);
    signal(SIGINT,  handler);
    signal(SIGQUIT, handler);
    signal(SIGSTOP, handler);
    signal(SIGCONT, handler);
    signal(SIGTERM, handler);
    signal(SIGKILL, handler);
    signal(SIGPIPE, handler);
    signal(SIGCHLD, handler);
    
    while(1);

    return 0;
}</code></pre>

<p>Пойдем по порядку.</p>

<p>Сигнал SIGINT вызывается при нажатии комбинации <code>Ctrl + C</code> в терминале и по умолчанию прерывает процесс. Нажмите эту комбинацию, и увидете число <code>2</code>.</p>

<p>Сигнал SIGQUIT вызывается при нажатии комбинации <code>Ctrl + \</code> в терминале и по умолчанию прерывает процесс. Нажмите эту комбинацию, и увидете число <code>3</code>.</p>

<p>Сигнал SIGSTOP вызывается при нажатии комбинации <code>Ctrl + Z</code> в терминале, то есть, при переводе процесса на фон. Нажмите эту комбинацию, однако число <code>19</code>(номер этого сигнала) вы не увидете. Дело в том, что этот сигнал особенный — его нельзя перехватить.</p>

<p>Сигнал SIGCONT вызывается при возвращении фонового процесса командой <code>fg</code>. Введите эту команду, и увидете число <code>18</code>.</p>

<p>Сигнал SIGTERM вызывается при вызове программы kill с pid нашей программы. Выполните это и увидете число <code>15</code>.</p>

<p>Сигнал SIGKILL вызывается при вызове программы kill с дополнительным аргументом <code>-9</code>. При выполнении этого программа завершится и не выведет число, так как этот сигнал нельзя перехватить.</p>

<p>Для генерации следующих сигналов потребуется внести изменения в программу.</p>

<p>Сигнал SIGPIPE вызывается при записи в закрытый stream.</p>

<pre><code class="language-cpp">...
    int fds[2];
    pipe(fds);
    close(fds[0]);
    write(fds[1], "Hello\n", 6);
...</code></pre>

<p> Сигнал SIGCHLD вызывается при завершении дочернего процесса.</p>

<pre><code class="language-cpp">...
    if (fork() == 0) {
        return 0;
    }
...</code></pre>

<p>Здесь возникнет интересная ситуация. Посмотрите на таблицу процессов любым способом (например, через <code>ps</code> или <code>top</code>). Вы увидете, что дочерний процесс ещё есть, и, более того, он не будет пропадать при сигнале SIGKILL. Дочерний процесс находиться в состоянии зомби. В этом состоянии процесс уже завершен, но ОС хранит некоторую метаинформацию, которая может быть полезна родительскому процессу. ОС уничтожит эти данные после того, как родительский процесс вызовет СВ wait. Обработчик по умолчанию делает этот вызов, но наш — нет.</p>

<pre><code class="language-cpp">...
void handler(int s) {
    printf("%d\n", s);
    wait(NULL);
}
...</code></pre><h3 id="4.2.11">4.2.11</h3><h3>Проект: Shell</h3>

<p>Напишите программу, аналогичную <code>sh</code>, но без скриптов (так как их написание довольно сложно). Список, на который можно опираться:</p>

<ul>
	<li>Принимать команды, которые состоят из нескольких слов и отделены друг от друга переводами строк.</li>
	<li>Первое слово в команде определяет путь к исполняемому файлу. Остальные слова — аргументы.</li>
	<li>Может быть команда <code>cd</code>, которая меняет текущую директорию. Для её реализации необходимо воспользоваться системным вызовом <code>chdir</code>.</li>
	<li>В команде могут быть операторы <code>&lt;</code>, <code>&gt;</code> после которых идут пути к файлам. Для реализации этих операторов необходимы pipe-ы.</li>
	<li>Команды могут быть разделены символов <code>|</code>. Тогда нужно запускать программы сразу во всех таких командах и связывать их pipe-ами.</li>
	<li>В команде может быть оператор <code>&amp;</code>. Также могут быть команды <code>fd</code> и <code>bg</code>. Это также реализуется манипуляциями с pipe-ами.</li>
	<li>При получении сигналов, которые могут быть предназначены текущему дочернему процессу, передавать эти сигналы ему. Для реализации этого необходимо воспользоваться системным вызовом <code>kill</code>.</li>
</ul><h3 id="4.3">4.3. Файловая система</h3><h3 id="4.3.1">4.3.1</h3><p><strong>Внимание! В данной главе мы будем работать с потенциально разрушительными командами. Внимательно читайте команды перед тем, как выполнять их.</strong></p>

<p>Создадим для удобства папку <code>mnt</code> (это не более, чем обычная папка).</p>

<pre><code class="language-no-highlight">mkdir mnt</code></pre>

<p>Посмотрите содержимое директории <code>/dev</code>. Среди файлов вы увидете файлы с названиями <code>sda</code>, <code>sda1</code>, <code>sda2</code>, и т. д. <code>sda</code> — это ваш загрузочный диск, на котором располагается ОС. Диск разбит на несколько partitions (разделов), которые являются обычными, но независимыми друг от друга, директориями. Каждый из файлов <code>sdaX</code> — это соответствующий partition.</p>

<p>В Unix есть возможность "подвесить" partition к любой пустой директории. В результате этого действия вы сможете видеть директорию partition-а при в входе в эту пустую директорию. Это дествие называется mount (монтирование) и выполняется программой <code>mount</code>.</p>

<p>Монтрирование производится централизованно, и список всех можно увидеть, выполнив <code>mount -l</code>.</p>

<pre><code class="language-no-highlight">...
/dev/sda1 on /boot type ext4 (rw,relatime)
...</code></pre>

<p>Посмотрите на мой вывод. Здесь указано, что первый partition моего системного диска уже подвешен к директории /boot. Этот partition отвечает за первичную загрузку нашей ОС.</p>

<p>Давайте примонтируем этот partition к нашей директории <code>mnt</code> с помощью команды <code>sudo mount /dev/sda1 mnt</code>.</p>

<p>Теперь в выводе программы <code>mount -l</code> я получаю такую строку в конце:</p>

<pre><code class="language-no-highlight">...
/dev/sda1 on /home/igor/test/mnt type ext4 (rw,relatime)
</code></pre>

<p>Мы можем зайти в директорию и увидеть её содержимое.</p>

<pre><code class="language-no-highlight">$ ls mnt
config-6.5.0-44-generic      initrd.img-6.8.0-40-generic  System.map-6.5.0-44-generic
config-6.8.0-40-generic      initrd.img.old               System.map-6.8.0-40-generic
efi                          lost+found                   vmlinuz
grub                         memtest86+.bin               vmlinuz-6.5.0-44-generic
initrd.img                   memtest86+.elf               vmlinuz-6.8.0-40-generic
initrd.img-6.5.0-44-generic  memtest86+_multiboot.bin     vmlinuz.old</code></pre>

<p>Директорию можно редактировать, что является отличным способом сломать свою ОС.</p>

<p>Чтобы размонтировать директорию, необходимо воспользоваться программой <code>umount</code>: <code>sudo umount mnt</code></p>

<p>Давайте теперь примонтируем <code>/dev/sda3</code>. В моём случае в этом partition-е хранится основная файловая система вместе с директорией <code>/home</code>. В вашем случае, это может быть другой partition, или даже директория /home может находится в отдельном от основной файловой системы partition-е. Найдите partition с /home самостоятельно и работайте с ним.</p>

<p>При такой файловой системе вы можете вновь прийти к директории mnt, однако на этот раз она будет пуста.</p>

<pre><code class="language-no-highlight">$ ls mnt/home/igor/test/mnt</code></pre><h3 id="4.3.2">4.3.2</h3><p>В Linux есть возможность создать файловую систему прямо на обычном файле, а затем этот файл примонтировать и пользоваться им. Для этого используются loop devices.</p>

<p>Посмотрите содержимое директории <code>/dev</code>: во многих дистрибутивах у вас там будут использоваться loop devices (на Ubuntu их особенно много).</p>

<p>Создадим файл, состоящий только из нулей.</p>

<pre><code class="language-no-highlight">dd if=/dev/zero of=dsk count=1024</code></pre>

<p>Программа <code>dd</code> берет префикс файла <code>if</code> размера <code>bs * count</code> и пишет его в файл <code>of</code>. Файл <code>/dev/zero</code> это особенный файл, который состоит только из нулей, а его размер бесконечен.</p>

<p>Примонтировать сам файл нельзя, зато можно примонтировать loop device. Введите <code>losetup -l</code>, чтобы увидеть список loop devices, которые сейчас у вас присутствуют. В зависимости от дистрибутива, их может быть разное количество. Все их названия имеют форму <code>/dev/loopX</code>. Введите <code>losetup -f</code>, чтобы определить свободное название.</p>

<p>Я предположу, что название <code>/dev/loop100</code> у вас свободно. Создадим loop device:</p>

<pre><code class="language-no-highlight">sudo losetup /dev/loop100 dsk</code></pre>

<p>Введите теперь <code>losetup -l</code>: вы увидете ваш loop device в списке.</p>

<pre><code class="language-no-highlight">/dev/loop100         0      0         0  0 /home/igor/test/dsk                                       0     512</code></pre>

<p>Попробуем его примонтировать.</p>

<pre><code class="language-no-highlight">$ sudo mount /dev/loop100 mnt
mount: /home/igor/test/mnt: wrong fs type, bad option, bad superblock on /dev/loop100, missing codepage or helper program, or other error.</code></pre>

<p>Монтировать можно только корректные файловые системы, а у нас просто последовательность нулей. Создадим файловую систему <code>ext4</code> (об этом чуть позже).</p>

<pre><code class="language-no-highlight">$ mkfs.ext4 dsk
mke2fs 1.46.5 (30-Dec-2021)

Filesystem too small for a journal
Discarding device blocks: done                            
Creating filesystem with 128 4k blocks and 64 inodes

Allocating group tables: done                            
Writing inode tables: done                            
Writing superblocks and filesystem accounting information: done

$ sudo mkfs.ext4 /dev/loop100
mke2fs 1.46.5 (30-Dec-2021)
/dev/loop100 contains a ext4 file system
	created on Wed Sep 11 13:38:27 2024
Proceed anyway? (y,N)  
</code></pre>

<p>Обратите внимание: вы можете упомянуть как сам файл, так и loop device.</p>

<p>Теперь мы можем выполнить монтирование.</p>

<pre><code class="language-no-highlight">$ sudo mount /dev/loop100 mnt
$ ls mnt
lost+found
</code></pre>

<p>В этой файловой системе у вас изначально есть директория <code>lost+found</code>.</p>

<p>Чтобы удалить loop device, необходимо выполнить <code>sudo losetup -d /dev/loop100</code> .</p><h3 id="4.3.3">4.3.3</h3><p>Разберемся, как установить на диске несколько partition-ов и примонтировать их.</p>

<p>Есть несколько утилит для редактирования partition-ов диска. Мы воспользуемся утилитой <code>fdisk</code>. Введите <code>fdisk dsk</code>, чтобы начать редактирование.</p>

<p>Ранее я говорил о том, что мы создали диск с единственным partition-ом. Это не совсем так, так как диск с partition-ами должен содержать специальную метаинформацию, которой у нас не было. Когда мы запустим fdisk, он нас предупредит о том, что наш диск является чистой ext4 файловой системой, которую он просто перезапишет.</p>

<p>Интерфейс этой программы не совсем тривиальный. Внимательно читайте, что она выводит.</p>

<p>Для начала, познакомимся с форматами таблиц partition-ов. Выведите help с помощью <code>m</code> и посмотрите на последний блок, в котором написаны форматы <code>GPT</code>, <code>SGI</code>, <code>DOS</code> и <code>Sun</code>. Мы поговорим о первом и третьем.</p>

<pre><code class="language-no-highlight">...
  Create a new label
   g   create a new empty GPT partition table
   G   create a new empty SGI (IRIX) partition table
   o   create a new empty DOS partition table
   s   create a new empty Sun partition table</code></pre>

<p>Когда вы запускаете компьютер, на нём выполняется "некий" код, который делает некоторую подготовку, а затем начинает выполнять код, написанный где-то на диске. Этот "некий" код, который ответственнен за первичную подготовку, бывает двух типов: <code>BIOS</code> и <code>EFI</code>.</p>

<p>BIOS действует очень просто: он загружает первый сектор диска и начинает его выполнять. Поэтому в первом секторе мы обязательно должны написать код, который поймет, где находится нужный нам partition, и загрузит его. (Один сектор — это, кстати, 512 байт. А вы сможете вместить такую логику в этот объем?)</p>

<p>BIOS сейчас является устаревшим, и маловероятно, что на вашем компьютере используется он. Однако, вы можете запустить виртуальную машину с BIOS (почему-то, это фукнция по умолчанию в VirtualBox).</p>

<p>EFI значительно умнее и его "некий" код изучает таблицу partition-ов и загружает нужный самостоятельно.</p>

<p>Обратите внимание, что термин "таблица partition-ов" не имеет отношения к термину "файловая система". Вы можете иметь на диске partition-ы с разными файловыми системами.</p>

<p>Итак, EFI использует формат GPT, а BIOS использует формат DOS (на самом деле, формат <code>MBR</code>, к которому относится DOS).</p>

<p>Посмотрим на используемый сейчас формат с помощью <code>p</code>.</p>

<pre><code class="language-no-highlight">Command (m for help): p
Disk dsk: 512 KiB, 524288 bytes, 1024 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: dos
Disk identifier: 0xaf3f4246</code></pre>

<p>По умолчанию fdisk выбрал формат DOS. Давайте проверим, как он отформатирует наш диск. Введите <code>n</code> для создания нового partition-а и, пока что, прокликайте всё без изменения. Теперь введите <code>w</code>, чтобы выполнить форматирование.</p>

<p>Посмотрим на первый сектор, то есть, первые 512 байт получившегося файла <code>dsk</code>.</p>

<p>Посмотрите на таблицу из <a href="http://wiki.osdev.org/Partition_Table" rel="noopener noreferrer nofollow">http://wiki.osdev.org/Partition_Table</a> . Согласно таблице, информация о нашем первом partition-е должна находиться на байте <code>0x01BE</code>.</p>

<table border="1" cellpadding="4" cellspacing="0" style="background: #f9f9f9; border: 1px #aaaaaa solid;">
	<tbody>
		<tr>
			<th>Partition number</th>
			<th>Offset</th>
		</tr>
		<tr>
			<td>Partition 1</td>
			<td>0x01BE (446)</td>
		</tr>
		<tr>
			<td>Partition 2</td>
			<td>0x01CE (462)</td>
		</tr>
		<tr>
			<td>Partition 3</td>
			<td>0x01DE (478)</td>
		</tr>
		<tr>
			<td>Partition 4</td>
			<td>0x01EE (494)</td>
		</tr>
	</tbody>
</table>

<p> Проверим это с помощью <code>hd</code>: <code>hd dsk</code>.</p>

<pre><code class="language-no-highlight">00000000  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001b0  00 00 00 00 00 00 00 00  e2 79 d9 ef 00 00 00 00  |.........y......|
000001c0  02 00 83 01 04 15 01 00  00 00 ff 03 00 00 00 00  |................|
000001d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000001f0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 55 aa  |..............U.|
...</code></pre>

<p>Мы действительно видим ненулевые биты на отрезке <code>0x1be - 0x1cd</code>. (Что написано на отрезке <code>0x1b8 - 0x1ba</code> можете изучить самостоятельно по той же ссылке.) Кроме того, мы здесь видим в конце первого сектора байты <code>0x55</code> и <code>0xaa</code>, которые обязательно должны быть в MBR.</p><h3 id="4.3.4">4.3.4</h3><p>Когда вы создаёте первый partition в DOS-диске, вы можете разместить его только начиная с 1-го сектора (везде нумерация идёт с нуля), так как первый сектор является хратит код и таблицу разделов MBR. Однако, когда вы создаёте первый partition в GPT-диске, вы можете разместить его только начиная с 34-сектора.</p>

<ul>
	<li>Что находится в первых 34-х секторах?</li>
	<li>Зачем нужет первый сектор?</li>
</ul>

<p> Можете прочитать о GPT на OSDev Wiki.</p><h3 id="4.3.5">4.3.5</h3><p>Создадим диск с несколькими partition-ами с помощью fdisk. Прочитайте самостоятельно help в утилите и добейтесь похожей картины:</p>

<pre><code class="language-no-highlight">Command (m for help): p
Disk dsk: 512 KiB, 524288 bytes, 1024 sectors
Units: sectors of 1 * 512 = 512 bytes
Sector size (logical/physical): 512 bytes / 512 bytes
I/O size (minimum/optimal): 512 bytes / 512 bytes
Disklabel type: gpt
Disk identifier: 4A705392-B1C6-E34B-B7B9-39BFA385DB58

Device Start   End Sectors  Size Type
dsk1      34   200     167 83,5K Linux filesystem
dsk2     201   990     790  395K Linux filesystem</code></pre>

<p>Формат диска не важен, так как мы планируем использовать loop devices, и они поддерживают большинство форматов.</p>

<p>Выполните <code>losetup</code> с флагом <code>-P</code>: <code>sudo losetup -P /dev/loop100 dsk</code> . Вывод <code>losetup -l</code> ничего нового не покажет, но если вы выполните <code>ls /dev</code>, то увидете интересную картину.</p>

<pre><code class="language-no-highlight">...
loop100
loop100p1
loop100p2
...</code></pre>

<p>У нас появилось по одному дополнительному loop device на каждый partition. Мы можем в каждом из них выполнить форматирование. Для интереса выполним форматирование в разные файловые системы.</p>

<pre><code class="language-no-highlight">$ sudo mkfs.fat /dev/loop100p1
$ sudo mkfs.ext4 /dev/loop100p2</code></pre>

<p>Теперь мы можем примонтировать их.</p>

<pre><code class="language-no-highlight">$ mkdir mnt1 mnt2
$ sudo mount /dev/loop100p1 mnt1
$ sudo mount /dev/loop100p2 mnt2
$ ls mnt1
$ ls mnt2
lost+found</code></pre>

<p>Расскажу ещё немного о файловых системах. Есть три основных часто используемых файловых систем:</p>

<ul>
	<li>ext4 — сложная файловая система, часто используемая на Linux</li>
	<li>NTFS — сложная файловая система, используемая на Windows</li>
	<li>fat — простая файловая система, драйвер к которой можно написать самостоятельно</li>
</ul><h3 id="4.3.6">4.3.6</h3><p>Выполните установку любого дистрибутива с ручной установкой (я рекомендую Arch) на виртуальную машину в VirtualBox. Нас интересует часть, связанная с разметкой диска. Попробуйте выполнить установку и на машину с BIOS, и на машину с EFI (меняется в настройках машины).</p><h3 id="4.3.7">4.3.7</h3><p>Предположим, что мы хотим запустить процесс так, чтобы он видел лишь некое поддерево файловой системы. Есть два способа достичь этого: <code>chroot</code> и системный вызов <code>clone</code> с флагом <code>CLONE_NEWNS</code>. Второй способ использует namespaces, которые были введены в Linux не очень давно для контейнеризации (изоляции процессов), и именно его сейчас используют утилиты <code>LXC</code> и <code>Docker</code>. Namespaces способны изолировать не только файловую систему и значительно сложнее chroot-а, поэтому будем здесь работать с ним.</p>

<p>При использовании любого способа, так как программа не будет видеть ничего вне выбранного поддерева, необходимо будет иметь как минимум, необходимые shared objects, а, желательно, почти всю ОС в этом поддереве.</p>

<p>Попробуем запустить pwd в изолированной директории. Создайте директорию <code>dir</code> и скопируйте туда pwd.</p>

<pre><code class="language-no-highlight">$ mkdir dir
$ cp /usr/bin/pwd dir</code></pre>

<p>Попробуем запустить его с помощью программы chroot.</p>

<pre><code class="language-no-highlight">$ sudo chroot dir /pwd
chroot: failed to run command ‘/pwd’: No such file or directory</code></pre>

<p>Первым аргументом мы вводим поддерево, которое будет видеть процесс, а вторым — путь к исполняемому файлу относительно корня этого поддерева.</p>

<p>Ошибка очень неочевидная и она говорит о том, что загрузчик процесса не смог найти необходимые shared objects. (Как это понять, история умалчивает.) Мы можем посмотреть необходимые shared objects с помощью программы <code>ldd</code>, а затем скопировать их в dir.</p>

<pre><code class="language-no-highlight">$ cd dir
$ ldd pwd
	linux-vdso.so.1 (0x00007ffd1aed3000)
	libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007d59e6000000)
	/lib64/ld-linux-x86-64.so.2 (0x00007d59e637a000)
$ mkdir -p lib/x86_64-linux-gnu lib64
$ cp /lib/x86_64-linux-gnu/libc.so.6 lib/x86_64-linux-gnu/
$ cp /lib64/ld-linux-x86-64.so.2 lib64
$ cd ..
$ sudo chroot dir /pwd
/</code></pre>

<p><code>linux-vdso.so.1</code> — особый shared object, который импортируется в из ядра в любую программу. Обратите внимание, что pwd вывел свою позицию относительно поддерева.</p>

<p>Для запуска sh скопируем в dsk образ ОС. (Ведь, чтобы запускать другие программы в sh, необходимо будет их всех также скопировать вместе с их зависимостями.) Наверное, легче всего скачивать образы с помощью утилиты Docker. Очистите директорию dsk и выполните <code>docker export $(docker create ubuntu) | tar -C dsk -xvf -</code> , чтобы скачать и образ ОС Ubuntu и разархивировать его в dsk.</p>

<p>Выполните <code>sudo chroot dsk /bin/sh</code> , чтобы запустить sh. Попробуйте походить по папкам, чтобы удостовериться, что вы не имеете доступа к основной файловой системе.</p>

<p>chroot имеет некоторые уязвимости, которые устраняют namespaces. Можете изучить самостоятельно, что нехорошего может сделать программа, запущенная из chroot-а.</p><h3 id="4.3.8">4.3.8</h3><h3>Проект: Containerization</h3>

<p>Напишите программу для контейнеризации, которая позволяет:</p>

<ul>
	<li>Создавать файлы-диски и монтировать их (создавать контейнеры)</li>
	<li>Автоматически устанавливать на контейнер ОС (можно загружать их с помощью docker-а)</li>
	<li>Монтировать несколько дисков</li>
	<li>Запускать программы в контейнерах в chroot</li>
</ul>

<p>По желанию, можете использовать namespaces, но это намного сложнее.</p><h2 id="5">5. Assembly</h2><h3 id="5.1">5.1. Регистры, базовые инструкции</h3><h3 id="5.1.1">5.1.1</h3><p>Начнём изучать язык ассемблера (assembly language). Мы уже знаем, что в процессе компиляции код на C переписывается на язык ассемблера, а затем он переписывается ассемблером в объектный файл с машинным кодом.</p>

<p>Для чего может быть нужно знание ассемблера? На самом деле, ответ такой же, как и на вопрос о том, зачем знать C. Мы очень не хотим писать на языке ассемблера, так как это очень сложно (чуть позже увидим почему). Обычно мы прибегаем к его использованию в следующих случаях:</p>

<ul>
	<li>Мы хотим организовать среду, в которой сможет работать код, написанный на языке C. Это касается embedded programming (встраимоевого программирования).</li>
	<li>Мы хотим изучить результат работы компилятора на предмет возможных недостатков. Иногда специфические математические алгоритмы лучше написать на языке ассемблера, так как компилятор может не догадываться, как их писать правильно.</li>
	<li>Мы пишем непосредственно генерацию кода для ассемблера.</li>
</ul>

<p>Первый случай отличается от двух других гараздо сильнее, чем может показаться на первый взгляд. Остальные случаи относятся к написанию кода на прикладном уровне. Возможно, вы уже слышали такую мудрость: Для написания кода на ассемблере достаточно знать <code>random_range(5, 10)</code> инструкций.  Для прикладного уровня это так, и с него мы и начнём изучение. Организация же среды в embedded program требует взаимодействия с состояниями процессора с помощью инструкций, которые мы, по понятной причине, не можем применять на прикладном уровне.</p>

<p>Существует много различных архитектур процессоров. Все они работают по одной модели, но отличаются множеством состояний и набором инструкций. Самые часто используемые на практике процессоры: <code>x86</code>, <code>arm</code>, <code>risс-v</code>. Подобно тому, как мы можем использовать другие операционные системы с помощью виртуальной машины, мы можем выполнить эмуляцию других процессоров (понятно, что не аппаратно, а программно). Однако, мы будем в основном работать с архитектурой <code>x86</code>, так как, скорее всего, эта архитектура и стоит на вашем компьютере.</p><h3 id="5.1.2">5.1.2</h3><p>Сама архитектура задаёт только инструкции, которые мы будем видить при дизассемблировании. Однако, даже ассемблеры имеют конструкции для структуризации кода, которые называются директивами. Проблема в том, что хоть все ассемблеры имеют одинаковые инструкции (ведь их задаёт архитектура), директивы в них отличаются.</p>

<p>Мы будем пользоваться ассемблером <code>GNU Assembler</code>, который и используется в процессе компиляции программы на C компилятором gcc. Существует два основных синтаксиса  языков ассемблера: <code>AT&amp;T</code> и <code>Intel</code>. По умолчанию, gcc использует синтаксис <code>AT&amp;T</code>, с которого мы и начнём, но позже посмотрим и на второй. Чтобы gcc использовал синтаксис <code>Intel</code>, следует добавить флаг <code>-masm=intel</code>.</p>

<p>Когда мы пишем на ассемблере, следует соблюдать некоторые протоколы взаимодействия. ОС Linux использует специальные объектные файлы, поэтому, когда мы пишем программу на Linux, следует генерировать именно объектный файл. Другие ОС имеют другие структуры у подобных файлов. Если мы хотим на своей ОС иметь свой формат, аналогичный объектным файлам, нам придётся написать свой ассемблер. Также ассемблеры могут генерировать flat binary файлы, то есть файлы, состоящие непосредственно из секций, без какой-либо метаинформации. Естественно, мы их не сможем запустить на Linux-е, но они могут быть неплохой отправной точкой, когда мы пишем загрузчик программ для своей ОС.</p>

<p>Итак, перейдем к языку ассемблера.</p>

<p><code>main.s</code></p>

<pre><code class="language-no-highlight">    .text
    .globl  main
main:
    mov     $2, %rax # comment
    mov     $3, %rbx
    add     %rax, %rbx
    ret</code></pre>

<p>Первые три строки являются директивами. То есть, они говорят ассемблеру, что делать, но сами в результирующий объектный файл не попадают.</p>

<p><code>.text</code> говорит о том, что все следующие инструкции следует положить в секцию <code>text</code>. Компоновщик gcc требует наличие этой секции. Но позже мы научимся регулировать это.</p>

<p><code>.globl</code> говорит о том, что label (метка) <code>main</code> должна быть видна извне данного файла. В данном случае она нужно, чтобы компоновщик gcc увидел эту метку и записал, что выполнять программу следует с этого адреса.</p>

<p><code>main</code> — это метка, на которую мы можем ссылаться в других местах нашей программы. Каждое использование слова <code>main</code> будет заменено её адресом (каким адресом, мы узнаем позже).</p>

<p>Комментарии в gnu assembler начинаются с символа <code>#</code>.</p>

<p>Далее идут четыре инструкции. В языке ассемблера у нас есть регистры, в которых мы храним результаты провежуточных вычислений. Это ячейки памяти с самым быстрым доступом. Обычно регистров общего назначения около десяти, но помимо них могут быть десятки более специфических регистров. <code>rax</code> и <code>rbx</code> — это регистры общего назначения. Мы изучим полный их список позже. Можно воспринимать их, как очень глобальные переменные.</p>

<p>Что делают инструкции <code>mov</code> и <code>add</code> догадаться просто. Инструкция <code>mov</code> кладёт значение в первом аргументе (source — источник) во второй аргумент (destination — цель, назначение) (что происходит, когда второй аргумент не является регистром, узнаем чуть позже). Инструкция <code>add</code> складывает оба аргумента и кладёт результат во второй аргумент. Инструкция <code>ret</code> более сложная, мы её изучим позже.</p>

<p>Скомпилируем: <code>gcc main.s -o main</code> и запустим <code>./main</code>. Программа ничего не выведет. Написать ввод и вывод в языке ассемблера несколько сложнее, чем в C, и мы научимся этому позже.</p><h3 id="5.1.3">5.1.3</h3><p>Научимся отлаживать (debug) код на языке ассемблера. Сама отладка, по моему мнению, по большей части бессмысленна, но конкретно сейчас она хорошо покажет, как выполняется программа на уровне регистров и памяти.</p>

<p>Установите <code>GNU Debugger</code> — <code>gdb</code>. Запустите его на нашей программе из прошлого шага: <code>gdb main</code>. Начнётся интерактивная сессия, подобная тем, которые используются в текстовых редакторах.</p>

<p>Я хочу выполнить четыре инструкции в нашей программе и посмотреть на то, что происходит с регистрами.</p>

<ul>
	<li>Чтобы видеть наши инструкции, следует написать <code>layout asm</code>. Это выполнит дизассемблирование, поэтому директивы мы не увидим.</li>
	<li>Чтобы видет регистры, следует написать <code>layout regs</code>.</li>
	<li>На самом деле, до и после выполнения функции main выполняется немало другого кода. Поэтому начинать с самого начала нам пока не следует (хотя позже мы изучим, что это за код, и как он генерируется). Поставьте точку останова (breakpoint) на метке main: <code>b main</code></li>
	<li>Наконец, запустите программу: <code>r</code>. Чтобы перейти к следующей инструкции, напишите <code>ni</code>. Наблюдайте за подсвеченной командой в коде и значениями регистров <code>rax</code> и <code>rbx</code>.</li>
</ul>

<p>Что вы должны видеть в процессе ввода команд <code>ni</code>.</p>

<pre><code class="language-no-highlight">┌─Register group: general───────────────────────────────────────────────────────────────────────────────┐
│rax            0x2                 2                                                                   │
│rbx            0x0                 0                                                                   │
│rcx            0x555555557df8      93824992247288                                                      │
│rdx            0x7fffffffdc98      140737488346264                                                     │
│rsi            0x7fffffffdc88      140737488346248                                                     │
│rdi            0x1                 1                                                                   │
│rbp            0x1                 0x1                                                                 │
│rsp            0x7fffffffdb78      0x7fffffffdb78                                                      │
│r8             0x7ffff7e1bf10      140737352154896                                                     │
│r9             0x7ffff7fc9040      140737353912384                                                     │
│r10            0x7ffff7fc3908      140737353890056                                                     │
│r11            0x7ffff7fde660      140737353999968                                                     │
│r12            0x7fffffffdc88      140737488346248                                                     │
│r13            0x555555555129      93824992235817                                                      │
│r14            0x555555557df8      93824992247288                                                      │
┌───────────────────────────────────────────────────────────────────────────────────────────────────────┐
│B+  0x555555555129 &lt;main&gt;           mov    $0x2,%rax                                                   │
│  &gt; 0x555555555130 &lt;main+7&gt;         mov    $0x3,%rbx                                                   │
│    0x555555555137 &lt;main+14&gt;        add    %rax,%rbx                                                   │
│    0x55555555513a &lt;main+17&gt;        ret                                                                │
│    0x55555555513b                  add    %dh,%bl                                                     │
│    0x55555555513d &lt;_fini+1&gt;        nop    %edx                                                        │
│    0x555555555140 &lt;_fini+4&gt;        sub    $0x8,%rsp                                                   │
│    0x555555555144 &lt;_fini+8&gt;        add    $0x8,%rsp                                                   │
│    0x555555555148 &lt;_fini+12&gt;       ret                                                                │
│    0x555555555149                  add    %al,(%rax)                                                  │
│    0x55555555514b                  add    %al,(%rax)                                                  │
│    0x55555555514d                  add    %al,(%rax)                                                  │
│    0x55555555514f                  add    %al,(%rax)                                                  │
│    0x555555555151                  add    %al,(%rax)                                                  │
│    0x555555555153                  add    %al,(%rax)                                                  │
│    0x555555555155                  add    %al,(%rax)                                                  │
└───────────────────────────────────────────────────────────────────────────────────────────────────────┘
multi-thre Thread 0x7ffff7f9c7 In: main                                         L??   PC: 0x555555555130 
(gdb) layout regs
(gdb) b main
Breakpoint 1 at 0x1129
(gdb) r
Starting program: /home/igor/test/main
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".

Breakpoint 1, 0x0000555555555129 in main ()
(gdb) ni
0x0000555555555130 in main ()
(gdb) 
</code></pre>

<p>Чтобы не вводить постоянно эти команды, можно написать скрипт.</p>

<p><code>.gdbinit</code></p>

<pre><code class="language-no-highlight">layout asm
layout regs
b main
r</code></pre>

<p>После того, как вы запустите в следующий раз gdb, среди текста вам будет выведено такое сообщение с вашими путями.</p>

<pre><code class="language-no-highlight">warning: File "/home/igor/test/.gdbinit" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
To enable execution of this file add
	add-auto-load-safe-path /home/igor/test/.gdbinit
line to your configuration file "/home/igor/.config/gdb/gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/home/igor/.config/gdb/gdbinit".</code></pre>

<p>Удовлетворите это условие, и при следующих запусках gdb будет выполнять скрипт.</p><h3 id="5.1.4">5.1.4</h3><p>Инструкция <code>mov</code> имеет несколько вариантов. (Мне здесь не особо известна терминология. Возможно, правильно говорить, что есть неколько инструкций с названием <code>mov</code>.) Вариант, который мы использовали, имеет в качестве destination (назначения) регистр. Но назначение может быть также и адрес.</p>

<p>В языке C обычно мы начинаем изучение адресов с адресов локальных переменных. Однако, понятия локальной переменной в языке ассемблера нет — нам нужно организовать стек самостоятельно. Вызывать функции динамического выделения памяти мы тоже пока не можем. Придётся использовать глобальные переменные.</p>

<p>Здесь мы выполним более серьёзный анализ. Начнём с gnu assembly 64-bit.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, (%rax)
    ret</code></pre>

<p>Мы объявляем новую стандартную секцию <code>bss</code>, которая изначально заполнена нулями. С помощью директивы <code>.zero</code> мы объявляем последовательность из восьми байт, на начало которой указывает метка <code>arr</code>.</p>

<p>Посмотрим сначала на инструкцию <code>movq</code>. Мы взяли второй аргумент в скобки. Это означает, что мы хотим записать значение не в сам регистр, а по адресу регистра. Но какая размерность числа, которое мы записываем? (От этого зависит то, сколько старших байт регистра мы занулим.) Это мы явно сообщаем суффиксом <code>q</code> в слове <code>movq</code>.</p>

<p>Посмотрим на строку с инструкцией <code>leaq</code>. Её первый аргумент упоминает метку <code>arr</code>. Может показаться, что здесь упоминается регистр <code>rip</code>, который является адресом текущей инструкции. Но это не так, и это лишь директива ассемблеру, сообщающая о том, что адрес метки <code>arr</code> должен вычисляться относительно регистра <code>rip</code>. (Мы поговорим об этом отдельно. Дело в том, что в 64-bit мы хотим, чтобы все адреса в нашей программе были относительными. Это называется position independent code (PIC).)</p>

<p>Что делает инструкция <code>lea</code>? Она загружает не значение по адресу <code>arr</code> (что сделала бы инструкция <code>mov</code>), а сам адрес <code>arr</code>. (Здесь у знающих ассемблеры может быть вопрос — точно ли <code>mov</code> загружает значение? Да, и я сам не понимаю, почему в gnu assembly это работает так.)</p>

<p>Проверим программу. Запустите дебаггер и выведите память около адреса, равного значению регистра <code>rax</code>, с помощью команды <code>x</code>. (Эта команда имеет много параметров для форматирования вывода. Ищите "gdb cheet sheet".)</p>

<pre><code class="language-no-highlight">(gdb) x $rax
0x555555558011: 0x00000001</code></pre>

<p>Действительно, три нуля и единица.</p>

<p>Замените теперь инструкцию <code>leaq</code> на <code>movq</code>. Убедитесь, что программа получает SIGSEGV и дизассемблируйте её с помощью <code>objdump</code>: <code>objdump -d main</code>.</p>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre>

<p>Посмотрите на <code>opcode</code> этой инструкции: <code>0x8b</code> (число <code>48</code>, очевидно, не может быть opcode-ом, ведь эти две инструкции явно разные). Эта информация нам скоро понадобится.</p>

<p>Чтобы получить значение из ячейки по адресу, следует так же использовать скобки.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, (%rax)
    movq    arr(%rip), %rbx
    movq    (%rax), %rcx
    ret</code></pre>

<p>Так мы запишем значение по адресу <code>arr</code> в регистры <code>rbx</code> и <code>rcx</code>. (Третья и четвёртая инструкция эквивалентны, так как <code>rax</code> хранит адрес <code>arr</code>.)</p>

<p>Так мы можем работать с сдвинутыми адресами (например, обратиться к ненулевому индексу массива).</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   16

    .text
    .globl  main
main:
    leaq    arr(%rip), %rax
    movq    $1, 8(%rax)
    movq    8+arr(%rip), %rbx
    ret</code></pre>

<p>Здесь мы создали массив для двух 64-bit чисел, и обращаемся ко второму, добавляя <code>8</code> к адресам. (Синтаксис этого, конечно, очень странный. В синтаксисе <code>Intel</code> это выглядит получше.)</p><h3 id="5.1.5">5.1.5</h3><p>Инструкция lea (load effective address) загружает адрес, который может быть представлен в форме специфического арифметического выражения. Изучите эту форму (ищите по запросу "effective address"), а затем напишите одну инструкцию, которая сложит значения двух регистров и сохранит результат в третий (инструкция add так не может, так как принимает только два аргумента).</p><h3 id="5.1.6">5.1.6</h3><p>Рассмотрим, как писать 32-bit код.</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   4

    .text
    .globl  main
main:
    leal    arr, %eax
    movl    $1, (%eax)
    ret</code></pre>

<p>Здесь произошли следующие изменения:</p>

<ul>
	<li>Использованы 32-битные регисты. Их названия начинаются с буквы <code>e</code>, вместо буквы <code>r</code>.</li>
	<li>Использованы команды с размерностью четыре байта, которые определяются суффиксом <code>l</code>, так как восьмибайтных команд нет.</li>
	<li>Отсутствует директива <code>(%rip)</code>, так как теперь мы можем написать position independent executable (PIE) (для этого нужен дополнительный флаг <code>-no-pie</code>).</li>
</ul>

<p>Для компиляции в 32-bit необходимы дополнительные зависимости в системе, которые в некоторых дистрибутивах может быть непросто поставить. Выполнять компиляцию в 32-bit необязательно. Я просто хочу показать, что это такое.</p>

<p>Скомпилируем программу: <code>gcc main.s -o main -m32 -no-pie</code>. Флаг <code>-m32</code> выполняет компиляцию в 32-bit.</p>

<p>Посмотрим теперь на суффиксы размерностей инструкций.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 500px;">
	<tbody>
		<tr>
			<td> </td>
			<td>AT&amp;T</td>
			<td>Intel</td>
		</tr>
		<tr>
			<td>1</td>
			<td>b</td>
			<td>byte</td>
		</tr>
		<tr>
			<td>2</td>
			<td>w</td>
			<td>word</td>
		</tr>
		<tr>
			<td>4</td>
			<td>l</td>
			<td>dword</td>
		</tr>
		<tr>
			<td>8</td>
			<td>q</td>
			<td>qword</td>
		</tr>
	</tbody>
</table>

<p>Теперь посмотрим на регистр <code>rax</code>. Когда мы писали 32-bit код, мы использовали регистр <code>eax</code>. Однако этот же регистр есть и в 64-bit коде и он является младшими четырьмя байтами регистра <code>rax</code>.</p>

<p> Рассмотрим программу:</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    movq    $0x1122334455667788, %rax
    movl    $0xeeff, %eax
    ret</code></pre>

<p>С помощью дебаггера убедитесь, что обе инструкции действительно меняют значение регистра <code>rax</code>. Обратите также внимание на то, что инструкция <code>movl</code> также зануляет старшие четыре байта регистра.</p>

<p>Регистр <code>eax</code> имеет более маленькие составные части. Его младшие два байта покрываются регистром <code>ax</code>, первый байт покрывается регистром <code>al</code>, а второй байт покрывается регистром <code>ah</code>.</p>

<p>Рассмотрим теперь такую программу:</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    movl    $0x12345678, %eax
    movw    $0xabcd, %ax
    movb    $0xee, %al
    movb    $0xff, %ah
    ret</code></pre>

<p>Выполните её в дебаггере и обратите внимание на то, что инструкция <code>movw</code> занулила старшие два байта регистра <code>eax</code>. То же самое происходит и при использовании инструкции <code>movb</code> с регистрами <code>al</code> и <code>ah</code>.</p><h3 id="5.1.7">5.1.7</h3><p>Контент этого шага сложный и необязательный для полного понимания. Здесь я покажу, как читать машинный код.</p>

<p>Информацию обо всех инструкциях мы можем найти в instruction set architecture (ISA), который предоставляется производителем процессора. Научимся их читать. Откройте ISA AMD. (Это один из производителей процессоров архитектуры x86. Возможно, на вашем компьютере процессор AMD.)  <a href="https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf" rel="noopener noreferrer nofollow">https://www.amd.com/content/dam/amd/en/documents/processor-tech-docs/programmer-references/24594.pdf</a></p>

<p>Давайте откроем страницу с описанием инструкции <code>mov</code>.</p>

<table border="1" cellpadding="1" cellspacing="1" style="width: 800px;">
	<tbody>
		<tr>
			<td>Mnemonic</td>
			<td>Opcode</td>
			<td>Description</td>
		</tr>
		<tr>
			<td>MOV reg/mem8, reg8</td>
			<td>88 /r</td>
			<td>Move the contents of an 8-bit register to an 8-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem16, reg16</td>
			<td>89 /r</td>
			<td>Move the contents of a 16-bit register to a 16-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem32, reg32</td>
			<td>89 /r</td>
			<td>Move the contents of a 32-bit register to a 32-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem64, reg64</td>
			<td>89 /r</td>
			<td>Move the contents of a 64-bit register to a 64-bit<br>
			destination register or memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg8, reg/mem8</td>
			<td>8A /r</td>
			<td>Move the contents of an 8-bit register or memory<br>
			operand to an 8-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg16, reg/mem16</td>
			<td>8B /r</td>
			<td>Move the contents of a 16-bit register or memory<br>
			operand to a 16-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg32, reg/mem32</td>
			<td>8B /r</td>
			<td>Move the contents of a 32-bit register or memory<br>
			operand to a 32-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg64, reg/mem64</td>
			<td>8B /r</td>
			<td>Move the contents of a 64-bit register or memory<br>
			operand to a 64-bit destination register.</td>
		</tr>
		<tr>
			<td>MOV reg16/32/64/mem16,<br>
			segReg</td>
			<td>8C /r</td>
			<td>Move the contents of a segment register to a 16-bit, 32-<br>
			bit, or 64-bit destination register or to a 16-bit memory<br>
			operand.</td>
		</tr>
		<tr>
			<td>MOV segReg, reg/mem16</td>
			<td>8E /r</td>
			<td>Move the contents of a 16-bit register or memory<br>
			operand to a segment register.</td>
		</tr>
		<tr>
			<td>MOV AL, moffset8</td>
			<td>A0</td>
			<td>Move 8-bit data at a specified memory offset to the AL<br>
			register.</td>
		</tr>
		<tr>
			<td>MOV AX, moffset16</td>
			<td>A1</td>
			<td>Move 16-bit data at a specified memory offset to the AX<br>
			register.</td>
		</tr>
		<tr>
			<td>MOV EAX, moffset32</td>
			<td>A1</td>
			<td>Move 32-bit data at a specified memory offset to the<br>
			EAX register.</td>
		</tr>
		<tr>
			<td>MOV RAX, moffset64</td>
			<td>A1</td>
			<td>Move 64-bit data at a specified memory offset to the<br>
			RAX register.</td>
		</tr>
		<tr>
			<td>MOV moffset8, AL</td>
			<td>A2</td>
			<td>Move the contents of the AL register to an 8-bit memory<br>
			offset.</td>
		</tr>
		<tr>
			<td>MOV moffset16, AX</td>
			<td>A3</td>
			<td>Move the contents of the AX register to a 16-bit memory<br>
			offset.</td>
		</tr>
		<tr>
			<td>MOV moffset32, EAX</td>
			<td>A3</td>
			<td>Move the contents of the EAX register to a 32-bit<br>
			memory offset.</td>
		</tr>
		<tr>
			<td>MOV moffset64, RAX</td>
			<td>A3</td>
			<td>Move the contents of the RAX register to a 64-bit<br>
			memory offset.</td>
		</tr>
		<tr>
			<td>MOV reg8, imm8</td>
			<td>B0 +rb ib</td>
			<td>Move an 8-bit immediate value into an 8-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg16, imm16</td>
			<td>B8 +rw iw</td>
			<td>Move a 16-bit immediate value into a 16-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg32, imm32</td>
			<td>B8 +rd id</td>
			<td>Move an 32-bit immediate value into a 32-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg64, imm64</td>
			<td>B8 +rq iq</td>
			<td>Move an 64-bit immediate value into a 64-bit register.</td>
		</tr>
		<tr>
			<td>MOV reg/mem8, imm8</td>
			<td>C6 /0 ib</td>
			<td>Move an 8-bit immediate value to an 8-bit register or<br>
			memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem16, imm16</td>
			<td>C7 /0 iw</td>
			<td>Move a 16-bit immediate value to a 16-bit register or<br>
			memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem32, imm32</td>
			<td>C7 /0 id</td>
			<td>Move a 32-bit immediate value to a 32-bit register or<br>
			memory operand.</td>
		</tr>
		<tr>
			<td>MOV reg/mem64, imm32</td>
			<td>C7 /0 id</td>
			<td>Move a 32-bit signed immediate value to a 64-bit<br>
			register or memory operand.</td>
		</tr>
	</tbody>
</table>

<p>Вспомним пример:</p>

<pre><code class="language-no-highlight">    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    movq    arr(%rip), %rax
    movq    $1, (%rax)
    ret</code></pre>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre>

<p>Первая инструкция <code>mov</code> записывает значение, хранящееся по адресу (не сам адрес), в регистр. Найдем opcode <code>0x8b</code> в таблице. В первой колонке мы видим:</p>

<pre><code class="language-no-highlight">MOV regXX, reg/memXX</code></pre>

<p>Здесь мы видим, что первых аргументом должен быть регистр, а вторым регистр или адрес в памяти (который трактуется, как содержимое по этому адресу). Разве не наоборот? Да. Дело в том, что в данном ISA используется синтаксис Intel, в котором первым аргументом стоит destination. Поэтому нам придётся визуально поменять эти аргументы местами. Мы посмотрим синтаксис Intel чуть позже.</p>

<p>Посмотрим чуть внимательнее на инструкцию:</p>

<pre><code class="language-no-highlight">48 8b 05 e1 2e 00 00</code></pre>

<p>Обратите внимание: последние четыре байта — это число <code>0x00002ee1</code>. Оно хранится байтами наоборот (как и всё в архитектуре x86) как есть. Что же говорит о том, что это адрес, а не регистр, и что перемещение идёт в регистр <code>rax</code>? Третий байт, равный <code>0x05</code>. Это <code>ModR/M</code> байт, о наличии которого сообщает приписка <code>/r</code> во втором столбце. Можете найти таблицу кодирования этого байта, она общая для всех инструкций. Я же просто скажу, что число <code>0x05</code> находится на пересечении регистра <code>rax</code> и <code>disp32</code>.</p>

<p>Байт <code>0x48</code> является префиксом инструкции и, полагаю, говорит о том, что число в инструкции имеет размер четыре байта.</p>

<p>Напомню, что метка — это не более, чем число. Поэтому, и число, и метка относятся к <code>immXX</code>.</p><h3 id="5.1.8">5.1.8</h3><p>Выполните анализ второй инструкции.</p>

<pre><code class="language-no-highlight">...
0000000000001129 &lt;main&gt;:
    1129:	48 8b 05 e1 2e 00 00 	mov    0x2ee1(%rip),%rax        # 4011 &lt;arr&gt;
    1130:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
    1137:	c3                   	ret
...</code></pre><h3 id="5.1.9">5.1.9</h3><p>Мы уже увидели некоторую проблему в синтаксисе <code>AT&amp;T</code>, поэтому не будет ошибкой попробовать перейти на синтаксис <code>Intel</code>.</p>

<pre><code class="language-no-highlight">    .intel_syntax   noprefix

    .bss
arr:
    .zero   8

    .text
    .globl  main
main:
    lea     rax, arr[rip]
    movq    [rax], 1
    ret</code></pre>

<p>Что изменилось:</p>

<ul>
	<li>Операнды в инструкциях поменялись местами.</li>
	<li>Вместо круглых скобок используются квадратные.</li>
	<li>Перед названиями регистров и константами больше нет знаков <code>%</code> и <code>$</code>.</li>
</ul>

<p>Есть проблема в том, что обычно на gnu assembly не используют синтаксис intel, и в разных ассемблерах директивы разные. Мы будем использовать ассемблер <code>nasm</code>, так как он более известен среди ассемблеров с синтаксисом intel.</p>

<p>Итак, установите <code>nasm</code>. Обычно, его файлы имеют расширение <code>.asm</code>.</p>

<pre><code class="language-no-highlight">section .bss
arr:
    resb    8

section .text
global _start
_start:
    lea     rax, [rel arr] ; comment
    mov     qword [rax], 1
    ret</code></pre>

<p>Это та же самая программа на nasm-е. Обратите внимание: директивы теперь выглядят совсем по другому.</p>

<ul>
	<li>При объявлении секции присутствует ключевое слово <code>section</code></li>
	<li>Вместо <code>.globl</code> теперь <code>global</code></li>
	<li>Другой синтаксис обозначения размерности инструкции: вместо <code>movq</code> теперь <code>mov qword</code></li>
	<li>Другой синтаксис обозначения того, что адрес относительно <code>rip</code>: вместо <code>arr[rip]</code> теперь <code>[rel arr]</code></li>
	<li>Комментарии начинаются с символа <code>;</code>.</li>
</ul>

<p>В общем, хоть синтаксис и одинаковый, код для этих ассемблеров плохо совместим.</p>

<p>Обратите внимание на метку: теперь используется метка <code>_start</code>. Это стартовая метка для стандартного linker script-а ассемблера <code>nasm</code>. В отличии от gnu assembly исполнение здесь начинается непосредственно с нашего кода.</p>

<p>Выполним компиляцию и компоновку.</p>

<pre><code class="language-no-highlight">$ nasm -felf64 main.asm -o main.o
$ ld main.o -o main</code></pre>

<p>При запуске программы вы получите SIGSEGV. Это происходит из-за инструкции <code>ret</code>, так как она переходит к внешней функции с помощью стека, а на данный момент у нас стек пустой.</p>

<p>Проверим entry point.</p>

<pre><code class="language-no-highlight">$ objdump -d main

main:     file format elf64-x86-64


Disassembly of section .text:

0000000000401000 &lt;_start&gt;:
  401000:	48 8d 05 f9 0f 00 00 	lea    0xff9(%rip),%rax        # 402000 &lt;__bss_start&gt;
  401007:	48 c7 00 01 00 00 00 	movq   $0x1,(%rax)
  40100e:	c3                   	ret    
$ readelf -h main
...
  Entry point address:               0x401000
...</code></pre>

<p>Entry point (то есть, первая исполняемая инструкция) действительно метка <code>_start</code>.</p><h3 id="5.1.10">5.1.10</h3><p>Далее для удобства мы будем использовать ассемблер <code>nasm</code>.</p>

<p>Изучим арифметические инструкции. Инструкции <code>add</code> и <code>sub</code> для сложения и вычитания являются очевидными. Посмотрим на инструкцию <code>mul</code> для умножения.</p>

<p>В ISA AMD написано:</p>

<blockquote>
<p>Multiplies the unsigned byte, word, doubleword, or quadword value in the specified register or<br>
memory location by the value in AL, AX, EAX, or RAX and stores the result in AX, DX:AX,<br>
EDX:EAX, or RDX:RAX (depending on the operand size). It puts the high-order bits of the product in<br>
AH, DX, EDX, or RDX.</p>

<p>If the upper half of the product is non-zero, the instruction sets the carry flag (CF) and overflow flag<br>
(OF) both to 1. Otherwise, it clears CF and OF to 0. The other arithmetic flags (SF, ZF, AF, PF) are<br>
undefined.</p>
</blockquote>

<p>Данная инструкция принимает только один операнд (причём, не imm), а в качестве второго использует регистр <code>*A*</code>. При размерности операндов равной <code>X</code> младшие <code>X</code> байт результата помещается в регистр <code>*A*</code>, а старшие в регистр <code>*D*</code>. Во втором абзаце упоминаются некие флаги.</p>

<p>В x86 есть специальный регистр <code>FLAGS/EFLAGS/RFLAGS</code>, к которому у нас нет свободного доступа, но на который влияют многие инструкции. В данном случае при переполнения младших <code>X</code> байт результата нас дополнительно уведомляют об этом, включая биты, соответствующие флагам <code>carry</code> (перевод в следующий разряд) и <code>overflow</code> (переполнение). (Эти флаги не эквивалентны при знаковых вычислениях.) Здесь есть странность терминологии: часто под "включает флаг, если X" подразумевается также "выключает флаг, если не X".</p>

<pre><code class="language-no-highlight">section .text
global _start
_start:
    mov     eax, 0xffffffff
    mov     ebx, 0x2
    mul     ebx
    ret</code></pre>

<p>Посмотрим на это в gdb (не забудьте поставить точку останова на метку <code>_start</code>). Мы можем вывести флаги с помощью команды <code>p $eflags</code>.</p>

<pre><code class="language-no-highlight">(gdb) p $eflags
$4 = [ CF IF OF ]</code></pre>

<p> Помимо carry flag и overflow flag у нас также есть следующие арифметические флаги (это их примерные словесные описания, так как инструкции, работающие с ними, разные):</p>

<ul>
	<li>Parity flag — чётность количества единичных битов в результате (когда это может быть полезно?).</li>
	<li>Zero flag — равен ли результат нулю.</li>
	<li>Sign flag — отрицателен ли результат.</li>
	<li>Direction flag — в какое направление будет идти итерирование по массиву при выполнении инструкций циклов. Мы сами управляем этим флагом.</li>
</ul>

<p>На остальные флаги мы влиять не можем или они для нас бесполезны. IF — это interrupt flag, который выключается инструкцией <code>cli</code>. Что будет, если мы её выполним?</p>

<pre><code class="language-no-highlight">section .text
global _start
_start:
    cli
    ret</code></pre>

<p>При выполнении этой инструкции мы получим SIGSEGV. Некоторые инструкции, например, cli, требуют большие права для выполнения. Условно, на текущий уровень прав ссылаются сегментные регистры, и мы на них влиять не можем (иначе в чём смысл такой защиты?).</p><h3 id="5.1.11">5.1.11</h3><p>Control flow выполняется с помощью условных прыжков, которые совершают переход к адресу при условии, что какой-то флаг включен. Например, инструкция <code>jz</code> выполняет прыжок, если включен ZF.</p>

<p>Мы можем написать <code>if (rax == rbx)</code> такой последовательностью инструкций:</p>

<pre><code class="language-no-highlight">    sub     rax, rbx
    jz      if_true</code></pre>

<p>Если при выполнении инструкции вычитания получается ноль, то включается ZF. Если он включен, выполняется переход не к инструкции, следующей за инструкцией <code>jz</code>, а к метке <code>if_true</code>.</p>

<p>Рассмотрим более полный пример. Так мы пишем if statement на языке ассемблера.</p>

<pre><code class="language-no-highlight">section .text
global _start
_start:
    mov     rax, 1
    mov     rbx, 2

    sub     rax, rbx
    jz      if_true
if_else:
    mov     rcx, 0
    jmp     if_end
if_true:
    mov     rcx, 1
if_end:

    ret</code></pre>

<p>Проследите за логикой прыжков когда регистры rax и rbx равны, и когда не равны.</p>

<p>Не много ли меток (метка <code>if_else</code> присутствует для наглядности и не используется)? Давайте посмотрим, как скомпилирует if statement компилятор gcc.</p>

<pre><code class="language-cpp">int main() {
    int a = 1, b = 2, c;
    if (a == b) {
        c = 1;
    }
    else {
        c = 0;
    }
    return 0;
}</code></pre>

<pre><code class="language-no-highlight">$ gcc main.c -S -masm=intel -o main.s</code></pre>

<pre><code class="language-no-highlight">...
	cmp	eax, DWORD PTR -8[rbp]
	jne	.L2
	mov	DWORD PTR -4[rbp], 1
	jmp	.L3
.L2:
	mov	DWORD PTR -4[rbp], 0
.L3:
...</code></pre>

<p>Здесь есть следующие отличия:</p>

<ul>
	<li>Вместо регистров используется стек. Конечно, я не могу заставить компилятор использовать регистры, ведь это смысл компилятора — использовать регистры эффективно. Поэтому он обращается к стеку, адрес которого содержится в регистре <code>rbp</code>. Чуть позже мы это изучим.</li>
	<li>Вместо инструкции <code>sub</code> используется инструкция <code>cmp</code>. Она выставляет флаги так же, как и инструкция <code>sub</code>, но сам destination регист не меняет.</li>
	<li>Вместо инструкции <code>jz</code> используется инструкция <code>jne</code> — jump not equal, которая выполняет прыжок, если ZF выключен.</li>
</ul>

<p>В остальном, сама структура меток и прыжков полностью идентична нашей.</p>

<p>Изучите самостоятельно все conditional jump инструкции, например, <code>jl</code> (jump less), <code>jg</code> (jump greater) и т.д.</p>

<p>Помимо обычных меток есть и локальные метки, названия которых начинаются с символа <code>.</code>.</p>

<pre><code class="language-no-highlight">section .text
global _start

_start:
    jmp     .aba
.1:
    jmp     foo
.aba:
    jmp     .1

foo:
    jmp     .1
.1:
    jmp     $</code></pre>

<p>В данном примере nasm транслирует название локальной метки <code>.1</code> под меткой <code>_start</code> в <code>_start.1</code>, название локальной метки <code>.aba</code> под меткой <code>_start</code> в <code>_start.aba</code>, а название локальной метки <code>.1</code> под меткой <code>.foo</code> в <code>foo.1</code>. Попробуйте самостоятельно проследить за порядком выполнения инструкций в этой программе.</p>

<p>Оператор <code>$</code> транслируется в адрес начала текущей инструкции, поэтому в результате выполнения инструкции <code>jmp $</code> мы перейдем в неё же, создав бесконечный цикл.</p>

<p>Существует также оператор <code>$$</code>, который транслируется в адрес начала текущей секции. Однако область его применения достаточно специфична, поэтому мы на него здесь не посмотрим.</p><h3 id="5.1.12">5.1.12</h3><p>Напишите циклы while, do while и for.</p><h3 id="5.1.13">5.1.13</h3><p>В x86_64 есть следующие регистры общего назначения: <code>rax</code>, <code>rbx</code>, <code>rcx</code>, <code>rdx</code>, <code>rdi</code>, <code>rsi</code>, <code>rbp</code>, <code>rsp</code>, <code>r8</code>, <code>r9</code>, <code>r10</code>, <code>r11</code>, <code>r12</code>, <code>r13</code>, <code>r14</code>, <code>r15</code>. Изучить их составные регистры можно по этой картинке: <a href="https://upload.wikimedia.org/wikipedia/commons/1/15/Table_of_x86_Registers_svg.svg" rel="noopener noreferrer nofollow">https://upload.wikimedia.org/wikipedia/commons/1/15/Table_of_x86_Registers_svg.svg</a></p>

<p>У этих регистров есть роли. Некоторые из этих ролей задаются самой архитектурой (например, инструкция mul выполняла перемножение строго с регистром rax), некоторые задаются "стилем" написания кода, который называется Application Binary Interface (ABI).</p>

<p>Посмотрим на роли со стороны архитектуры. Для работы с массивами мы используем инструкции <code>stos</code> и <code>lods</code>. Первая инструкция копирует данные в маcсив, в вторая — их массива. Прочитаем их описание в ISA.</p>

<blockquote>
<p>STOS<br>
STOSB<br>
STOSW<br>
STOSD<br>
STOSQ</p>

<p>Copies a byte, word, doubleword, or quadword from the AL, AX, EAX, or RAX registers to the<br>
memory location pointed to by ES:rDI and increments or decrements the rDI register according to the<br>
state of the DF flag in the rFLAGS register.<br>
If the DF flag is 0, the instruction increments the pointer; otherwise, it decrements the pointer. It<br>
increments or decrements the pointer by 1, 2, 4, or 8, depending on the size of the value being copied.</p>
</blockquote>

<p>Рассмотрим код, выполняющий эту инструкцию.</p>

<pre><code class="language-no-highlight">section .bss
arr:
    resb 32

section .text
global _start
_start:
    mov     rax, 0x1122334455667788
    lea     rdi, arr
    stosq
    stosq
    stosq
    stosq
    ret</code></pre>

<p>Здесь мы четыре раза кладём значение регистра rax в очередные восемь байт массива. Посмотрим содержимое массива после выполнения этих инструкций. (Здесь <code>32</code> — это количество блоков, <code>x</code> — это формат вывода (шестнадцатеричный), <code>b</code> — это размерность блока.)</p>

<pre><code class="language-no-highlight">...
(gdb) x/32xb &amp;arr
0x402000:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402008:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402010:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402018:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
...</code></pre>

<p>Обратите внимание на второй абзац описания инструкции — там упоминается о том, что есть мы установим direction flag, то итерирование будет в обратную сторону. Чтобы включить и выключить DF, следует использовать инструкции <code>std</code> и <code>cld</code>. Помните, что он глобальный, что может поломать функции, которые вы вызываете.</p>

<pre><code class="language-no-highlight">section .bss
arr:
    resb    32

section .text
global _start
_start:
    std
    mov     rax, 0x1122334455667788
    lea     rdi, arr
    stosq
    stosq
    stosq
    stosq
    ret</code></pre>

<p>После выполнения первой инструкции <code>stosq</code> у вас будет такая картина:</p>

<pre><code class="language-no-highlight">...
(gdb) x/32xb &amp;arr
0x402000:       0x88    0x77    0x66    0x55    0x44    0x33    0x22    0x11
0x402008:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402010:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x402018:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
...</code></pre>

<p>При выполнении второй инструкции вы получите SIGSEGV, так как значение регистра edi будет на <code>0x402000</code>, а <code>0x401ff8</code>.</p>

<p>Самостоятельно прочитайте описание инструкции <code>lods</code>. Рассмотрим программу:</p>

<pre><code class="language-no-highlight">section .data
arr:
    dw      0xaaaa, 0xbbbb, 0xcccc

section .text
global _start
_start:
    lea     rsi, arr
    lodsw
    lodsw
    lodsw
    ret</code></pre>

<p>Чтобы было, что копировать из памяти, я создал инициализированный массив. Он должен находиться в секции <code>data</code> (так как секция <code>bss</code> хранит только нули). Директива <code>dw</code> означает, что мы хотим положить в секцию words (2 байта), которые перечислены далее (аналогично, есть директивы <code>db</code>, <code>dd</code>, и <code>dq</code>).</p>

<p>Выполните программу в дебаггере и убедитесь, что значние регистра <code>al</code> меняется после каждого выполнения инструкции <code>lodsw</code> на очередной элемент массива.</p><h3 id="5.1.14">5.1.14</h3><p>Напишите программу, которая выполнит копирование из одного ноль-терминированного массива в другой с помощью функций lods и stos.</p>
      </main>
    </div>
  </div>
</body>

</html>
